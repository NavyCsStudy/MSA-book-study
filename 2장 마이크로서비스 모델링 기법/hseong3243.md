## 1. 뮤직코프 소개

가상 시나리오: 뮤직코프
- 오프라인 판매 -> 온라인 음악 CD 판매에 집중 전략을 세운 소매 업체

## 2. 올바른 마이크로서비스 경계를 만드는 것은 무엇인가?

마이크로서비스를 독립적으로 릴리스 할 수 있는 능력은 중요하다. 그렇다면 서비스 경계를 정하기 위해서는 어떤 점을 염두에 둬야 하는가?
- 마이크로서비스는 네트워크 기반의 상호작용이 이루어지나 결국 모듈식 분해의 다른 형태이다.
- 모듈식 소프트웨어와 구조적 프로그매이 영역에 존재하는 선행 기술에 의지할 수 있다.

### 2.1 정보 은닉(Information hiding)

정보 은닉은 모듈 경계 뒤에 가능한 한 많은 세부 정보를 숨기려는 욕구를 나타낸다. 정보 은닉은 다음과 같은 이점을 가진다.

#### 향상된 개발 시간
- 모듈의 독립적 개발을 통한 병렬 작업 수행 가능
- 프로젝트에 더 많은 개발자를 추가하는데서 오는 영향을 줄일 수 있다.

#### 이해도
- 각 모듈을 따로 살펴보고 이해할 수 있다.
- 시스템 전체가 수행하는 작업을 더 쉽게 이해하도록 해준다.

#### 유연성
- 모듈의 독립적 변경이 가능해진다.
- 모듈을 다양한 방식으로 결합해 새로운 기능을 제공할 수 있다.

정보 은닉은 모듈식 아키텍처를 최대한 활용하는 데 도움이 되는 핵심 기법이었다. 이는 마이크로서비스에도 동일하게 적용된다.

정보 은닉을 이라는 개념을 만든 데이비드 파나스는 다음과 같이 말했다.

> 모듈 간 연결은 모듈이 서로에게 만드는 가정(assumption)이다.

가정의 수를 작게 유지하면, 다른 모듈에 영향을 미치지 않고 하나의 모듈을 변경하기 더 쉽다. 개발자가 다른 사람들이 해당 모듈을 어떻게 사용하는지 이해하고 있다면, 업스트림 호출자도 변경할 필요가 없는 방식으로 안전하게 변경하도록 만들 가능성이 더 높다.

### 2.2 응집력(cohension)

응집력의 가장 간결한 정의 중 하나는 '함께 바뀌고 함께 머무는 코드'다.
우리는 비즈니스 기능을 쉽게 변경할 수 있도록 msa를 최적화하려 한다. 따라서 가능한 한 적은 장소에서 변경할 수 있는 방식으로 기능을 그룹으로 묶으려 한다.

여러 곳에서 행동을 변경해야 한다면 변경 사항을 제공하기 위해 서로 다른 많은 서비스를 함께 릴리스해야 할 것이다. 이는 느리고, 위험하므로 가능하면 피하고 싶은 일이다.

따라서 문제 영영 내에서 관련 동작을 한 곳으로 모으며, 다른 경계와 가능한 한 느슨하게 통신할 수 있는 경계를 찾길 원한다.

### 2.3 결합(coupling)

결합은 다양한 형태로 발생할 수 있다.

서비스가 느슨한 결합을 가지면 한 서비스를 변경할 때 다른 것은 변경할 필요 없다.

느슨하게 결합된 서비스는 협업하는 서비스들에 대해 필요한 만큼만 알고 있다. 또한 한 서비스에서 다른 서비스로 다양한 유형의 호출 수를 성능 문제, 과한 커뮤니케이션을 줄이려 한다.

### 2.4 결합과 응집력의 연관성

논리적으로 연관된 기능이 시스템 전체에 분산되어 있다면, 기능에 대한 변경이 경계를 넘어 전파돼 더 긴밀한 결합을 나타낸다.

> 콘스탄틴의 법칙
> 응집력이 강하고 결합도가 낮으면 구조가 안정된다.

#### 안정성(stability)
- 마이크로서비스 경계에서 각 서비스를 병렬로 작업하고 협업하는 팀 간의 조정 작업량을 줄이려면, 경계 자체에 어느 정도의 안정성이 필요
- 서비스가 제공하는 계약이 하위 호환성을 깨뜨리는 방식으로 계속 변경되면 상위 소비자도 지속적으로 변경

결합도와 응집력은 연관된 개념이다. 응집력은 경계 내부에 있는 사물 사이의 관계에 적용된다. 결합은 경계 건너에 있는 사물 간의 관계를 설명한다.

떄로는 시스템이 일부가 너무 많이 변경되어 안정성을 보장하지 못할 수 있다.

## 3. 결합 유형

모든 결합이 나쁜 것은 아니다. 시스템에서 일부 결합을 피할 수 없으며, 우리는 결합의 양을 줄이기 원한다.

결합의 중첩 및 충돌을 평가하는 다양한 모델 중 상당수는 서비스 기반 상호작용보다는 코드 수준이다. 마이크로서비스 또한 이러한 개념을 적용할 수 있다.

<img width="662" height="164" alt="스크린샷 2025-10-07 오후 10 07 49" src="https://github.com/user-attachments/assets/8bb999e8-3faf-4066-9a88-acf68ced9d21" />

### 3.1 도메인 결합(domain coupling)

- 도메인 결합은 첫 번째 서비스가 다른 서비스가 제공하는 기능을 사용해야 하므로 하나의 마이크로서비스가 다른 마이크로서비스와 상호작용해야 하는 상황
- 주문 처리기는 CD 주문을 관리하기 위해 창고, 결제 서비스에 의존하고 결합된다. 하지만 창고와 결제 서비스 사이에는 상호작용이 없으므로 결합도 없다.

<img width="703" height="411" alt="스크린샷 2025-10-07 오후 10 10 40" src="https://github.com/user-attachments/assets/b83a629d-785e-43a8-978a-f1928d9ef735" />

- msa에서 이러한 유형의 상호작용은 대개 불가피
- 도메인 결합은 느슨한 형태의 결합으로 간주
- 그러나 많은 하위 서비스와 통신하는 마이크로서비스 -> 많은 로직이 집중됨. 서비스 간에 더 복잡한 데이터 집합이 전송됨에 따라 문제가 될 수 있다.
- 정보 은닉의 중요섬을 명심하여 꼭 필요한 데이터만 전송할 수 있도록 해야 함

> 시간적 결합(temporal coupling)
> 코드 중심적 관점에서는 동시에 발생하기 때문에 함께 엮이는 상황을 나타낸다.
> 분산 시스템의 관점에서는 하나의 서비스가 작업을 완료하기 위해 동시간에 어떤 작업을 수행하는 다른 마이크로서비스가 필요한 상황을 나타낸다.
> <img width="671" height="210" alt="스크린샷 2025-10-07 오후 10 15 44" src="https://github.com/user-attachments/assets/b6036215-54b8-42ee-a7e2-3589fe3b9dc1" />
> 어떠한 이유로 서비스간 통신이 불가하다면 작업이 실패하거나 잠재적으로 리소스 경합과 관련된 문제를 유발할 수 있다.
>
> 시간적 결합이 나쁘지는 않다. 그러나 서비스가 늘어나고 복잡해짐에 따라 시간적 결합 문제가 증가한다. 이를 피하는 한 가지 방법은 메세지 브로커와 같은 비동기 통신 형태를 사용하는 겻이다.

### 3.2 통과 결합(pass-through coupling)

-통과 결합은 데이터가 다른 하위 마이크로서비스에 필요하다는 이유만으로 한 서비스가 다른 서비스에 데이터를 전달하는 상황
- 이는 호출 서비스의 존재와 동작까지 알아야 함을 의미

- 주문 처리기는 창고 서비스에 배송 목록을 포함한 요청을 보낸다. 창고 서비스는 배송 목록을 다른 서비스에 그대로 전달한다.

<img width="703" height="355" alt="스크린샷 2025-10-08 오후 10 39 36" src="https://github.com/user-attachments/assets/c6b13418-5005-4bee-b935-20b7a1c5557e" />

- 하위에서 데이터를 변경하면 상위에서 더 큰 변경을 일으킬 수 있음. 즉 위 그림에서 배송 서비스의 데이터 포맷 변경이 창고, 주문 처리기에까지 영향을 미칠 수 있다.
- 문제를 해결하는 첫번째 방법.
  - 데이터가 필요한 하위 서비스와 직접 통신하도록 변경
  - 이렇게 하면 상위 서비스가 알아야 하는 서비스가 추가되므로 도메인 결합이 발생하며, 서비스간 통신 순서와 같은 내용을 상위 서비스가 알아야 함

<img width="714" height="436" alt="스크린샷 2025-10-08 오후 10 46 09" src="https://github.com/user-attachments/assets/5f74ebb8-4de8-48f8-8472-604605ef8dac" />

- 두번째 방법.
  - 배송 서비스가 배송 목록을 원한다는 사실을 숨긴다.
  - 중간 서비스는 계약의 일부로 필요한 정보를 받아 로컬에서 필요한 데이터를 만든다.
  - 하지만 하위 서비스에서 추가로 필요한 데이터가 생긴다면 주문 처리기는 추가 정보를 전달해야할 수도 있다. 두번째 방법 역시 여전히 모든 서비스의 변경이 필요할 것이다. 하지만 세부사항을 숨길 수 있기 떄문에 첫번째에 비하면 더 쉬운 배포 단계를 진행할 수 있다.

<img width="699" height="347" alt="스크린샷 2025-10-08 오후 10 47 55" src="https://github.com/user-attachments/assets/5636456b-379b-428f-a92b-ff4a22b00567" />

- 마지막 방법.
  - 주문 처리기가 여전히 창고 서비스가 필요한 배송 목록을 보내지만 중간 서비스가 그 내용을 알지 못하게 한다.
  - 중간 서비스는 관련된 필드를 보지 못하게 처리. 배송 목록 형식을 변경해야 한다면 주문 처리기, 배송 서비스는 모두 변경해야 하지만, 창고 서비스는 그에 대해 관심이 없기 때문에 변경할 필요가 없다.

### 3.3 공통 결합(common coupling)

- 공통 결합은 둘 이상의 서비스가 공통 데이터 집합을 사용할 때 발생
- 예를 들어 동일한 공유 데이터베이스를 여러 서비스가 사용하는 경우
- 공통 결합의 문제점은 데이터 구조 변경이 한 번에 여러 서비스에 영향을 미친는 것. 스키마가 하위 호환되는 방식으로 변경되지 않는다면 모든 데이터 소비자를 변경해야 한다.

<img width="783" height="431" alt="스크린샷 2025-10-08 오후 10 57 44" src="https://github.com/user-attachments/assets/aedcc365-4a07-4b3c-a0e9-4d6e4e0c7320" />

- 한 서비스의 변경이 다른 서비스와 호환되게 변경되었는지 어떻게 확신할 수 있을까?
  - 어떤 상태가 올바른 방식으로 변경됐는지 확인하는 한 가지 방법은 유한 상태 기계(finite state machine)을 만드는 것이다. 이를 이용해 개체의 상태 잘못된 상태 전환을 방지할 수 있다.

<img width="781" height="217" alt="스크린샷 2025-10-08 오후 11 00 46" src="https://github.com/user-attachments/assets/d9b84e5f-4972-4a59-96e7-426f14c5282c" />

- 이러한 상황의 잠재적인 해결책은 하나의 서비스가 상태를 관리하게 하는 것이다. 다른 서비스들은 주문 서비스에 상태 업데이트 요청을 보낼 수 있다.
- 이때 주문 서비스는 해당 주문에 대한 `진실의 원천(source of truth)`이다. 
- 주문 상태를 변경하는 것은 오로지 주문 서비스의 책임. 다른 서비스들은 단순히 요청을 보낼 뿐이다. 잘못된 요청을 보낸다면 주문 서비스는 해당 요청을 거부할 수 있다.

> tip
> 마이크로서비스에서 전송된 요청이 유효하지 않을 경우 하위 마이크로서비스가 거부할 수 있는지 확인하라.
> 중요한 팁이다.

### 3.4 내용 결합(content coupling)

- 내용 결합은 상위 서비스가 하위 서비스의 내부까지 도달해 서비스의 내부 상태를 변경하는 상황
- 이를 빈번하게 일으키는 경우는 다른 서비스의 데이터베이스에 액세스해 직접 변경하는 외부 서비스. 공통 결합에서는 공유된 외부 의존성이 나의 통제하에 있지 않으나 내용 결합에서는 소유권의 경계가 모호하여 개발자가 시스템을 변경하기 어렵게 만든다.
- 앞서 내용 결합의 주문 서비스의 상태 관리 책임을 우회하여 다른 서비스가 테이블을 직접 변경한다면 어떻게 될까? 최악의 경우 이는 서비스 붕괴를 야기할 수 있다. 

<img width="770" height="544" alt="스크린샷 2025-10-08 오후 11 33 26" src="https://github.com/user-attachments/assets/f0db418e-b5a5-4c45-af8b-8238cf430408" />

- 이 문제를 쉽게 해결하는 방법은 모든 변경이 오직 주문 서비스만을 통하도록 하는 것
- 마이크로서비스에서는 변경 가능한 부분과 그렇지 못한 부분을 명확히 분리하는 것이 중요. 개발자는 서비스가 외부에 노출하는 계약 부분의 기능 변경 시점을 알아야 한다. 변경할 경우에도 상위 서비스가 중단되지 않도록 해야 한다. 계약에 영향을 주지 않는 기능은 무난하게 변경할 수 있다.
- 외부에서 직접 데이터베이스에 액세스하도록 허용하면 변경 가능한 것과 불가능한 부분을 쉽게 추론할 수 없게 된다. 이는 반드시 피해야 하는 결합이다.

## 4. 딱 도메인 주도 설계만큼

마이크로서비스 경계를 찾는 데 사용되는 기본 메커니즘은 도메인 주도 설계이다.

### 4.1 보편 언어

- 의사소통을 돕기 위해 코드와 도메인 설명에 사용할 공통 언어를 정의하고 채택한다.
- 보편 언어를 사용하여 개발자들은 도메인을 더 쉽게 모델링하고 이해 관계자 사이의 의사소통을 향상 시킬 수 있다. 개발자는 도메인 전문가의 풍부한 도메인 언어를 코드에 적용하고 유저 스토리를 통해 개념을 더욱 잘 이해할 수 있다.

### 4.2 애그리거트

- 객체들의 집합이며 일반적으로 실제 세계 개념과 관련된 하나의 개체로 관리된다.
- 애그리거트는 실세계의 개념을 나타낸다. 자신만의 독립된 수명 주기를 가지며 상태 기계(state machine)로 구현할 수 있다.
- 하나의 서비스는 여러 애그리거트를 관리할 수 있지만, 하나의 애그리거트는 하나의 서비스에 관리되어야 한다. 만일 외부 시스템이 애그리거트에 상태 전이를 요청하더라도 애그리거트는 이를 거절할 수 있다는 사실을 이해해야 한다.
- 애그리거트는 다른 애그리거트와 관련성을 가질 수 있다. 서비스 경계를 넘는 연관 관계는 애그리거트의 ID를 통해 표현할 수 있다.

<img width="785" height="295" alt="스크린샷 2025-10-09 오후 5 49 24" src="https://github.com/user-attachments/assets/7612ae59-d62d-4abc-a0fd-7129964dc5c3" />

- 다만 애그리거트의 ID를 이용한 관계는 암묵적이다. ID가 어떻게 사용됐는지 알아보려면 해당 애그리거트를 관리하는 서비스 코드를 살펴봐야 한다.
- 명확한 관계를 표현하기 위해 REST 기반 시스템을 만들 때 사용하는 URI를 사용할 수도 있다. 이는 명시적이며 URI를 직접 역참조해 관련 자원을 조회할 수 있다.

<img width="766" height="461" alt="스크린샷 2025-10-09 오후 5 51 53" src="https://github.com/user-attachments/assets/116df4d1-6b3f-468e-912a-159f210c8f75" />

하지만 REST 기반 시스템이 아니라면? 사운드클라우드의 수도 URI 스킴이라는 방법도 있다. 예를 들어 `soundcloud:tracks:123`은 ID가 123인 트랙에 대한 참조다. 읽기 쉽고 애그리거트 간 상호 조회 코드를 쉽게 작성할 수 있을 것이다. 

### 4.3 바운디드 컨텍스트
- 더 큰 범위의 시스템에 대한 기능을 제공하지만 복잡성을 숨기는 비즈니스 도메인 내부의 명시적인 경계다.
- 바운디드 컨텍스트는 보다 큰 구조적 경계를 나타낸다. 이는 구현 세부 사항을 숨기는 경계이다.
- 구현 관점에서 바운디드 컨텍스트는 애그리거트를 하나 이상 포함한다. 일부 애그리거트는 컨텍스트 외부로 노출될 수도 있고, 어떤 것들은 내부에 숨겨져 있을 수 있다. 

#### 은닉 모델

- 서로 다른 컨텍스트간에 기능을 수행하기 위해 정보를 공유해야 할 수 있다.
- 모든 데이터를 맹목적으로 노출할 필요는 없다. 따라서 내부 전용 표현과 노출용 외부 표현이 따로 존재한다.

<img width="782" height="288" alt="스크린샷 2025-10-09 오후 6 43 12" src="https://github.com/user-attachments/assets/6871ebcf-aef8-4829-9502-57c7ef7d3bc6" />

#### 공유 모델

- 둘 이상의 컨텍스트에서 나타나는 개념도 존재할 수 있다. 이러한 공유 모델은 서로 다른 의미를 가질 수 있어 다른 이름으로 불릴 수 있다. 

### 4.4 애그리거트와 경계 콘텍스트를 마이크로서비스에 매핑

- 애그리거트와 바운디드 컨텍스트는 잘 정의된 인터페이스로 응집력의 단위를 제공
- 둘 다 서비스의 경계로 잘 작동할 수 있다.
- 경험을 통해 서비스를 더 작은 서비스로 분해하기로 결정하게 될 때는 애그리거트 자체의 분리를 원하지 않는다는 사실을 기억해야 한다. 즉, 하나의 애그리거트가 둘 이상의 서비스에서 관리되는 상황은 원치 않는다.

#### 거북이 아래 거북이

- 시간이 지남에 따라 하나의 컨텍스트는 더 많은 컨텍스트를 포함할 수 있다. 마이크로서비스 경계를 고려할 때 대분화된 컨텍스트의 관점에서 먼저 생각해본 후 내부 컨텍스트의 이음새를 분리하는 장점을 찾는다면 내부 컨텍스트에 따라 세분화한다.
- 컨텍스트를 더 작은 서비스로 분해하기로 결정했더라도 소비자에게 큰 단위의 api를 제공하는 방식으로 이러한 결정을 숨기는 기법이 존재한다. 서비스를 쪼개는 결정은 구현 결정이므로 가능하다면 숨기는 것이 좋을 것이다. 

<img width="805" height="421" alt="스크린샷 2025-10-09 오후 7 01 10" src="https://github.com/user-attachments/assets/0415d080-27ec-4960-bc06-2caaea82da92" />

- 이는 정보 은닉의 한 형태. 테스트를 단순화하기도 쉽다. 각 서비스를 스텁하는 대신 큰 단위의 api만 있으면 된다. 이는 더 큰 범위의 테스트를 고려할 때 격리 단위를 제공한다.

### 4.5 이벤트 스토밍(event storming)

- 이벤트 스토밍은 도메인 모델을 표현화하도록 설계된 협력적인 브레인스토밍 훈련
- 이해 관계자 모두가 다 같이 참여하는 공동 작업을 의미한다.

- 모델링 도구로는 포스트잇을 주로 사용하며 색상으로 서로 다른 개념을 나타낸다.

1. 작업은 도메인 이벤트를 식별하는 것에서 시작한다. 이는 시스템에서 발생하는 일을 나타내며 관심 대상이 되는 이벤트다.
2. 다음은 이벤트를 발생시키는 명령을 식별한다. 명령은 사람이 무언가를 하려고 내리는 결정이다. 시스템의 경계를 이해하고 핵심이 되는 액터(actor)를 식별하려 한다.
3. 다음은 애그리거트다. 이 단계에서느 이벤트는 잠재적인 애그리거트가 무엇인지 강조하기 시작한다. '주문 접수'라는 도메인 이벤트에서 '주문'은 잠재적인 애그리거트가 될 수 있고 '접수하다'는 애그리거트 수명주기의 한 부분이 될 수 있다.
4. 식별된 애그리거트들은 바운디드 컨텍스트에 묶인다. 일반적으로 회사의 조직 구조를 따른다.

## 5. 마이크로서비스를 위한 도메인 주도 설계 사례

DDD는 msa에서 얼마나 유용한가?

첫째, ddd의 바운디드 컨텍스트가 정보 은닉에 명시적으로 사용된다. 이는 시스템의 명확한 경계를 제시하여 안정적인 마이크로서비스의 경계를 찾는 데 매우 중요하다.
둘째, 보편 언어는 마이크로서비스 엔드포인트를 정의할 때 큰 도움이 된다. 이를 통해 api와 이벤트 포맷 등을 만들 때 참고할만한 용어를 제공할 수 있다. 또한 컨텍스트 안에서 언어 변경 가능성을 고려해 api 표준화 범위에 대한 문제를 해결하는 데도 도움이 된다.

## 6. 비즈니스 도메인 경계에 대한 대안

물론 ddd가 마이크로서비스 경계를 찾기 위한 유일한 기술은 아니다.

### 6.1 변동성(volatility)

- 시스템에서 빈번하게 변경되는 부분을 식별하여 해당 기능을 자체 서비스로 추출하면 더 효과적으로 작업이 가능할 수 있다. 하지만 애플리케이션의 확장이 주요한 관심사라면 변동성을 기반으로 한 분해에서 얻을 수 있는 장점이 크지는 않을 것이다.

### 6.2 데이터

- 보유하고 관리할 데이터의 특징에 따라 분해가 발생할 수도 있다.
- 개인정보를 다루는 영역은 외부 감사가 필요할 수 있다. 이를 기준으로 개인정보가 결코 유입되어서는 안되는 블루존, 개인정보가 다루어지는 그레이존으로 시스템을 나눌 수도 있다.

<img width="776" height="647" alt="스크린샷 2025-10-09 오후 9 16 29" src="https://github.com/user-attachments/assets/a528fb94-afa6-493a-ad43-00939e624d3f" />

### 6.3 기술

- 다른 기술을 사용해야 할 필요성도 경계를 찾아내는 요소가 될 수 있다.
- 기술이 분해 수단으로 채택된다면 그 기술이 우리를 어디로 이끄는지 알고 있어야 한다. 1장에서 살펴본 것과 같이 관련 기술로 묶인 3계층 아키텍처는 이상적인 아키텍처라고 말할 수는 없었다.

#### 6.4 조직

- 조직을 어떻게 구성하느냐에 따라 시스템 아키텍처가 결정
- 서비스 경계를 정의하는 데 있어 이를 의사결정의 핵심 부분으로 고려해야 한다.
- 소유권이 여러 팀에 걸쳐져있는 서비스에 대한 경계를 정의하려 한다면 원하는 결과를 얻지 못할 것이다. 상황에 따라 원하는 아키텍처를 이루기 위해 조직 구조의 변경을 고려해야 할 수도 있다.
- 반대로 조직 구조가 바뀌었을 때 어떻게 되는지도 고려해야 한다. 최악의 경우 서비스 분리를 검토해야할 지도 모른다.

<img width="781" height="503" alt="스크린샷 2025-10-09 오후 9 30 03" src="https://github.com/user-attachments/assets/834b09ae-7a86-4ded-b9a0-925c95a135ef" />

## 7. 혼합 모델과 예외

정보 은닉의 지침을 따르고 결합과 응집력의 상호작용을 이해한다면 어떤 메커니즘을 선택하든 최악의 함정을 피할 수 있다. 하지만 경우에 따라 모델을 혼합해야 할 이유가 나타난다.
