- 시스템을 확장하는 이유
    - 성능 개선: 더 많은 부하 처리, 지연 시간 감소
    - 견고성 개선: 장애에 더 잘 견디도록
- 확장은 단일 해법이 아니라 문제의 성격에 따라 선택
- 마이크로서비스는 다양한 확장 기법을 조합해 사용할 수 있음

## 13.1 확장의 네 가지 축

- 네 가지 확장 유형
    - 수직 확장 (Vertical Scaling): 더 큰 머신 사용
    - 수평 복제 (Horizontal Duplication): 동일한 인스턴스 여러 개
    - 데이터 파티셔닝 (Data Partitioning): 데이터 기준으로 분산
    - 기능 분해 (Functional Decomposition): 기능 단위로 분리
- 하나만 선택할 필요는 없으며 복합적으로 사용 가능

### 13.1.1 수직 확장

**📌 개념**

- 더 빠르고 더 큰 머신(CPU, 메모리, I/O)을 사용
- 주로 성능 개선 목적
- 적용 사례
    - 푸드코: 쓰기 경합 증가 → DB 서버 업그레이드
    - 관계형 DB의 쓰기 성능 개선에 특히 효과적

**📌 구현**

- VM 환경: VM 크기 조정
- 베어메탈: 더 큰 하드웨어 필요
- 공용 클라우드
    - 시간 단위로 대형 인스턴스 사용 가능
    - 메모리, CPU, I/O, GPU 특화 인스턴스 선택 가능

**📌 주요 이점**

- 가장 빠르고 위험이 적은 확장 방식
- 코드 변경 없이 적용 가능한 경우 많음
- 다른 확장 방식의 기반 마련
    - 예: 더 많은 DB를 한 머신에 수용

**📌 제한 사항**

- 멀티코어를 활용하지 못하는 소프트웨어는 효과 미미
- 견고성 향상에는 거의 기여하지 않음
- 머신이 커질수록 비용 대비 효율이 떨어질 수 있음
- 결국 한계에 도달

### 13.1.2 수평 복제

- 동일한 시스템을 여러 개 실행해 부하 분산
- 처리량 증가에 효과적

**📌 구현**

- 로드 밸런서
    
    <img width="694" height="513" alt="Image" src="https://github.com/user-attachments/assets/fb3b9ecc-7595-438e-87bd-826f4cfaf647" />
    
    - 여러 마이크로서비스 인스턴스로 요청 분산
    - 헬스 체크로 장애 노드 제거
- 경쟁 소비자 패턴
    
    <img width="625" height="539" alt="Image" src="https://github.com/user-attachments/assets/a2464097-422d-4a05-ae22-7e2700935d7e" />
    
    - 작업 큐 + 여러 소비자 인스턴스
- DB 읽기 복제본
    
    <img width="568" height="476" alt="Image" src="https://github.com/user-attachments/assets/e6fcf02f-aa6a-46fa-9641-cbd201877891" />
    
    - 읽기 요청 분산
    - 쓰기 자원 확보

**📌 주요 이점**

- 애플리케이션 변경 없이 적용 가능한 경우 많음
- 비교적 단순하고 효과적인 확장 방식
- 수직 확장 이후의 다음 단계로 적합

**📌 제한 사항**

- 인프라 비용 증가
- 부분 문제에도 전체 복제
- 부하 분산 메커니즘에 대한 이해 필요
- 고정 세션(sticky session)은 부작용이 큼

### 13.1.3 데이터 파티셔닝

- 데이터의 특정 속성 기준으로 부하 분산
    - 예: 사용자 ID, 지역, 고객 그룹

**📌 구현 방식**

- 데이터베이스 수준 파티셔닝
    
    <img width="822" height="587" alt="Image" src="https://github.com/user-attachments/assets/d4155cc6-a11a-48fc-bbbf-ec1cacb99210" />
    
    - 동일 스키마, 데이터만 분할
- 마이크로서비스 인스턴스 수준 파티셔닝
    
    <img width="809" height="855" alt="Image" src="https://github.com/user-attachments/assets/13134ba9-0288-4a64-8904-de57ecf0b004" />
    
    - 프록시 또는 라우팅 로직 필요
- 지리적 파티셔닝
    - 국가/지역별 데이터 분리
- 하위 시스템 활용
    - Cassandra, Kafka 등은 기본 지원

**📌 주요 이점**

- 쓰기 병목 해소에 매우 효과적
- 유지보수 영향 범위 축소
- 파티션별 롤아웃 가능
- 수평 복제와 잘 결합됨

**📌 제한 사항**

- 파티션 장애 시 해당 영역은 실패
- 파티션 키 선정이 매우 중요 (잘못 설계 시 부하 불균형)
- 파티셔닝 전략 변경은 매우 고통스러움
- 샤드 간 쿼리 처리 복잡
- 데이터베이스 선택에 큰 영향

### 13.1.4 기능 분해

- 기능을 분리해 독립적으로 확장
- 모놀리스 → 마이크로서비스 전환의 핵심
- 적용 사례
    - 뮤직코프: 주문 기능 분리
    - 푸드코: 배달·메뉴 데이터 분리 → 팀 구조 개선

**📌 주요 이점**

- 워크로드별로 인프라 최적화 가능
- 비용 효율성 증가
- 부분 장애 허용 구조 설계 가능
- 기술 선택의 자유도 증가
- 조직 확장에도 도움

**📌 제한 사항**

- 구현 난이도 높음
- 단기간 효과를 기대하기 어려움
- 시스템 복잡도 증가
- 데이터 계층 변경 부담 큼
- 다른 확장 기법을 먼저 고려하는 것이 일반적

## 13.2 결합 모델

- 확장 축은 서로 결합 가능
- 예시 흐름
    - 기능 분해 → 수평 복제 → 지리적 파티셔닝
- 한 축의 확장은 다른 축을 더 쉽게 만듦
- 목표는 “모든 축 사용”이 아니라 상황에 맞는 선택

## 13.3 작게 시작하라

- 조기 최적화는 해악
- 실제 문제에 의해 확장이 주도돼야 함
- 확장은 복잡성을 증가시킴 → 새로운 취약점
- 반드시 실험 기반 접근
    - 기준선 측정
    - 변경 적용
    - 효과 검증
- 자동화된 부하 테스트가 매우 중요

> **📌  CQRS와 이벤트 소싱**
> 
> - CQRS
>     - 읽기와 쓰기 모델 분리
>     - 독립적 확장 가능
> - 이벤트 소싱
>     - 상태 대신 이벤트 이력 저장
>     - CQRS와 함께 자주 사용
> - 장점
>     - 읽기/쓰기 확장에 유연
>     - 특정 상황에서 강력
> - 단점
>     - 구현 복잡도 매우 높음
> - 권장 사항
>     - 가장 어려운 확장 방식 중 하나
>     - 먼저 수직 확장, 수평 복제, 읽기 복제본 등을 고려
>     - 마이크로서비스 내부 구현 세부 사항으로 숨겨야 함 → 소비자에게 노출되지 않도록 설계

## 13.4 캐싱

- 캐싱: 이전 계산 결과를 저장해 지연 시간·자원 사용 감소
- 마이크로서비스에서는 성능 개선, 확장성 확보, 경우에 따라 견고성 향상 가능
- 핵심 과제
    - 어디에 캐시할 것인가
    - 어떻게 무효화할 것인가
    - 얼마나 오래된 데이터를 허용할 것인가

### 13.4.1 성능을 위해

- 네트워크 호출 제거 → 지연 시간 감소
- 다운스트림 마이크로서비스 부하 감소
- 비용이 큰 연산(조인, 집계 결과 등) 캐싱 효과 큼
- e.g. 장르별 인기 목록, 복잡한 DB 쿼리 결과 캐싱

### 13.4.2 확장성을 위해

- 읽기 트래픽을 캐시로 흡수해 경합 지점 완화
- 대표 사례
    - DB 읽기 복제본
        - 주 노드 부하 감소
        - 복제 메커니즘이 무효화 자동 처리
- 원본이 병목인 모든 지점에 캐싱은 확장성에 유효

### 13.4.3 견고성을 위해

- 원본이 불가용해도 캐시로 서비스 지속 가능
- 주의점
    - 원본 장애 시 캐시 자동 무효화 금지
    - 오래된 데이터라도 제공할 수 있어야 함
- 일관성보다 가용성 우선인 상황에서 적용 가능

### 13.4.4 캐싱 위치

**📌 클라이언트 측 캐싱**

<img width="748" height="463" alt="Image" src="https://github.com/user-attachments/assets/b924321e-8461-4dc6-9530-d0df663043c7" />

- 마이크로서비스 내부(인메모리 등)에 캐시
- 장점
    - 네트워크 호출 제거 → 성능·견고성에 매우 효과적
    - 필요한 데이터만 선택적으로 캐싱 가능
- 단점
    - 무효화 선택지 제한
    - 여러 클라이언트 간 캐시 불일치 발생
- 완화 방안
    - 공유 캐시 (Redis, Memcached 등)
    - 복사본 수 감소, 리소스 효율 증가
    - 단, 공유 캐시 왕복 비용 발생

**📌 서버 측 캐싱**

<img width="763" height="529" alt="Image" src="https://github.com/user-attachments/assets/b6861734-c101-47f8-8c13-6ee51df5b090" />

- 마이크로서비스가 자체적으로 캐시 관리
- 장점
    - 정교한 무효화 구현 용이
    - 소비자 간 캐시 불일치 문제 감소
    - 모든 소비자의 성능을 일괄 개선
- 단점
    - 서비스 경계까지는 왕복 필요
    - 지연 시간 최적화, 견고성 효과는 제한적
- 적합한 경우
    - 조직 전반에서 널리 사용되는 핵심 서비스

**📌 요청 캐시**

- 특정 요청의 최종 결과 자체를 캐싱
- 장점
    - 가장 빠른 응답
    - 다운스트림 호출 완전 제거
- 단점
    - 매우 제한적
    - 다른 요청에는 재사용 불가

### 13.4.5 무효화

> “컴퓨터 과학에서 어려운 것은 캐시 무효화와 작명뿐이다.”
> 

**📌 TTL**

- 일정 시간 후 자동 무효화
- 구현 단순
- 단점
    - TTL 동안 오래된 데이터 제공 가능
- HTTP 지원
    - Cache-Control
    - Expires
- TTL은 처음엔 리소스 유형별 동일 값으로 시작 권장

**📌 조건부 GET**

- ETag 기반 변경 여부 확인
- 변경 없으면 `304 Not Modified`
- 장점
    - 불필요한 자원 재생성 방지
- 한계
    - 네트워크 왕복은 여전히 발생
- 적합한 경우
    - 응답 생성 비용이 매우 비싼 경우

**📌 알림 기반 무효화**

- 이벤트로 캐시 무효화 트리거
- 장점
    - 오래된 데이터 제공 기간 최소화
- 단점
    - 구현 복잡
    - 메시징 인프라 필요
- 실무 고려사항
    - 심박(heartbeat) 이벤트로 메커니즘 정상 여부 확인
    - 이벤트에 포함할 데이터 범위 신중히 결정

**📌 연속 쓰기 (Write-through)**

- 원본 업데이트 시 캐시도 함께 업데이트
- 서버 측 캐싱에서 구현 용이
- 장점
    - 오래된 데이터 제공 거의 제거
- 한계
    - 사용 가능한 상황이 제한적

**📌 나중 쓰기 (Write-behind)**

- 캐시 먼저 업데이트, 원본은 나중에 반영
- 장점
    - 쓰기 성능 우수
- 단점
    - 데이터 손실 위험
    - 진실의 출처(Source of Truth) 불명확
- 마이크로서비스에서는 거의 사용되지 않음

### 13.4.6 캐싱의 황금 법칙

- 캐시는 가능한 한 적게
- 캐시가 많을수록
    - 데이터 신선도 추론 어려움
    - 무효화 복잡도 증가
- 중첩 캐시 위험
    - 각 캐시의 TTL이 누적돼 데이터가 더 오래됨
- 권장
    - 캐싱은 성능 최적화 목적
    - 신선도를 쉽게 추론할 수 있도록 단순하게 유지

### 13.4.7 신선도 대 최적화

- TTL 감소
    - 신선도 ↑
    - 원본 부하·지연 ↑
- 사용자 기대와 시스템 안정성 사이에서 균형 필요
- 캐시 장애 시, 원본 과부하 방지를 위해 기능 차단이 더 안전할 수 있음
- 캐시가 적을수록 시스템 이해와 운영이 쉬움

### 13.4.8 캐시 중독: 주의 사례

- 잘못된 캐시 헤더 → 영구적으로 오래된 데이터 제공
- 문제 원인
    - Expires: Never
    - CDN, ISP, 브라우저 캐시까지 중첩
- 결과: URL 변경 외에는 무효화 불가
- 교훈
    - 캐싱 경로 전체(CDN~브라우저) 이해 필수
    - 캐시는 강력하지만 통제하기 어렵다

## 13.5 자동 확장

- 전제: 인프라 프로비저닝·배포 자동화
- 방식
    - 예측적 확장
        - 시간·계절 패턴 기반
    - 반응형 확장
        - 부하 증가, 인스턴스 장애 대응
- 실무 포인트
    - 확장 속도 vs 부하 증가 속도 파악
    - 부하 테스트로 확장 규칙 검증 필수
- 실제 활용: 장애 대응 목적이 더 흔함
- 주의
    - 너무 빠른 축소는 위험
    - 여유 용량 > 부족한 용량

## 13.6 다시 시작하기

- 초기 아키텍처는 성장 한계에 도달할 수 있음
- 초반에는 수직 확장, 수평 복제 로 충분
- 이후에는
    - 모놀리스 분해
    - 데이터 저장소 교체
    - 이벤트 기반 전환
    - 플랫폼/스택 변경
        
        등 근본적 재설계 필요
        
- 오해 경계
    - “처음부터 크게 만들어야 한다” → 위험
- 메시지
    - 재설계는 실패가 아니라 성공의 증거
    - 빠른 실험과 학습이 우선