## 1. 확장의 네 가지 축

- 수직 확장: 더 큰 머신을 사용하는 것.
- 수평 복제: 동일한 작업을 수행할 수 있는 여러 기기를 두는 것.
- 데이터 파티셔닝: 데이터의 일부 속성에 따라 작업을 나누는 것.
- 기능 분해: 유형에 따라 업무를 분리하는 것.

### 1.1 수직 확장

- 더 빠른 cpu, 더 높은 i/o는 지연 시간과 처리량의 향상으로 이어지는 경우가 많음.

#### 구현

- 실행 중인 인프라에 따라 구현 방법은 달라짐.
- 자체 가상화 인프라에서 실행하는 경우 하드웨어의 구입이 필요할 수 있음.
- 클라우드의 등장으로 완전 관리형 머신을 쉽게 임대할 수 있게 되었음.

#### 주요 이점

- db 인프라를 더 큰 머신으로 옮기면 논리적 db를 더 많이 호스팅할 수 있음.
- 운영체제와 칩셋이 동일하다면 코드나 db를 변경할 필요가 없음.

#### 제한 사항

- 실행 중인 머신을 확장하면 cpu가 빨라지는게 아니라 코어만 많아지는 경우가 많음.
- sw 가 멀티코어 하드웨어를 활용하지 않는 경우 개선 효과가 없을 수 있음.
- 크고 새로운 서버가 안정성을 개선할 수 있지만, 해당 머신이 다운되면 모든 것이 다운됨.
- 더 맣은 비용이 들지만 성능이 비례해서 향상되지는 않음.

### 1.2 수평 복제

- 시스템 일부를 복제해 더 많은 워크로드를 처리할 수 있음.
- 복제본들에게 작업을 분산하는 방법이 필요.
- 단순하며 초기에 시도하기 쉬움.

#### 구현

- 로드 밸런서를 사용해 복제본으로 요청을 분산.
<img width="675" height="442" alt="image" src="https://github.com/user-attachments/assets/878df708-1422-4964-98bd-8cfad5a91dcb" />

- 경쟁 소비자 패턴은 인스턴스들끼리 작업을 두고 경장하면서 시스템 처리량을 증가시킴.
<img width="586" height="504" alt="image" src="https://github.com/user-attachments/assets/721e3919-6520-44c4-8edb-ad2fb7e23123" />

- 데이터베이스 복제는 주 노드에 대한 읽기 부하가 줄어들어 쓰기 처리를 위한 자원을 확보할 수 있음.
<img width="509" height="434" alt="image" src="https://github.com/user-attachments/assets/98710be9-f4ac-4f4b-a49a-71c9b1545cb3" />

#### 주요 이점

- 부하를 분산하는 작업은 큐나 로드 밸런서를 통해 수행될 수 있으므로 애플리케이션을 업데이트해야 하는 경우는 거의 없음.
- 복제본을 분산할 수 있다면 부하를 분산하고 원시 컴퓨팅 자원에 대한 경합을 줄이는 세련된 방법.

#### 제한 사항

- 전체 애플리케이션 중 일부에서 부하가 발생해도 전체 애플리케이션을 복제해야 함.
- 대부분의 작업은 부하 분산 메커니즘 구현. http 부하 분산, 메세지 브로커, db 읽기 복제본 등 다양함.
- 사용자 세션과 연관된 요청이 동일한 복제본으로 향하는 것이 요구될 수 있음. 이러한 경우 부하 분산 메커니즘이 제한됨.

### 1.3 데이터 파티셔닝

- 데이터의 일부 측면을 기반으로 부하를 분산시키는 것

#### 구현

- 워크로드에 관련된 키를 함수에 적용하여 결과로 얻은 파티션(샤드)에 부하를 분산.

<img width="573" height="365" alt="image" src="https://github.com/user-attachments/assets/f4c84628-2346-4f5d-ab6e-69c317925d05" />

- 데이터베이스 스키마는 동일하지만, 각 노드의 콘텐츠는 고객의 부분 집합만 포함.
- 마이크로서비스 수준의 파티셔닝도 가능. 이 경우 인바운드 요청이 어떤 파티션에 매핑되어야 하는지 파악해야 함.

<img width="534" height="577" alt="image" src="https://github.com/user-attachments/assets/f04bc4a6-bc14-4a34-bdbf-95d7b06ae79d" />

- 데이터 파티셔닝의 다른 예는 지리적 기준으로 구분하는 것.
- 대부분의 경우 파티셔닝은 카프카와 같이 의존하는 하위 시스템에서 수행됨.

#### 주요 이점

- 트랜잭션 워크로드에 유용하게 확장 가능. 쓰기 제약이 있는 시스템의 경우 데이터 파티셔닝을 통해 개선 효과를 얻을 수 있음.
- 유지 보수의 영향도와 범위를 쉽게 줄일 수 있음. 파티션별 업데이트, 다운타임이 필요한 작업도 단일 파티션에만 영향을 미침.

#### 제한 사항

- 파티션에 장애가 발생하면 해당 부분의 요청이 실패함. 수평 복제 같은 기술을 결합해 특정 파티션의 견고성을 향상시킬 수 있음.
- 파티션 키의 올바른 분할은 어려움. 합리적인 것은 비즈니스 키 대신 인조키를 기반으로 파티션을 분할하는 것. 비즈니스 키가 변경되는 상황에 대처 가능하고 부하 분산이 균등할 가능성이 높음.
- 여러 노드에 걸친 쿼리가 어려움. 개별 샤드를 쿼리하고 메모리 조인하거나, 모든 데이터 지합을 사용 가능한 읽기 저장소가 있어야 함.

### 1.4 기능 분해

- 기능을 추출해 독립적으로 확장 가능.

<img width="696" height="362" alt="image" src="https://github.com/user-attachments/assets/dae279b7-362a-40c1-a251-85138fa040aa" />

#### 구현

- msa.

#### 주요 이점

- 기능별로 분해했으므로 이제 기본 인프라의 크기를 조절 가능.
- 사용하지 않는 것은 꺼둘 수 있고, 부하고 높은 것은 더 많은 하드웨어를 투입할 수 있음.
- 기능 분해 자체는 시스템을 견고하게 만들지 못하지만, 부분적인 장애를 견딜 수 있는 시스템 구축 기회를 열어줌.

#### 제한 사항

- 복잡한 작업이며 단기간에 이점을 제공하기는 어려움.
- 전반적인 시스템 복잡성이 증가.
- 기능 분해 전에 다른 모든 가능성을 고려해야 함.

## 2. 결합 모델

- 한 가지 유형의 확장으로 좁게 생각하는 것을 지양해야 함. 필요에 따라 여러 축으로 확장하는 것이 합리적.

<img width="694" height="276" alt="image" src="https://github.com/user-attachments/assets/83011736-1227-49bd-ab58-0715af1756d3" />

<img width="682" height="367" alt="image" src="https://github.com/user-attachments/assets/7cc1713e-57a7-4631-88cd-d37d04c18e62" />

- 한 축을 따라 확장하면 다른 축을 더 쉽게 활용할 수 있음.
- 모든 축을 따라 확장하는 것이 목표는 아니지만, 다양한 메커니즘이 있다는 사실을 고려할 것.

## 3. 작게 시작하라

- 모든 형태의 최적화는 실제 필요에 의해 주도되어야 함.
- 시스템에 새로운 복잡성을 추가하면 새로운 취약성의 원인이 될 수 있음.
- 문제를 인식했다면 솔루션이 효과가 있는지 확인하기 위해 수행 가능한 작은 작업을 찾아보라.

## 4. 캐싱

- 이전 결과를 저장해 후속 요청에서 시간과 자원을 소비하지 않고 저장된 값을 사용하게 해줌.
- 원본 데이터는 변경될 수 있으므로 서비스 캐시를 무효화할 수 있는 방법도 필요.
- 지연 시간을 줄일 수 있으며 경우에 따라 시스템 견고성을 개선할 수 있음.

### 4.1 성능을 위해

- msa 환경에서 다른 ms 와 상호작용하는 비용이 우려될 수 있음.
- 캐시에서 데이터를 가져오면 네트워크 호출을 제거하여 다운스트림 ms의 부하를 줄이는데 도움이 됨.

### 4.2 확장성을 위해

- 읽기를 캐시로 전환할 수 있으면 시스템 일부분에서 발생하는 경합을 피해 더 나은 확장성을 확보할 수 있음.
- 데이터베이스 읽기 복제본을 사용하면 주 db에 대한 부하가 줄어듬. 복제본의 캐시 무효화는 db 기줄에 의해 자동으로 처리됨.

### 4.3 견고성을 위해

- 로컬 캐시에 전체 데이터 집합이 들어있으면 원본이 가용하지 않을 경우에도 작동할 수 있음.
- 이 경우 오래된 데이터를 제거하지 않고 업데이트 가능한 시점까지 데이터를 캐시에 보관할 수 있어야 함.
- 일관성보다는 가용성을 우선시하는 방법.

### 4.4 캐싱 위치

- 캐싱 위치는 다양함.

<img width="704" height="592" alt="image" src="https://github.com/user-attachments/assets/f87cba3f-f05e-481e-b5ee-8af444d8455e" />

#### 클라이언트 측 캐싱

- 데이터는 원본의 범위를 벗어난 곳에 캐싱됨.
- 필요한 모든 조회에 대해 캐시 히트가 발생했다면 다운스트림 ms에 대한 호출은 필요 없음.
- 다운스트림 ms로부터 얻은 정보 중 일부만 캐싱하기로 결정할 수 있음.

<img width="636" height="373" alt="image" src="https://github.com/user-attachments/assets/e31c3a93-f44e-4144-8b17-4f1b59693bec" />

- 네트워크 호출을 피할 수 있어 지연 시간을 줄이고, 견고성을 높일 수 있음.
- 단점
  - 무효화 메커니즘과 관련된 선택 범위가 제한되기 쉬움.
  - 클라이언트 사이에 불일치가 발생할 수 있음.
 
- 클라이언트 측 캐시를 레디스와 같은 도구를 사용해 공유한다면 클라이언트 간 불일치를 해소할 수 있음.
- 관리해야 하는 복사본도 줄어들어 리소스 측면에서 효율적. 캐시까지 왕복하는 비용이 추가됨.
- 고려해야할 점은 공유 캐시에 대한 소유권.

#### 서버 측 캐싱

- 클라이언트는 캐시를 통해 제공하는지 실제 db 조회가 이루어지는지 알 필요 없음.

<img width="677" height="450" alt="image" src="https://github.com/user-attachments/assets/be521947-c107-4b2e-8a99-6e7bd17cbad3" />

- 서버가 캐시 관리에 대한 모든 책임을 짐.
- 정교한 캐시 무효화 메커니즘을 구현하기 용이함.
- 클라이언트 사이의 캐시 불일치 문제도 해결 가능.
- 단점은 서비스간 통신이 필요하기 때문에 지연 시가 최적화는 어려움. 견고성 향상도 기대할 수 없음.
- 그러나 분명히 모든 클라이언트의 성능을 개선할 수 있음.
- 우려하는 점이 무엇인지에 따라 어디서 캐싱을 할지 결정할 수 있음.

#### 요청 캐시

- 원본 요청에 대한 응답을 캐싱하는 것.

<img width="617" height="508" alt="image" src="https://github.com/user-attachments/assets/3b4ec97e-f90f-429c-89e3-2b0bc630f601" />

- 매우 효율적이지만 특정 요청의 결과만 캐싱할 수 있음.

### 4.5 무효화

- 개념은 간단하지만 실행은 복잡한 일.

#### TTL

- 캐시의 각 항목은 특정 기간동안만 유효함. 기간이 만료되면 새로운 사본을 가져옴.
- http는 Cache-Control 헤더로 ttl과 응답의 Expires 헤더를 통해 만료 타임스탬프를 설정할 수 있음. 즉, 원본에서 데이터를 얼마나 오랫동안 최신으로 간주해야 하는지 알려줄 수 있음.
- ttl 기반 무효화는 간단하지만 정교하지는 못함.

#### 조건부 GET

- ETag는 리소스 값이 변경됐는지 여부를 확인하는 데 사용.
- get 요청 시에 추가 헤더를 지정해 특정 기준을 만족하는 경우에만 클라이언트에게 자원을 내려보내도록 지시할 수 있음.
- 고객 레코드의 `ETag: key`일때, `If-None-Match: key`와 같은 헤더의 응답이 304 Not Modified 이면 클라이언트가 최신 버전을 가지고 있다는 것.
- 여전히 네트워크 통신이 필요하지만 불필요한 자원 재새성을 피할 수 있음.

#### 알림 기반

- 이벤트를 사용해 구독자가 로컬 캐시를 무효화하는 것.
- ttl 과 비교했을 때 복잡함.

<img width="755" height="360" alt="image" src="https://github.com/user-attachments/assets/bbeafbee-6feb-41c6-b2c1-be9126b4af2f" />

- 캐시가 오래된 데이터를 제공할 가능성을 줄일 수 있음.
- 단점은 구현이 복잡함. 메세지 브로커와 같은 미들웨어를 관리하는 추가 비용이 들어감. 이미 사용중인게 있다면 그것을 활용하는 것이 합리적.
- 주의할 점은 클라이언트가 알림 메커니즘이 작동중이라는 사실을 인지할 수 있어야 함. 하트비트 이벤트 수신이 없으면 사용자에게 오래된 데이터라는 것을 알리거나 기능을 중단하는 등의 조치를 취할 수 있어야 함.
- 알림에 포함된 내용에 따라 다시 조회할지, 알림 내용에 기반하여 데이터를 업데이트할지 결정할 수 있음.

#### 연속 쓰기(write-through)

- 캐시와 원본의 상태가 동시에 업데이트 됨.
- 서버 측 캐싱에서 트랜잭션 내에서 db와 인메모리 캐시는 큰 어려움 없이 업데이트할 수 있음.
- 캐시가 다른 곳에 있는 경우 동시에 업데이트하는 것은 어려울 수 있음.

#### 나중 쓰기(write-behind)

- 캐시를 먼저 업데이트하고 원본을 업데이트하는 것. 일종의 버퍼.
- 데이터 손실 가능성이 있음.
- 데이터 원본이 무엇인지 구분하기 어려워짐.
- 복잡성이 높고 더 간단한 형태의 캐싱으로도 충분하기 때문에 잘 쓰이지 않음.

### 4.6 캐싱의 황금 법칙

- 너무 많은 곳에 캐시를 만들지 마라.
- 오래된 데이터, 데이터를 무효화해야 할 위치, 지연 시간 최적화와 같은 추론과 판단이 어려워짐.
- 서버도 1분 ttl, 클라이너트도 1분 ttl 캐시가 존재하면 실제로는 최대 2분 전의 데이터를 사용할 가능성이 있음.
- 타임스탬프 기반으로 만료한다면 그나마 나을 수 있음.
- 캐싱은 복잡성을 높인다는 사실을 명심할 것. 캐싱 장소의 이상적인 수는 0.

### 4.7 신선도 대 최적화

- 데이터 신선도를 고려하면 ttl 을 5분에서 1분으로 줄일 수 있지만 지연 시간과 부하는 5배로 늘어남.
- 이러한 균형은 요구 사항에 따라 달라짐.

### 4.8 캐시 중독: 주의해야 할 이야기

- 버그로 인해 오래된 데이터를 영원히 제공하게 될 수 있음.
- 캐시가 많아지면 복잡성이 증가함. 특히 사용자 브라우저 캐시는 제어할 수 없음.
- 소스에서 목적지까지 캐싱되는 데이터의 전체 경로를 이해해야 캐싱의 복잡성과 발생하게 될 문제를 제대로 인식할 수 있음.

## 5. 자동 확장

- 가상 호스트 프로비저닝, ms 인스턴스 배포를 자동화할 수 있으면 자동으로 확장할 수 있는 구성 요소를 갖추고 있는 것.
- 시스템의 부하 추이에 따라 자동으로 확장하거나, 부하 증가나 인스턴스 장애를 감지하여 반응형으로 확장할 수도 있음.
- 보통 자동 확장은 부하보다는 인스턴스 장애를 처리하기 위해 더 많이 사용됨.
- 부하에 따라 자동 확장하는 경우 너무 빨리 축소하지 않도록 유의할 것. 대부분의 상황에서 더 많은 컴퓨팅 성능을 보유하는 것이 부족한 것보다 좋음.

## 6. 다시 시작하기

- 수직 확장 수평 확장은 시스템 아키텍처에 대한 영향이 적음.
- 특정 시점에서 다음 단계로의 성장을 위해 아키텍처를 변경하려면 급진적인 조치가 필요. 기능 분해, 이벤트 기반 시스템, 기술 스택 변경 등.
- 그러나 처음부터 대규모로 구축할 필요는 없음. 신속하게 실험하고 어떤 기능을 구축해야할지 파악해야 함.
