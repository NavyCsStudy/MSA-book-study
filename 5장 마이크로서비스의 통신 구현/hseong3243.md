## 1. 이상적인 기술을 찾아서

### 1.1 하위 호환성을 쉽게 하라

- 새 필드를 추가하는 간단한 작업으로 클라이언트가 중단되면 안 된다.
- 변경 사항이 이전 버전과 호환되는지 검증할 수 있는 기능을 마련하라.
- 배포 전에 변경 사항의 피드백 방법을 마련하라.

### 1.2 인터페이스를 명시적으로 만들라.

- 명시적 스키마는 서비스의 인터페이스가 명시적이라는 것을 보장하는 데 도움이 된다.
- 소비자가 기대하는 기능을 설명하는 문서와 함께 스키마를 사용해보라.

### 1.3 API를 기술 중립적으로 유지하라

- 우리 분야의 기술은 급변한다.
- 따라서 서비스 간 통신에 사용된 api를 최대한 기술 중립적으로 유지하라.

### 1.4 소비자를 위해 서비스를 단순하게 만들라

- 소비자가 ms를 사용하는 데 필요한 비용과 아름다운 msa 사이에서 고민하라

### 1.5 내부 구현 세부 사항을 숨겨라

- 소비자가 우리 내부 구현에 종속되면 결합이 증가한다.
- 우리 서비스가 변경되면 소비자에게도 변경을 요구한다. 이는 기술 부채의 증가로 이어진다.
- 따라서 상세 정보를 노출하도록 강요하는 기술은 피하라.

## 2 기술 선택

#### 원격 프로시저 호출(rpc)
- 원격 프로세스에서 로컬 메서드를 호출할 수 있는 프레임워크

#### REST
- 동사(get, post)를 활용해 액세스 가능한 리소스(고객)를 노출하는 아키텍처

#### 그래프QL
- 소비자가 여러 서비스에서 정보를 가져올 수 있는 사용자 지정 쿼리를 정의
- 필요한 결과만 반환하기 위해 필터링할 수 있다.

#### 메세지 브로커
- 큐나 토픽을 통해 비동기 통신을 허용하는 미들웨어

### 2.1 원격 프로시저 호출

- rpc는 로컬 호출을 통해 원격 서비스를 실행하는 기술
- rpc 기술을 사용하는 것은 직렬화 프로토콜에 투자한다는 의미이다. rpc 프레임워크는 데이터의 직렬화/역직렬화되는 방법을 정의한다.
- 클라이언트 측 코드를 쉽게 생성할 수 있다.

#### 단점
- 기술 결합이 발생한다.
  - 일부 rpc 메커니즘은 클라이언트와 서버의 사용 기술을 제한하고 특정 플랫폼에 묶여 있다.
  - 이러한 제약이 없는 rpc 구현체도 많다.
 
- 로컬 호출은 원격 호출과 같지 않다.
  - rpc의 핵심 개념은 원격 호출의 복잡성을 숨기는 것이다.
  - 그러나 네트워크 전송 시간, 페이로드 마샬링/역마샬링에는 상당한 비용이 들어간다.
  - 높은 추상화로 인해 자신도 모르는 사이 원격 호출을 할 수 도 있다.
  - 그리고 네트워크는 신뢰할 수 없다. 전송 속도, 패킷 변조 등 악의적인 가능성이 존재한다.
 
- 깨지기 쉽다.
  - 일부 구현체는 취성(brittleness, 깨지기 쉬운 성질)을 유발할 수 있다.
  - 메서드의 파라미터가 변경되거나, 객체의 필드가 변경되면 클라이언트도 함께 변경해야 한다.
  - 확장만 가능한 객체가 생기며 불필요한 필드가 노출된다.
 
#### 적용 대상

- 네트워크를 완전히 숨기는 수준의 추상화를 하지 말라.
- 클라이언트 업그레이드 없이 인터페이스를 개선할 수 있는지 확인하라.

### 2.2 REST

- 웹에서 영감을 받은 아키텍처 형식
- 리소스
  - Customer처럼 서비스 자체가 알고 있는 것
  - 리소스가 외부에 표시되는 방식과 내부에 저장되는 방식은 완전히 별개
  - 서버는 요청에 따라 Customer에 대한 다양한 표현을 생성
 
#### REST와 HTTP

- http method는 리소스와 함께 작동하는 방법에 대해 상세한 명세를 정의
- 도구와 기술을 지원하는 대규모 생태계도 제공
- rpc를 구현하는 데도 사용 가능하다. http를 사용한다고 rest를 한다고 말할 수는 없다.

#### 애플리케이션 상태 엔진으로서의 하이퍼미디어(HATEOAS)

- 클라이언트-서버 결합을 피하고자 rest에 도입된 원칙

#### 문제점

- 최적화된 바이너리 프로토콜에 비해 성능이 떨어진다.
- 다른 네트워킹 프로토콜에 비해 비효율적인 tcp를 사용한다.
  - http/3의 quic 프로토콜은 tcp와 동일한 종류의 기능을 제공하면서, 지연 시간 개선을 이루어냈다.

- hateoas는 추가적인 성능 문제가 발생할 수 있다.
  - 클라이언트는 엔드포인트를 찾기 위해 여러 컨트롤을 탐색하며 복잡한 프로토콜이 발생할 수 있다.

#### 적용 대상

- ms 간의 동기식 요청 및 응답 기반 통신에 매우 효과적
- 친숙한 인터페이스 방식이며 다양한 기술 간의 상호 운용성을 보장
- 비동기적으로 상호작용하도록 구성할 수 있지만, 다른 대안에 비하면 미흡

### 2.3 그래프QL

- 클라이언트가 동일 정보를 검색하기 위해 여러 번 요청할 필요 없는 쿼리를 정의할 수 있다.
- 검색하는 데이터와 호출 수를 줄일 수 있다.

#### 문제점

- 클라이언트 장치는 동적으로 변경되는 쿼리를 실행할 수 있다. 이는 고비용 sql을 실행하는 것과 동일한 문제를 일으킨다.
  - 그래프QL은 쿼리 플래너와 같은 도구가 없다.
 
- 캐싱도 복잡하다.
  - 일반적인 요청은 http api를 사용하고, 구체적인 요청을 그래프ql을 사용해볼 수 있다.
 
- 이론적으로 쓰기를 사용할 수 있지만 읽기만큼 적합하지 않다.
- 데이터베이스 래퍼로 오해할 수 있다. 데이터 베이스와의 결합되지 않도록 해야 한다.

#### 적용 대상

- 모바일 네트워크의 특성 면에서 제약이 있는 모바일 장치에 적합
- 호출 집계 및 필터링 메커니즘. msa 맥락에서 여러 하위 ms에 대한 호출을 집계하는 데 사용

### 2.4 메세지 브로커

- 프로세스 사이에 위치해 프로세스 간 통신을 관리하는 미들웨어
- 메세지는 메세지 브로커가 보내는 것을 정의하는 일반적 개념
  - 메세지에는 요청, 응답 또는 이벤트가 포함
  - ms와 직접 통신하지 않고 메세지 전송 방법에 대한 정보와 메세지를 메세지 브로커에 전달
 
#### 토픽과 큐

- 큐는 point to point이다.
  - 발신자는 큐에 메세지를 넣고, 소비자는 해당 큐에서 읽는다.
  - 소비자는 하나 이상의 ms로 표현되며 소비자 그룹으로 모델링된다.
  - 큐는 부하 분산 메커니즘으로 작동하며 소비자 그룹의 한 구성원이 해당 메세지를 받는다.
  - 큐를 통해 메세지가 전송될때는 대상에 대한 정보가 있다.
  - 일반적으로 요청 및 응답 통신에 적합하다.
<img width="735" height="385" alt="image" src="https://github.com/user-attachments/assets/ee6b7629-d9df-4755-a562-d7bafb0699a1" />
 
- 토픽
  - 여러 소비자가 토픽을 구독한다.
  - 구독한 소비자는 해당 메세지의 복사본을 받는다.
  - 토픽은 여러 소비자 그룹을 가질 수 있다.
  - 이벤트의 복사본은 별도의 소비자 그룹에 존재하는 하나 이상의 서비스가 수신한다.
  - 토픽을 통해 메세지가 전송될때는 대상에 대한 정보가 발신자에게 숨겨지므로 누가 메세지를 받을지 모른다.
  - 이벤트 기반 통신에 적합하다.
 <img width="733" height="498" alt="image" src="https://github.com/user-attachments/assets/9d1a2c02-a529-41ab-a86a-93455dd6829b" />

#### 전달 보장

- 브로커는 메세지를 전달할 수 있을 때가지 보관하므로 대상이 가용하지 않더라도 문제가 되지 않는다.
- 동기식 호출에서는 메세지가 대상에 도달하지 않았을 때 처리 방식을 고민해야 한다. 재시도하나, 아니면 포기하나.
- 전달 보장을 위해 브로커는 지속적인 방법으로 메세지를 유지해야 한다.
  - 클러스터 기반 시스템으로 실행돼 하나의 머신이 고장나도 메세지가 손실되지 않도록 해야 한다.
  - 올바르게 설정되어 있지 않다면 전달 보장에 대한 약속을 지킬 수 없다.
- 모든 브로커는 전달 보장을 지키기 위해 필요한 운영 방식에 제한을 가진다.

#### 신뢰

- 브로커를 얼마나 신뢰할지도 고려해야 한다.

#### 다른 특성

- 일부 브로커는 쓰기 트랜잭션을 제공한다.
- 정확히 한 번은 논란이 있는 기능이다.
  - 더 나은 방법은 멱등적인 처리이다.
  - 예를 들어 각 메세지는 id를 포함하고 이미 처리된 id인 경우 메세지를 무시하는 방법이 있다.

#### 선택

- 다양한 메세지 브로커가 존재한다.

#### 카프카

- 대규모 처리를 위해 설계되었다.
- 여러 소비자와 생산자를 허용하기 위해 만들어졌다.
- 메세지의 저장 기간을 설정할 수 있다.
- 스트림 처리를 기본으로 제공한다.

## 3. 직렬화 포맷

### 3.1 텍스트 포맷

- 클라이언트가 자원을 사용하는 방법이 유연해진다.
- json은 브라우저에 최적화되었고 간결하며, 단순하다.
- xml은 페이로드의 특정 부분만 추출하려는 경우 많은 도구를 지원한다.

### 3.2 바이너리 포맷

- 페이로드의 크기나 읽기 및 쓰기 효율성을 걱정하는 사람들이 많이 찾는다.
- 다양한 포맷이 존재하지만 성능 비교를 위해서는 벤치마크보다는 직접 해보는 것이 좋다.
- 대부분의 시스템은 데이터를 덜 보내거나 호출 제거하여 기대하는 개선을 수행할 수 있다.
- 극도로 낮은 지연 시간이 필요한 순간이 왔을 때 바이너리 포맷을 고려할 수 있다.

## 4. 스키마

- 엔드포인트가 노출하고 수용하는 것을 정의하기 위해 스키마를 사용해야 하는가?
- 명시적인 스키마가 좋은 문서를 대체할 수는 없지만 필요한 문서의 양을 줄일 수는 있다.
- 엔트포인트의 우발적 고장을 탐지하는 데도 도움이 된다.

### 4.1 구조적 계약 위반 대 의미적 계약 위반

- 구조적 위반
  - 더 이상 호환되지 않는 방식으로의 엔드포인트 구조가 변경되는 상황
  - 필드나 메서드가 제거되거나 새롭게 추가되는 것
  - 메서드의 파라미터 개수가 변경되는 것은 탐지하기 쉽다.
 
- 의미적 계약 위반
  - ms의 그조는 동일하게 유지
  - 소비자의 기대와 다른 방식으로 행동 양식이 변경되는 상황
  - 동작이 변경되는 것은 조금 더 탐지하기 어려울 것이다.
 
### 4.2 스키마를 사용해야 할까?

- 각 버전의 스키마를 비교하면 구조적 위반을 포착할 수 있다.
- 의미적 위반을 포착하려면 테스트를 사용해야 한다.
- 스키마를 사용하지 않기로 한다면 구조적 파손의 책임은 테스트에 있다.
- 스키마가 존재한다고 명시적인 것은 아니다. 어떤 데이터가 포함되고, 어떻게 구성되는지 가정하는 것은 묵시적이다.
- 스키마는 클라이언트-서버 간 구조 계약의 일부를 명시적으로 표현하는 데 큰 도움을 준다.
- 물론 클라이언트-서버 모두 하나의 팀이 소유한다면 스키마가 없는 것이 편할 수 있다.

## 5 마이크로서비스 간의 변경 처리

- 버전 관리를 어떻게 해야 하는가?
