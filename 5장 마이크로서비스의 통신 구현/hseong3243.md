## 1. 이상적인 기술을 찾아서

### 1.1 하위 호환성을 쉽게 하라

- 새 필드를 추가하는 간단한 작업으로 클라이언트가 중단되면 안 된다.
- 변경 사항이 이전 버전과 호환되는지 검증할 수 있는 기능을 마련하라.
- 배포 전에 변경 사항의 피드백 방법을 마련하라.

### 1.2 인터페이스를 명시적으로 만들라.

- 명시적 스키마는 서비스의 인터페이스가 명시적이라는 것을 보장하는 데 도움이 된다.
- 소비자가 기대하는 기능을 설명하는 문서와 함께 스키마를 사용해보라.

### 1.3 API를 기술 중립적으로 유지하라

- 우리 분야의 기술은 급변한다.
- 따라서 서비스 간 통신에 사용된 api를 최대한 기술 중립적으로 유지하라.

### 1.4 소비자를 위해 서비스를 단순하게 만들라

- 소비자가 ms를 사용하는 데 필요한 비용과 아름다운 msa 사이에서 고민하라

### 1.5 내부 구현 세부 사항을 숨겨라

- 소비자가 우리 내부 구현에 종속되면 결합이 증가한다.
- 우리 서비스가 변경되면 소비자에게도 변경을 요구한다. 이는 기술 부채의 증가로 이어진다.
- 따라서 상세 정보를 노출하도록 강요하는 기술은 피하라.

## 2 기술 선택

#### 원격 프로시저 호출(rpc)
- 원격 프로세스에서 로컬 메서드를 호출할 수 있는 프레임워크

#### REST
- 동사(get, post)를 활용해 액세스 가능한 리소스(고객)를 노출하는 아키텍처

#### 그래프QL
- 소비자가 여러 서비스에서 정보를 가져올 수 있는 사용자 지정 쿼리를 정의
- 필요한 결과만 반환하기 위해 필터링할 수 있다.

#### 메세지 브로커
- 큐나 토픽을 통해 비동기 통신을 허용하는 미들웨어

### 2.1 원격 프로시저 호출

- rpc는 로컬 호출을 통해 원격 서비스를 실행하는 기술
- rpc 기술을 사용하는 것은 직렬화 프로토콜에 투자한다는 의미이다. rpc 프레임워크는 데이터의 직렬화/역직렬화되는 방법을 정의한다.
- 클라이언트 측 코드를 쉽게 생성할 수 있다.

#### 단점
- 기술 결합이 발생한다.
  - 일부 rpc 메커니즘은 클라이언트와 서버의 사용 기술을 제한하고 특정 플랫폼에 묶여 있다.
  - 이러한 제약이 없는 rpc 구현체도 많다.
 
- 로컬 호출은 원격 호출과 같지 않다.
  - rpc의 핵심 개념은 원격 호출의 복잡성을 숨기는 것이다.
  - 그러나 네트워크 전송 시간, 페이로드 마샬링/역마샬링에는 상당한 비용이 들어간다.
  - 높은 추상화로 인해 자신도 모르는 사이 원격 호출을 할 수 도 있다.
  - 그리고 네트워크는 신뢰할 수 없다. 전송 속도, 패킷 변조 등 악의적인 가능성이 존재한다.
 
- 깨지기 쉽다.
  - 일부 구현체는 취성(brittleness, 깨지기 쉬운 성질)을 유발할 수 있다.
  - 메서드의 파라미터가 변경되거나, 객체의 필드가 변경되면 클라이언트도 함께 변경해야 한다.
  - 확장만 가능한 객체가 생기며 불필요한 필드가 노출된다.
 
#### 적용 대상

- 네트워크를 완전히 숨기는 수준의 추상화를 하지 말라.
- 클라이언트 업그레이드 없이 인터페이스를 개선할 수 있는지 확인하라.

### 2.2 REST

- 웹에서 영감을 받은 아키텍처 형식
- 리소스
  - Customer처럼 서비스 자체가 알고 있는 것
  - 리소스가 외부에 표시되는 방식과 내부에 저장되는 방식은 완전히 별개
  - 서버는 요청에 따라 Customer에 대한 다양한 표현을 생성
 
#### REST와 HTTP

- http method는 리소스와 함께 작동하는 방법에 대해 상세한 명세를 정의
- 도구와 기술을 지원하는 대규모 생태계도 제공
- rpc를 구현하는 데도 사용 가능하다. http를 사용한다고 rest를 한다고 말할 수는 없다.

#### 애플리케이션 상태 엔진으로서의 하이퍼미디어(HATEOAS)

- 클라이언트-서버 결합을 피하고자 rest에 도입된 원칙

#### 문제점

- 최적화된 바이너리 프로토콜에 비해 성능이 떨어진다.
- 다른 네트워킹 프로토콜에 비해 비효율적인 tcp를 사용한다.
  - http/3의 quic 프로토콜은 tcp와 동일한 종류의 기능을 제공하면서, 지연 시간 개선을 이루어냈다.

- hateoas는 추가적인 성능 문제가 발생할 수 있다.
  - 클라이언트는 엔드포인트를 찾기 위해 여러 컨트롤을 탐색하며 복잡한 프로토콜이 발생할 수 있다.

#### 적용 대상

- ms 간의 동기식 요청 및 응답 기반 통신에 매우 효과적
- 친숙한 인터페이스 방식이며 다양한 기술 간의 상호 운용성을 보장
- 비동기적으로 상호작용하도록 구성할 수 있지만, 다른 대안에 비하면 미흡

### 2.3 그래프QL

- 클라이언트가 동일 정보를 검색하기 위해 여러 번 요청할 필요 없는 쿼리를 정의할 수 있다.
- 검색하는 데이터와 호출 수를 줄일 수 있다.

#### 문제점

- 클라이언트 장치는 동적으로 변경되는 쿼리를 실행할 수 있다. 이는 고비용 sql을 실행하는 것과 동일한 문제를 일으킨다.
  - 그래프QL은 쿼리 플래너와 같은 도구가 없다.
 
- 캐싱도 복잡하다.
  - 일반적인 요청은 http api를 사용하고, 구체적인 요청을 그래프ql을 사용해볼 수 있다.
 
- 이론적으로 쓰기를 사용할 수 있지만 읽기만큼 적합하지 않다.
- 데이터베이스 래퍼로 오해할 수 있다. 데이터 베이스와의 결합되지 않도록 해야 한다.

#### 적용 대상

- 모바일 네트워크의 특성 면에서 제약이 있는 모바일 장치에 적합
- 호출 집계 및 필터링 메커니즘. msa 맥락에서 여러 하위 ms에 대한 호출을 집계하는 데 사용

### 2.4 메세지 브로커

- 프로세스 사이에 위치해 프로세스 간 통신을 관리하는 미들웨어
- 메세지는 메세지 브로커가 보내는 것을 정의하는 일반적 개념
  - 메세지에는 요청, 응답 또는 이벤트가 포함
  - ms와 직접 통신하지 않고 메세지 전송 방법에 대한 정보와 메세지를 메세지 브로커에 전달
 
#### 토픽과 큐

- 큐는 point to point이다.
  - 발신자는 큐에 메세지를 넣고, 소비자는 해당 큐에서 읽는다.
  - 소비자는 하나 이상의 ms로 표현되며 소비자 그룹으로 모델링된다.
  - 큐는 부하 분산 메커니즘으로 작동하며 소비자 그룹의 한 구성원이 해당 메세지를 받는다.
  - 큐를 통해 메세지가 전송될때는 대상에 대한 정보가 있다.
  - 일반적으로 요청 및 응답 통신에 적합하다.
<img width="735" height="385" alt="image" src="https://github.com/user-attachments/assets/ee6b7629-d9df-4755-a562-d7bafb0699a1" />
 
- 토픽
  - 여러 소비자가 토픽을 구독한다.
  - 구독한 소비자는 해당 메세지의 복사본을 받는다.
  - 토픽은 여러 소비자 그룹을 가질 수 있다.
  - 이벤트의 복사본은 별도의 소비자 그룹에 존재하는 하나 이상의 서비스가 수신한다.
  - 토픽을 통해 메세지가 전송될때는 대상에 대한 정보가 발신자에게 숨겨지므로 누가 메세지를 받을지 모른다.
  - 이벤트 기반 통신에 적합하다.
 <img width="733" height="498" alt="image" src="https://github.com/user-attachments/assets/9d1a2c02-a529-41ab-a86a-93455dd6829b" />

#### 전달 보장

- 브로커는 메세지를 전달할 수 있을 때가지 보관하므로 대상이 가용하지 않더라도 문제가 되지 않는다.
- 동기식 호출에서는 메세지가 대상에 도달하지 않았을 때 처리 방식을 고민해야 한다. 재시도하나, 아니면 포기하나.
- 전달 보장을 위해 브로커는 지속적인 방법으로 메세지를 유지해야 한다.
  - 클러스터 기반 시스템으로 실행돼 하나의 머신이 고장나도 메세지가 손실되지 않도록 해야 한다.
  - 올바르게 설정되어 있지 않다면 전달 보장에 대한 약속을 지킬 수 없다.
- 모든 브로커는 전달 보장을 지키기 위해 필요한 운영 방식에 제한을 가진다.

#### 신뢰

- 브로커를 얼마나 신뢰할지도 고려해야 한다.

#### 다른 특성

- 일부 브로커는 쓰기 트랜잭션을 제공한다.
- 정확히 한 번은 논란이 있는 기능이다.
  - 더 나은 방법은 멱등적인 처리이다.
  - 예를 들어 각 메세지는 id를 포함하고 이미 처리된 id인 경우 메세지를 무시하는 방법이 있다.

#### 선택

- 다양한 메세지 브로커가 존재한다.

#### 카프카

- 대규모 처리를 위해 설계되었다.
- 여러 소비자와 생산자를 허용하기 위해 만들어졌다.
- 메세지의 저장 기간을 설정할 수 있다.
- 스트림 처리를 기본으로 제공한다.

## 3. 직렬화 포맷

### 3.1 텍스트 포맷

- 클라이언트가 자원을 사용하는 방법이 유연해진다.
- json은 브라우저에 최적화되었고 간결하며, 단순하다.
- xml은 페이로드의 특정 부분만 추출하려는 경우 많은 도구를 지원한다.

### 3.2 바이너리 포맷

- 페이로드의 크기나 읽기 및 쓰기 효율성을 걱정하는 사람들이 많이 찾는다.
- 다양한 포맷이 존재하지만 성능 비교를 위해서는 벤치마크보다는 직접 해보는 것이 좋다.
- 대부분의 시스템은 데이터를 덜 보내거나 호출 제거하여 기대하는 개선을 수행할 수 있다.
- 극도로 낮은 지연 시간이 필요한 순간이 왔을 때 바이너리 포맷을 고려할 수 있다.

## 4. 스키마

- 엔드포인트가 노출하고 수용하는 것을 정의하기 위해 스키마를 사용해야 하는가?
- 명시적인 스키마가 좋은 문서를 대체할 수는 없지만 필요한 문서의 양을 줄일 수는 있다.
- 엔트포인트의 우발적 고장을 탐지하는 데도 도움이 된다.

### 4.1 구조적 계약 위반 대 의미적 계약 위반

- 구조적 위반
  - 더 이상 호환되지 않는 방식으로의 엔드포인트 구조가 변경되는 상황
  - 필드나 메서드가 제거되거나 새롭게 추가되는 것
  - 메서드의 파라미터 개수가 변경되는 것은 탐지하기 쉽다.
 
- 의미적 계약 위반
  - ms의 그조는 동일하게 유지
  - 소비자의 기대와 다른 방식으로 행동 양식이 변경되는 상황
  - 동작이 변경되는 것은 조금 더 탐지하기 어려울 것이다.
 
### 4.2 스키마를 사용해야 할까?

- 각 버전의 스키마를 비교하면 구조적 위반을 포착할 수 있다.
- 의미적 위반을 포착하려면 테스트를 사용해야 한다.
- 스키마를 사용하지 않기로 한다면 구조적 파손의 책임은 테스트에 있다.
- 스키마가 존재한다고 명시적인 것은 아니다. 어떤 데이터가 포함되고, 어떻게 구성되는지 가정하는 것은 묵시적이다.
- 스키마는 클라이언트-서버 간 구조 계약의 일부를 명시적으로 표현하는 데 큰 도움을 준다.
- 물론 클라이언트-서버 모두 하나의 팀이 소유한다면 스키마가 없는 것이 편할 수 있다.

## 5 마이크로서비스 간의 변경 처리

- 버전 관리를 어떻게 해야 하는가?


## 6. 중단 변경 피하기

#### 확장 변경(expansion changes)
- ms 인터페이스에 새로운 것을 추가하라.
- 다만 오래된 것은 제거하지 않아야 한다.

#### 관대한 독자(tolerant reader)
- ms 인터페이스를 사용할 때 기대하는 것에 유연해야 한다.

#### 올바른 기술(right technology)
- 인터페이스에 하위 호환 가능한 변경 사항을 쉽게 적용하는 기술을 선택하라.

#### 명시적 인터페이스(explicit interface)
- ms가 노출하는 내용은 명확해야 한다.
- 이는 클라이언트 작업을 쉽게 만들고, ms의 유지 보수자는 자유롭게 변경할 수 있는 부분을 더 쉽게 이해한다.

#### 우발적 중단 변경을 일찍 발견하기
- 변경 사항 배포 전에 운영 환경에서 소비자를 중단시킬 수 있는 변경 사항을 찾아내는 메커니즘이 있어야 한다.

### 6.1 확장 변경

- 새로운 추가에 대해 클라이언트가 관대할 것이라 가정한다면 이러한 작업이 중대한 영향을 미치지 않아야 한다.
- 예를 들면 고객 레코드에 `dateOfBirth` 필드를 추가하는 것은 문제없어야 한다.

### 6.2 관대한 독자

- 일부 바인딩 기술을 소비자가 원하는 것과 상관없이 모든 필드의 바인딩을 시도할 수 있다.
- 이러한 상황에서 아무도 사용하지 않는 필드를 제거하는 것은 중단 변경을 가져올 수 있다.
- 마틴 파울러는 관심 없는 변경 사항은 무시할 수 있는 독자를 구현하는 패턴을 관대한 독자라고 부른다.

### 6.3 올바른 기술

- 일부 기술이 인터페이스 변경에 더욱 취약한 반면, 어떤 기술을 클라이언트 중단 없이 쉽게 변경할 수 있게 한다.
- 일례로 gRPC의 일부로 사용되는 직렬화 포맷인 프로토콜 버퍼에는 필드 번호라는 개념이 있다.
  - 프로토콜 버퍼의 각 항목은 클라이언트 코드가 찾을 것으로 예상되는 필드 번호를 정의해야 한다.
  - 클라이언트는 새롭게 추가되는 필드는 신경쓰지 않는다.
 
### 6.4 명시적인 인터페이스

- 명시적 스키마는 소비자가 무엇을 기대하는지 분명히 할 수 있다.
- 소비자를 중단시키지 않으려면 어떤 것을 중단시키지 말아야 하는지 개발자도 쉽게 알 수 있다.
- 즉, 명시적 스키마는 숨겨진 정보의 경계를 더욱 명확하게 만드는 데 도움이 된다.

### 6.5 우발적 중단 변경을 일찍 발견하기

- 정상적인 변경도 소비자를 중단시킬 수 있다. 따라서 이러한 변경을 최대한 빠르게 파악하는 것이 중요하다.
- 여기에는 다양한 도구가 존재한다.(openapi-diff 등)
- 만일 스키마가 없다면 테스트는 중단 변경을 파악하기 위해 더 많은 작업을 수행해야 한다.
- 변경을 발견했다면 중단을 피하거나, 소비자 서비스를 관리하는 사람들과 올바른 대화를 시작해야 한다.

## 7. 중단 변경 관리하기

- 중단 변경이 반드시 필요하다면 어떻게 해야하는가?

#### 락스텝 배포(lockstep deployment)
- 인터페이스를 노출하는 ms와 인터페이스의 모든 소비자를 동시에 변경하는 것이 요구된다.

#### 호환되지 않는 마이크로서비스 버전의 공존
- ms의 이전 버전과 새 버전을 나란히 실행한다.

#### 기존 인터페이스 에뮬레이션
- ms가 새 인터페이슬르 노출하고 기존 인터페이스도 에뮬레이트하도록 한다.

### 7.1 락스텝 배포

- 독립적인 배포와는 대치된다.
- 독립적 배포를 원한다면 소비자에게 새 인터페이스로 업그레이드할 시간을 주어야 한다.

### 7.2 호환되지 않는 마이크로서비스 버전의 공존

- 서비스의 다른 버전들을 한 번에 실행한다.
- 이전 소비자의 트래픽은 이전 버전으로 라우팅하고 새 소비자는 새 버전을 보게 한다.
<img width="748" height="485" alt="image" src="https://github.com/user-attachments/assets/6a1d14d6-b947-42d2-95db-fc4e2f70520d" />

#### 단점
- 첫째, 서비스 버그 수정이 필요할 때 서로 다른 2개의 서비스를 수정하고 배포해야 한다.
- 둘째, 소비자를 올바른 ms로 유도하는 방법을 고민해야 한다. 이는 추적을 어렵게 만든다.
- 셋째, 생성된 고객 데이터는 버전에 관계 없이 모든 서비스에 보여져야 한다.

보통 카나리아 릴리스 같은 작업을 수행할 때 적합하다.

### 7.3 기존 인터페이스 에뮬레이션

- 신구 버전의 엔드포인트를 노출하는 새로운 버전의 서비스를 배포한다.
<img width="752" height="459" alt="image" src="https://github.com/user-attachments/assets/768ff943-9f31-4823-af51-561c2e3a86eb" />
- 이 방식은 호출자가 요청을 적절히 라우팅할 방법이 필요하다. 대표적인 것인 uri 내부에서 버전 번호를 사용하는 것이다.
- 이 방식은 상황을 명확하게 하고 요청 라우팅을 단순화할 수 있다.

### 7.4 어떤 방식을 선호하는가?

- 단일 팀이라면 락스텝 배포가 적절할 수 있다.
 - 익숙해지는 경우 분산 모놀리스와 다름 없어질 수 있다.

- 짧은 시간이라면 서로 다른 버전의 서비스를 동시에 실행시키는 것도 괜찮다.
  - 블루-그린 배포, 카나리아 릴리스같은 경우에는 이 방식의 단점이 줄어든다.
 
- 가능하다면 구버전 엔드포인트를 에뮬레이트하는 것이 좋다. 다른 방식보다 문제를 훨씬 쉽게 처리할 수 있다.

### 7.5 사회적 계약

- 우리가 만들고 있는 하위 호환성 없는 변경은 소비자의 요청에 의한 것이다.
- 소비자에게 가능한한 변경을 수행할 시간을 많이 주기를 바랄 수 있다. 그러나 이는 비용이기 때문에 최대한 빠르게 제거하는 것이 이상적이다.
- 스키마와 마찬가지로 하위 호환성 없는 변경을 명시한다면 작업을 단순화할 수 있다.
- 락스텝 릴리스를 피하고자 한다면 ms의 소유자 및 소비자는 다음 사항을 고려해야 한다.
  - 인터페이스를 변경해야 할 이슈는 어떻게 제기하는가?
  - 소비자와 ms 팀이 변경 사항에 동의하도록 어떻게 협업해야 하나?
  - 소비자를 업데이트하기 위해 누가 작업을 수행할 것인가?
  - 변경 사항에 동의한다면, 소비자가 인터페이스를 제거하기 전에 새로운 인터페이스로 전화하기까지 얼마나 걸리는가?
 
- 효과적인 msa는 소비자 우선 방식을 수용하는 것이다.
- 소비자의 요구가 가장 중요하며 소비자에게 문제를 일으키는 변경으로 인해 발생할 영향을 고려해야 한다.
- 구 버전의 api를 이용하는 하드웨어가 있다면 그것을 유지하는 수밖에 없다. 모든 하드웨어를 교체하는데는 돈이 들어간다.

### 7.6 사용성 추적

- 구 버전의 엔드포인트 사용이 중단되었는지 어떻게 알 수 있을까?
- 각 소비자를 식별할 수 있는 정보가 있다면 간단히 구분할 수 있을 것이다.

### 7.7 극단적 조치

- 소비자가 새로운 버전으로 전환하도록 만들려면 어떻게 해야 하는가?
- 가장 먼저 할 일은 그들과 대화하는 것이다.
- 시간의 흐름에 따라 누가 구버전의 엔드포인트를 사용하고 있는지 추적 가능해야 한다.
- 구버전의 라이브러리에 일부러 sleep을 삽입해 응답을 지연시킬 수도 있다.
- 물론 이는 소비자의 업그레이드를 위해 모든 노력을 기울인 뒤에 행해야 할 일이다.

## 8. 마이크로서비스 세계에서 DRY와 코드 재사용의 위험

- DRY(Don't Repeat Yourself, 반복하지 마라)
- 동작을 변경할 때 해당 동작이 여기저기 복제되어 있다면 놓치기 쉽고 버그로 이어질 수 있다.
- dry는 재사용할 수 있는 코드를 만들도록 유도한다. 중복을 제거하고 추상화된 코드는 여러 곳에서 호출 할 수 있다.
- 그럼 ms 환경에서는?

### 8.1 라이브러리를 통한 코드 공유

- 핵심 엔티티를 나타내는 공통 도메인 객체 라이브러리가 있다고 해보자.
- 작은 변경 하나만 발생해도 서비스를 전부 업데이트해야 한다.
- 메세지 큐를 통해 통신한다면 변경 후 유효하지 않은 메세지를 반드시 모두 비워야 한다.
- 로깅과 같은 공통 코드를 사용하는 것은 외부 세계에 보이지 않는 내부 개념이므로 사용해도 괜찮다.
- 여러 ms가 동일한 라이브러리를 사용한다면 모든 버전 업그레이드를 위해서는 모든 ms를 재배포해야 한다.
- 코드 재사용을 위해 라이브러리를 사용한다면 여러 버전이 존재할 수 있다는 사실을 받아들여야 한다.

#### 클라이언트 라이브러리

- 특정 서비스나 API를 더 쉽게 사용할 수 있도록 미리 만들어 놓은 라이브러리
- 말그대로 고객의 입장에서 개발을 편하도록 돕는 도구
- 외부 api, 서비스를 호출하기 위해 사용하는 sdk와 같은 도구
- 만일 클라이언트 라이브러리 방식을 사용한다면 핵심 비즈니스와 하부 전송 프로토콜을 처리하는 부분을 잘 분리해야 한다.
- 업그레이드 시기를 클라이언트가 담당할 수 있도록 하위 호환성을 잘 유지해야 한다.
- 즉, 서로 독립적으로 서비스 릴리스가 가능해야 한다.

## 9. 서비스 디스커버리

- ms가 어디에 있는지 어떻게 파악하는가?
- 이를 위한 솔루션은 서비스 디스커버리라는 분야에 속한다.
  - 첫째, 인스턴스가 스스로 등록하고 알리는 메커니즘을 제공한다.
  - 둘째, 등록된 서비스를 찾는 방법을 제공한다.
 
### 9.1 도메인 네임 시스템(DNS)
- dns를 이용하면 항상 특정 이름을 통해 서비스에 접근할 수 있다.
- 다양한 환경의 서비스 인스턴스를 처리할 때는 관례 기반의 템플릿이 효과적이다.
  - 예) <서비스이름>-<환경>.musiccorp.net
 
- dns는 표준이라는 장점이 있지만, 일회용 호스트가 많은 환경을 위해 설계된 서비스는 거의 없다.
- 도메인 네임에 대한 엔트리에는 ttl이 존재한다.
  - 따라서 클라이언트가 적어도 ttl에 명시된 기간 동안 이전 ip를 유지한다고 가정해야 한다.
  - 이를 해결하는 방법은 도메인 네임 엔트리가 로드 밸런서를 가리키는 것이다. 로드 밸런서는 새로운 인스턴스가 배포되면 차례로 과거 인스턴스를 제거하면 된다.
- 물론 하나의 인스턴스 뿐이라면 호스트를 직접 참조하는 것이 좋다.
<img width="798" height="394" alt="image" src="https://github.com/user-attachments/assets/a22b54c4-218c-4497-838c-cbac57601321" />

### 9.2 동적 서비스 레지스트리

- 중앙 레지스트리에 서비스를 등록하고, 등록된 서비스를 조회하는 기능을 제공

#### 주키퍼
- 하둡 프로젝트의 일부분으로 개발
- 구성 관리, 서비스 간 데이터 동기화, 리더 선출, 메세지 큐 등 다양한 사례에 사용
- 다양한 상황을 보장하기 위해 최소 3개의 노드를 실행
- 정보를 저장하기 위한 계층적 네임스페이스를 제공
  - 클라이언트는 이 계증체 새로운 노드를 삽입 또는 쿼리한다.
 
#### 콘술(Consul)
- 구성 관리와 서비스 디스커버리를 지원
  - 주키퍼보다는 더 많은 지원을 함
  - 기본 제품 기능으로 dns 서버를 탑재

- 서비스 등록에서 모든 작업에 rest 기반 http 인터페이스를 사용
- 다양한 기술 스택과 통합이 간단

#### etcd와 쿠버네티스

- etcd는 콘술과 유사한 기능을 가짐. 쿠버테시트는 이를 사용해 구성 정보를 관리
- 포드에 컨테이터를 배포, 포드와 관련된 메타데이터에 대한 패턴 매칭을 통해 어떤 포드가 서비스에 포함되는지 동적으로 식별

#### 내 식대로 만들기

- aws는 각 인스턴스와 관련된 메타데이터의 저장을 처리하고 해당 데이터를 쿼리하는 기능을 제공
- 이를 활용하여 자체 시스템을 만드는 것도 제공
- 그러나 이 분야에 여러 도구들이 충분히 성숙해졌기 때문에 굳이 처음부터 도구를 만들 필요는 없음

### 9.3 사람이 사용한다는 것을 잊지 말자!

- 인간이 사용하기 쉽도록 api를 통해 인간의 레지스트리로 가져올 수 있는 것도 중요하다.

## 10. 서비스 메시와 API 게이트웨이

- api 게이트웨이는 시스템 주변에 자리 잡고 남-북 방향(외부 세계와의) 트래픽을 처리
  - 외부 세계에서 내부 ms에 대한 액세스를 관리
 
- 서비스 메시는 동-서 방향(경계 내부의 ms 간 통신)을 처리
<img width="759" height="426" alt="image" src="https://github.com/user-attachments/assets/18abebc1-fad0-4c41-8bcb-6477fb3d5fb4" />

- 서비스 메시와 api 게이트웨이는 ms 사이의 프록시로 동작 가능
- 이러한 동작은 ms의 특정 동작과 무관하게 범용적이어야 함

### 10.1 API 게이트웨이

- 주요 관심사는 외부의 요청을 내부 ms로 매핑하는 것
- 일반적으로 http 프록시 위에 더 많은 기능을 추가한 것이며 대부분 리버스 프록시로 동작
- 외부 당사자용 api 키, 로깅, 속도 제한 등과 같은 메커니즘 구현에 사용 가능
- api 게이트웨이의 모든 기능이 필요하지는 않음. 따라서 api 게이트웨이를 원한다면 무엇을 기대하는지 명확해야 함

#### 적용 대상

- 쿠버네티스에서 실행되는 ms를 노출하는 경우에는 자체 리버스 프록시를 도입할 수 있음
- 또는 처음부터 이러한 사례를 염두에 두고 만들어진 전문 제품을 살펴볼 수 있음

#### 회피 대상

- 호출 집계, 프로토콜 재작성, 경계 내 호출에는 필요하지 않음
- 호출 집계의 경우 핵심 비즈니스 로직이 제 3자의 도구에 반영될 수 있음
- 프로토콜 재작성은 프록시 계층에서 단순하게 구현될 수 없음
- 이는 파이프를 멍청하게, 엔트포인트를 똑똑하게 유지한다(keeping the pipes dumb, and endpoints smart)는 규칙을 위반하는 것
- ms의 독립적 배포를 위해서는 ms에서 많은 지능을 유지해야 함
- 경계 내 호출의 경우 중간에 프록시가 끼어든다면 필요 이상의 지연 시간이 발생

### 10.2 서비스 메시

- 서비스 메시를 사용하면 ms 간 통신과 관련된 공통 기능이 메시로 푸시됨
- ms가 내부적으로 구현해야 하는 기능을 줄이는 동시에 특정 작업의 수행 방식에 일관성을 제공
- 메시를 사용하면 서로 다른 언어로 작성된 서비스 간 공통 기능을 재사용할 수 있다.
- 공유 라이브러리와 달리 재빌드, 재배포 없이 통신 측면의 변경 사항을 유연하게 배포할 수 있다.

#### 작동 방식

- 외부와의 통신이 여러 개의 경계 내 통신으로 이어질 수 있다. 이러한 추가 호출로 발생하는 오버헤드를 인식해야 한다.
- 원격 네트워크 호출 수를 제한하기 위해 동일한 물리 머신에서 서비스와 프록시를 분산하도록 구성할 수 있다.
<img width="736" height="427" alt="image" src="https://github.com/user-attachments/assets/0b22d9c7-f65a-4d97-84e5-48e7bf5649c0" />
- 컨트롤 플레인(control plane)은 로컬 메시 프록시 위에 있으며, 프록시 동작을 변경하고 프록시 작업에 대한 정보를 수집한다.

#### 서비스 메시는 똑똑한 파이프 아닐까?

- 공통 동작은 특정 ms에 국한되는 것이 아니다.
- 예) 요청 타임아웃을 처리하는 것과 같은 범용적인 사항

#### 필요할까?

- 쿠버네티스를 사용하지 않는다면 옵션이 제한됨
- 복잡성이 증가함
- 많은 ms를 가진 조직에서는 서비스 메시를 살펴볼 가치가 있음

### 10.3 다른 프로토콜은 어떨까?

- api 게이트웨이와 서비스 메시는 주로 http 관련 호출을 처리하는 데 사용
- 메세지 브로커의 경우 서비스 메시를 거치지 않고 브로커끼리 직접 통신한다.

## 11. 서비스 문서화

- 이상적인 ms api를 위해 항상 문서가 최신 상태인 것을 보장해야 함

### 11.1 명시적 스키마

- 구조를 드러내는 것에는 도움이 되지만 동작을 전달하는 데는 도움이 되지 않음
- 따라서 여전히 좋은 문서가 필요. 하지만 낡은 문서는 문제가 됨
- 반면 명시적 스키마는 최신 상태일 가능성이 높다.

#### 11.2 자기 기술 시스템

- 마틴 파울러는 인간이 위키에 기록하는 가벼운 접근 방식인 휴먼 레지스트리를 논의
- 위키같은 단순한 것부터 시작. 시간이 지남에 따라 더 많은 정보를 수집.
- 이러한 정보를 사용하기 쉽게 만드는 것이 대규모 시스템의 복잡성을 관리하기 위한 핵심 도구
- 어떤 기업은 수백개의 서비스에 대한 유용한 정보를 찾을 수 있는 제품을 제공하기도 함
