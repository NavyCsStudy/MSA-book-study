# 5. 마이크로서비스의 통신 구현

## 5.1 이상적인 기술을 찾아서

#### 5.1.1 하위 호환성을 쉽게 하라
- MS 를 변경할 때는 해당 서비스를 사용하는 MS 의 호환성을 깨지지 않도로 해야 함
- 변경 사항이 이전 버전과 호화되는 지는 검증할 수 있는 방법과 운영 환경에 배포하기 전 피드백 방법 마련이 필요

### 5.1.2 인터페이스를 명시적으로 만들라
- 외부로 노출되는 인터페이스는 명시적이어야 함
- 소비자가 MS 로 부터 제공받는 기능을 명확하게 문서화하는 것을 권장

### 5.1.3 API 를 기술 중립적으로 유지하라
- IT 는 급변하는 분야이며, MS 간의 통신에 사용된 API 를 기술 중립적으로 유지하는 것은 중요함

### 5.1.4 소비자를 위해 서비스를 단순하게 만들라
- 소비자가 MS 를 쉽게 사용할 수 있도록 만들어야 함

### 5.1.5 내부 구현 세부 사항을 숨겨라
- 소비자가 MS 의 내부 구현에 종속 된다면 결합도가 증가하게 됨
- 결합도가 높을 경우 MS 내부에서 변경을 했을 때 소비자도 변경해야하는 상황이 발생 -> 비용 증가 초래
- 따라서 내부 표현의 상세 정보를 노출하도록 강요하는 기술은 피해야 함

## 5.2 기술 선택
- 원격 프로시저 호출
    - 원격 서버의 메서드를 로컬 함수처럼 호출하는 프레임워크
    - SOAP, gRPC
- REST
    - 공통의 메서드(GET, POST 등)을 사용해 액세스 가능한 리소스(고객, 주문 등)를 노출하는 아키텍처 방식
- 그래프QL
    - 새로운 프로토콜로, 소비자가 여러 하위 MS 에서 정보를 가져올 수 있는 사용자 지정 쿼리를 정의, 필터링하는 방식
- 메시지 브로커
    - 큐나 토픽을 통해 비동기 통신을 허용하는 미들웨어

### 5.2.1 원격 프로시저 호출(RPC)
- 원격 서버의 메서드를 로컬 함수처럼 호출하는 기술
- 종류 : SOAP, gRPC
- 명시적 스키마가 있는 RPC 프레임워크를 사용하면, 클라이언트는 서비스의 명세에 대해 스스로 코드를 생성할 수 있음. 단, 호출하기 전에 스키마에 엑세스 하여 가져오는 작업이 필요

#### 문제점
- 기술 결합이 발생
    - 일부 RPC 는 클라이언트와 서버에서 사용될 수 있는 기술이 제한적
- 로컬 호출 != 원격 호출
    - 원격 메서드를 로컬 메서드 호출 처럼 보이게하는 RPC 형태는 두 호출이 매우 다르다는 사실을 감춤
    - RPC는 네트워크를 통해 전송되는 방식이고, 페이로드 또한 마샬링/역마샬링 작업이 필요
    - 따라서 원격 인터페이스와 로컬 인터페이스의 API 설계를 다르게 할 필요가 있음
- 깨지기 쉽다
    - 변경이 발생하면 깨지기 쉬움. 예를 들어 한 소비자에 새 메서드를 추가하는 경우 클라이언트 스텁을 재생성 해야하고, 새 메서드가 필요하지 않은 소비자도 스텁을 갱신해야하는 상황이 발생할 수 있음

#### 적용 대상
- 동기식 요청 및 응답, 리액티브 프로그래밍 모델과 잘 어울림
- 서버 변경 시 클라이언트 코드를 매번 다시 컴파일해야 하는 구조라면, gRPC보다는 스키마 공유가 필요 없는 REST API가 더 적합

### 5.2.2 REST
- 웹에서 영감을 받은 아키텍처 형식
- 서버는 리소스에 대한 다양한 표현을 생성

#### REST와 HTTP
- HTTP 는 REST 형식에 맞는 기능이 정의되어있음
- HTTP 동사(GET, POST 등)는 특정 리소스에 적용해야하는 방법을 HTTP 명세에 정의
- REST 형식은 해당 동사가 모든 리소스에 대해 동일한 방식으로 작동해야한다고 지정
    - GET: 명등적으로 리소스 검색, POST: 새로운 리소스 생성
- HTTP 는 도구와 기술을 지원하는 대규모 생테계도 지원(HTTP 캐싱 프록시, 로드 밸런서, 모니터링 도구)
- HTTP 는 보안 통제를 사용해 통신을 보호, 보안 프로세스를 쉽게 만드는 도구를 제공

#### 애플리케이션 상태 엔진으로서의 하이퍼미디어(HATEOAS)
- 하이퍼미디어
    - 링크가 포함된 다양한 형대의 콘텐츠(텍스트, 이미지 등)
    - 예시) 링크를 클릭하여 다른 페이지로 이동
- HATEOAS
    - REST 의 중요한 원칙 중 하나
    - 클라이언트가 서버의 상태 변화(다음 행동)를 링크(하이퍼미디어)를 통해 알 수 있게 하는 것
- HATEOAS 의 의도
    - 클라이언트와 서버의 결합도를 낮추는 것
    - 클라이언트는 서버의 URI이나 내부 구조를 알 필요 없이, 서버가 제공하는 링크를 따라가면 됨
```
<album>
<name>Give Blood</name>
<link rel="/artist" href="/artist/theBrakes" >/
‹description>
Awesome, short, brutish, funny and loud. Must buy!
</description>
<link rel="instantpurchase" href="/instantPurchase/1234" />
</album>
```
- 클라이언트는 artist 링크를 통해 아티스트 정보를 얻음
- instantpurchase 링크를 콩해 구매 요청을 보냄

-> 즉, URI 를 미리 알 필요 없이 하이퍼링크를 통해 탐색하면서 필요한 작업을 수행

- 서버 구조가 바뀌어도 클라이언트를 수정할 필요가 없음, 유연성 증가
- 서버가 새로운 링크를 응답에 추가하면, 클라이언트는 이를 해석해서 사용
- 하지만 실제로는 **실무에서 거의 사용되지 않음**
    - 구현이 복잡함
    - 대부분의 클라이언트는 이미 고정된 API 경로를 알고 있고, 고정된 엔드포인트에 맞춰 개발

#### 문제점
1. 클라이언트 요청/응답 코드 자동 생성이 어려웠음
- RPC처럼 스키마 기반이 아니라서, 개발자가 직접 REST 클라이언트를 짜야 했음 -> 그래서 Swagger/OpenAPI로 해결 중 (자동 코드 생성 가능)
2. HTTP 요청 자체의 오버헤드가 있음
- TCP 기반이라 빠른 통신이 필요한 경우엔 한계가 있음
- QUIC(HTTP/3) 같은 신기술로 개선 중
3. HATEOAS는 실무에서 잘 안 씀
- 클라이언트가 링크를 따라 탐색하는 REST 원칙인데, 너무 복잡하고 비효율적

#### 적용 대상
- 외부 공개 API, 클라이언트용 API로는 훌륭함
- 서비스 간 내부 통신에서는 비효율적일 수 있음
- 캐싱, 브라우저 호환성, 범용성에서 강점이 있음

### 5.2.3 그래프 QL
- 필요한 데이터만 한 번에 조회 가능
    - REST는 여러 번 호출해야 하지만, GraphQL은 한 쿼리로 가능 -> 모바일이나 느린 네트워크 환경에 특히 유리
- 유연한 데이터 요청
    - 클라이언트가 어떤 필드가 필요한지 직접 지정 가능

#### 문제점
- 서버 부하 문제
    - 클라이언트가 자유롭게 쿼리를 만들 수 있어서, 복잡한 쿼리로 서버가 과부하될 수 있음
    - 캐싱이 어려움
        - REST처럼 URL 기반이 아니라 쿼리 기반이라, 캐시하기 어려움
- 쓰기(Mutation) 처리에는 부적합
    - 읽기 중심이라, 데이터를 변경하는 로직은 REST를 함께 써야 하는 경우도 있음
- 서비스를 데이터베이스처럼 보이게 함
    - 마이크로서비스의 비즈니스 로직이 사라지고 “그냥 데이터 API”처럼 보일 위험

#### 적용 대상
- UI나 모바일 앱 같은 외부 클라이언트용 API에 적합
- 내부 서비스 간 통신에는 비효율적
- REST를 완전히 대체하는 게 아니라, 보완적인 역할

### 5.2.4 메시지 브로커
- 서비스 간 직접 통신 대신, 중간에서 메시지를 대신 전달해주는 중개자
- ex) “주문 서비스”가 “결제 서비스”에 직접 요청하지 않고, 메시지 브로커(예: Kafka, RabbitMQ)에 “결제 요청 메시지” 전송
- 브로커가 그 메시지를 결제 서비스에게 전달함 → 비동기 통신
- 즉, “서버 대 서버” 통신을 메시지를 매개로 느슨하게 연결하는 방식

#### 토픽과 큐

1. 큐
- 메시지를 하나씩 꺼내서 처리
- 한 메시지는 한 소비자만 받음
- ex) 요청/응답 (예: 주문 처리)
- RabbitMQ

2. 토픽
- 여러 소비자에게 동시에 알림
- 한 메시지를 여러 소비자 그룹이 각각 받음
- ex) 이벤트 알림 (예: 주문 완료 알림)
- Kafka

#### 전달 보장
- 메시지 브로커가 제공하는 **메시지를 잃지 않고 잘 전달하겠다**는 약속
- 전달 보장을 하기 위해서는 메시지가 배달될 때까지 브로커는 메시지를 유지해야함
- 전달 보장을 위해 일반적으로 클러스터 기반 시스템으로 실행

#### 다른 특성
- 순서 보장
    - 카프카는 “같은 파티션 안에서”만 순서가 보장
- 쓰기 트랜잭션
    - 여러 메시지를 하나의 트랜잭션처럼 처리할 수 있음
    - 카프카는 단일 트랜잭션에서 여러 토픽을 쓸 수 있음

#### 카프카
- 대량 데이터나 실시간 이벤트 처리에 강함
- 대규모 확장성: 수만 개의 생산자/소비자도 처리 가능
- 메시지 영속성: 메시지를 “삭제 안 하고” 계속 저장 가능
- 스트림 처리 기능: 내장 KSQL, Kafka Streams 등으로 실시간 데이터 처리 가능

## 5.3 직렬화 포맷
- 직렬화: 데이터를 네트워크로 주고받거나 파일로 저장하기 위해 객체를 바이트 형태로 변환하는 과정
- 역직렬화: 반대로 받을 때는 다시 원래의 객체로 되돌리는 과정

### 5.3.1 텍스트 포맷
- 예: JSON, XML
- 사람이 읽기 쉬운 형태
- 상호운용성(호환성) 이 좋음 -> 다양한 언어나 시스템에서 쉽게 사용 가능
- 주로 REST API 에서 사용됨 (요청/응답 body로 JSON을 주고받는 것)

### 5.3.2 바이너리 포맷
- 사람이 읽을 수는 없지만, 속도와 효율이 매우 뛰어남
- 데이터를 압축된 형태로 주고받기 때문에 네트워크 비용이 줄어듦
- RPC 같은 RPC 시스템에서 주로 사용됨
- 장점: 전송 속도 빠름, 직렬화/역직렬화가 효율적
- 단점: 사람이 직접 보기 어려움, 디버깅 불편, 언어나 프레임워크 간 변환이 복잡할 수 있음

## 5.4 스키마
- 스키마: “서비스가 어떤 데이터를 주고받는지”를 명시적으로 정의한 문서
- 명시적 스키마를 사용하는 것을 추천
- 이유1: 서비스 인터페이스를 명확히 표현
    - 스키마를 통해 마이크로서비스가 제공하거나 수용하는 데이터 구조를 명시적으로 표현할 수 있음
    - 개발자 입장에서 문서를 읽지 않아도 형태가 바로 보임 -> 개발 생산성 증가

- 이유2: 서비스 간 호환성 깨짐(breakage) 감지에 유용
    - 스키마가 있으면 “이전 버전과 달라진 부분”을 쉽게 검증 가능
    - 즉, 스키마는 **API 변경 관리(change management)**에 도움을 줌

### 5.4.1 구조적 계약 위반 대 의미적 계약 위반
1. 구조적 계약 위반 (Structural Contract Violation)
- 형태(구조) 자체가 바뀌는 경우
- ex) 필드 삭제, 이름 변경, 새로운 필드 추가, 파라미터 개수 변경, 메서드 시그니처 변경
- 클라이언트가 기존 방식으로 호출하면 요청이 실패함 (즉시 깨짐)
- 이런 변경은 스키마 비교로 쉽게 탐지 가능

2. 의미적 계약 위반 (Semantic Contract Violation)
- API 구조는 같지만, 동작(의미) 이 바뀌는 경우
- ex) 여전히 calculate(int a, int b) 를 받지만, 기존엔 두 수를 더하던 것이 이제 곱하기로 바뀜
- API 호출은 성공하지만, 결과가 기대와 다름
- 테스트 없이는 발견하기 어려움
- 이런 위반은 스키마로는 잡히지 않음
- 행위(behavior) 가 바뀌었기 때문 → 테스트를 통해만 검출 가능

### 5.4.2 스키마를 사용해야 할까?
1. 구조적 위반은 스키마로 탐지 가능
- 명시적 스키마를 두면 버전 간 비교로 구조 변화 감지 가능
= 테스트 이전 단계(빌드 시점)에 문제 발견 가능 → 안정성 증가

2. 의미적 위반은 테스트로만 탐지 가능
- 스키마는 형태만 보장
- 동작 변화는 자동 감지가 불가능하므로 테스트 필요

### 스키마 사용의 현실적 고려
- “스키마 없는 API”도 사실상 스키마를 암묵적으로 전제하고 있음. 따라서 명시적으로 관리하는 것이 훨씬 안전
- 스키마를 쓰면 초기 설정은 번거롭지만
    - 구조적 파손 조기 탐지 가능
    - 클라이언트-서버 계약이 명확해짐
    - 팀 간 의사소통 원활
- 반대로, 클라이언트와 서버가 모두 같은 팀에서 빠르게 수정 가능한 환경이라면 -> 스키마 없이 개발하는 것이 더 편할 수도 있음

## 5.5 마이크로서비스 간의 변경 처리
- 변화를 처리하는 방법은 두가지 주제로 나뉨
1. 중단 변경을 피하기 위해 무엇을 할 수 있을 지
2. 중단 변경이 필요한 경우 어떻게 되는지