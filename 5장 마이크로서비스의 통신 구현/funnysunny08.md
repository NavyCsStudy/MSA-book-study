## 5.1 이상적인 기술을 찾아서

### 5.1.1 하위 호환성을 쉽게  하라

어떤 기술을 선택하든 마이크로서비스를 변경할 때 해당 서비스를 소비하는 마이크로서비스와의 호환성이 깨지지 않도록 해야 한다.

### 5.1.2 인터페이스를 명시적으로 만들라

마이크로서비스 인터페이스는 명시적이어야 한다.

명시적 스키마는 마이크로서비스가 노출하는 인터페이스가 명시적이라는 것을 보장하는 데 큰 도움이 된다. (+ 지원 문서)

### 5.1.3 API를 기술 중립적으로 유지하라

마이크로서비스 간 통신에 사용된 API를 기술 중립적으로 유지하는 것이 중요하다.

다른 팀이나 서비스가 특정 기술을 강제로 써야만 하는 구조는 피해야 한다.

### 5.1.4 소비자를 위해 서비스를 단순하게 만들라

소비자가 마이크로서비스를 쉽게 사용할 수 있도록 만들라. → 비용, 기술 선택의 자유 등등

### 5.1.5 내부 구현 세부 사항을 숨겨라

소비자가 우리의 내부 구현에 종속되는 상황을 바라지 않는 것은 결합이 증가하기 때문이다.

마이크로서비스 내부에서 무언가를 변경하려는 경우 소비자에게도 변경을 요구해 소비자를 불편하게 만들 수 있다.

따라서 내부 표현의 상세 정보를 노출하도록 강요하는 기술은 피해야 한다.

## 5.2 기술 선택

### 5.2.1 원격 프로시저 호출

> RPC는 원격 서비스를 로컬처럼 호출하는 기술로, 명시적 스키마(IDL)를 통해 다양한 언어 간 통신을 가능하게 한다.
> 
> 
> 단, 스키마 공유와 관리가 필수다.
> 
- RPC(Remote Procedure Call)은 원격 서버의 함수를 로컬에서 호출하듯 실행할 수 있게 하는 기술이다.
- SOAP, gRPC 등은 명시적 스키마(Interface Definition Language, IDL) 를 필요로 한다.
    - SOAP의 경우 이 스키마를 WSDL(Web Services Description Language) 로 정의한다.
- 명시적 스키마를 사용하면 다양한 기술 스택에서 클라이언트 및 Stub 코드를 자동으로 생성할 수 있다.
- 즉, 클라이언트는 서비스 명세만 있으면 자체적으로 코드를 생성할 수 있어 별도의 공통 라이브러리 없이도 통신 가능하다.
- 다만, 클라이언트가 해당 스키마를 어디선가 확보할 방법이 필요하다는 제약이 있다.
- RPC 기술은 보통 직렬화 프로토콜을 포함하며, 데이터의 직렬화·역직렬화 방식을 프레임워크 수준에서 정의한다.

**문제점**

- 기술 결합
    - Java RMI처럼 특정 플랫폼이나 언어에 종속되는 RPC 구현이 있다.
    - 이는 내부 기술 세부 정보를 외부에 노출하는 형태가 될 수 있다.
    - 다만 gRPC, Thrift 등은 비교적 기술 중립적인 RPC 구현이다.
- 로컬 호출 ≠ 원격 호출
    - 네트워크 전송, 직렬화/역직렬화로 인한 성능 오버헤드가 있다.
    - 네트워크 장애, 지연, 패킷 손상 등 신뢰성 문제도 존재한다.
- 깨지기 쉬운 구조
    - 스키마(데이터 구조)가 바뀌면 역직렬화 과정에서 오류가 발생할 수 있다.
    - 오래된 필드는 쉽게 제거하지 못해 API가 점점 비대해지는 문제가 생긴다.

**적용 대상**

- 네트워크를 완전히 숨기지 말라.
    - RPC가 로컬 호출처럼 보이더라도, 실제로는 네트워크 호출임을 인지해야 한다.
    - 서버 인터페이스를 개선하더라도 클라이언트를 강제 업그레이드하지 않게 설계하라.
- gRPC의 활용 시점
    - 요청/응답이 명확하고, 클라이언트와 서버를 모두 제어할 수 있을 때 적합하다.
    - 동기식 호출뿐 아니라 스트리밍이나 반응형 통신에도 잘 어울린다.
- REST API로 대체가 더 나은 경우
    - 여러 언어나 플랫폼에서 접근해야 하거나  클라이언트가 서버 스키마를 컴파일할 수 없는 환경이라면 → HTTP 기반 REST API가 더 적절하다.

### 5.2.2 REST

- REST(Representational State Transfer)의 핵심은 리소스(Resource) 개념이다.
    - 리소스는 예를 들어 `Customer`처럼 서버가 관리하는 데이터 객체이다.
    - 서버는 요청에 따라 해당 리소스의 다양한 표현(Representation)을 생성해 반환한다.
- REST는 일반적으로 HTTP 프로토콜을 기반으로 구현된다.

**REST와 HTTP**

- HTTP는 REST 철학에 잘 맞는 여러 기능을 제공한다.
    - HTTP 메서드(GET, POST, PUT 등) 는 리소스 조작 방식에 대한 표준 동작을 정의한다.
        - `GET`: 리소스 조회 (멱등적)
        - `POST`: 리소스 생성
    - 예를 들어 `/customers` 엔드포인트는 고객 리소스를 다루며, 가능한 작업은 HTTP 메서드로 표현된다.
- HTTP는 풍부한 생태계를 갖추고 있다.
    - 캐싱(예: Varnish), 로드밸런싱(mod_proxy), 모니터링·보안 도구 등 다양한 인프라 지원.
    - 이를 통해 대규모 트래픽을 효율적이고 안정적으로 처리할 수 있다.

**HATEOAS (Hypermedia as the Engine of Application State)**

- HATEOAS는 REST의 핵심 제약 중 하나로 “클라이언트가 서버의 URI 구조를 미리 알지 않아도 된다”는 점이 핵심이다.
- 서버는 응답 본문에 하이퍼링크(링크 메타데이터) 를 포함해 클라이언트가 다음에 수행할 수 있는 동작을 링크 탐색을 통해 발견하도록 유도한다.

```json
{
  "id": 1,
  "name": "Alice",
  "email": "alice@example.com",
  "_links": {
    "self": { "href": "/customers/1" },
    "update": { "href": "/customers/1", "method": "PUT" },
    "orders": { "href": "/customers/1/orders" }
  }
}
```

- 클라이언트는 서버가 제공한 링크를 따라 다음 상태로 전이(transition) 하며 동작함
- 결과적으로 클라이언트-서버 간 결합도가 크게 낮아짐
- 이런 구조를 통해 API는 더 유연하고 진화 가능한 형태가 된다.

**문제점**

- 클라이언트 코드 생성의 어려움
    - 초기 REST는 명시적 스키마가 없어, 클라이언트 측 코드를 자동 생성하기 어려웠다.
    - 이 때문에 직접 클라이언트 라이브러리를 제공하는 경우가 많았고 결과적으로 서버-클라이언트 간 결합도가 높아졌다.
    - 최근에는 Swagger / OpenAPI 명세를 통해 다양한 언어의 클라이언트 코드를 자동 생성할 수 있게 되면서 이 문제가 완화되었다.
- 성능 한계
    - REST는 JSON 기반이라 SOAP보다 간결하지만 gRPC 등의 바이너리 프로토콜보다는 비효율적이다.
    - HTTP 요청마다 발생하는 네트워크 오버헤드로 인해 지연 시간이 중요한 환경에서는 부적합할 수 있다.
    - HTTP/3(QUIC 기반)은 이러한 성능 문제를 개선하기 위한 시도다.
    - HATEOAS를 사용할 경우 링크 탐색 과정에서 여러 번의 요청이 필요해 추가 round-trip 비용이 발생할 수 있다.
- 그럼에도 불구하고, REST는 여전히 서비스 간 통신의 기본 선택지로 널리 사용된다.

**적용 대상**

- 높은 상호운용성
    - REST는 대부분의 개발자가 익숙하고 언어·플랫폼 간 호환성이 좋아 외부 API나 공개 인터페이스에 적합하다.
- 효율적인 캐싱 구조
    - HTTP 캐싱 메커니즘을 활용해 대량의 요청을 효과적으로 처리할 수 있다.
- 적용 범위
    - REST는 마이크로서비스 간의 동기식 통신이나 외부 파트너 API 제공에 적합하다.
    - 다만, 고성능·저지연이 필요한 내부 통신에서는 gRPC 같은 바이너리 기반 프로토콜이 더 나을 수 있다.
- HATEOAS에 대한 견해
    - 일부 상황에서는 효과적일 수 있지만 모든 시스템에 반드시 필요한 것은 아니다.

### 5.2.3 GraphQL

- GraphQL은 클라이언트가 정확히 필요한 데이터만 요청할 수 있도록 설계된 쿼리 기반 API 규격이다.
- 이를 통해 클라이언트는 여러 REST 요청을 한 번의 쿼리로 대체할 수 있으며 특히 제한된 성능의 모바일·웹 환경에서 효율적인 데이터 조회가 가능하다.
- 예시: 고객의 최근 주문 내역을 표시하는 화면
    - REST 방식이라면 “고객 정보”와 “주문 내역”을 각각 다른 서비스에서 가져와야 한다.
    - GraphQL을 사용하면 **단일 쿼리로 필요한 데이터(최근 5건 + 고객 정보)**를 한 번에 가져올 수 있다.
- 이를 위해 마이크로서비스가 GraphQL 엔드포인트를 노출해야 한다.

**문제점**

- 서버 부하 증가 가능성
    - 클라이언트가 동적으로 다양한 쿼리를 날릴 수 있어 예측하기 어려운 복잡한 요청이 서버 리소스를 과도하게 소모할 수 있다.
- 성능 및 문제 추적 어려움
    - GraphQL에는 SQL처럼 쿼리 실행 계획이 없어 느린 쿼리나 비효율적인 요청을 분석하기 어렵다.
- 캐싱 복잡성
    - REST의 리소스 단위 캐싱(URI 기반)과 달리 GraphQL은 여러 리소스를 한 쿼리로 반환하므로 일반적인 HTTP 캐시를 적용하기 어렵다.
    - 해결책으로 각 리소스에 고유 ID 기반 캐싱 전략을 적용하기도 한다.
- 쓰기(Write) 작업의 비적합성
    - GraphQL은 이론적으로 쓰기를 지원하지만 실제로는 조회에 더 적합하다.
    - 따라서 일반적으로 읽기에는 GraphQL 쓰기는 REST를 함께 사용하는 하이브리드 접근이 많다.
- 비즈니스 로직과의 혼동
    - GraphQL은 데이터를 직접 다루는 느낌을 주지만 마이크로서비스는 단순한 데이터 래퍼가 아니라 고유한 도메인 로직을 가져야 한다.
    - 따라서 GraphQL API가 내부 DB와 직접 결합되지 않도록 주의해야 한다.

**적용 대상**

- 외부 클라이언트 인터페이스
    - 사용자 GUI(웹·앱)나 외부 개발자용 API 등 클라이언트가 다양한 데이터 조합을 요청하는 환경에 적합하다.
- API 호출 집계
    - 여러 하위 마이크로서비스에서 데이터를 조합해야 하는 경우 GraphQL은 호출을 집계·필터링하는 데 매우 유용하다.
- 대안 고려
    - GraphQL은 효과적인 솔루션이지만 복잡성이 높거나 내부 마이크로서비스 간 통신에는 BFF(Backend for Frontend) 패턴 같은 대안도 고려할 수 있다.

### 5.2.4 메시지 브로커

- 메시지 브로커는 마이크로서비스 간 통신을 중개하는 미들웨어이다.
- 서비스들은 직접 통신하지 않고, 메시지를 브로커에 전달해 비동기적으로 주고받는다.
- 메시지에는 요청 및 응답, 이벤트 등이 포함될 수 있다.

**토픽과 큐**

| 구분 | 큐 (Queue) | 토픽 (Topic) |
| --- | --- | --- |
| 통신 방식 | Point-to-Point (1:1) | Publish-Subscribe (1:N) |
| 수신자 | 하나의 소비자 그룹 내 한 인스턴스만 수신 | 구독한 모든 소비자 그룹이 각각 메시지 복사본 수신 |
| 용도 | 요청-응답 패턴에 적합 | 이벤트 기반 협업에 적합 |
| 발신자 인식 | 발신자가 수신자 존재를 앎 | 발신자는 누가 받을지 모름 (느슨한 결합) |
| 부하 분산 | O (큐 내부의 소비자 그룹 내 분산 처리) | 그룹 단위로 가능 (토픽-파티션 구조 활용) |
- 소비자는 하나 이상의 마이크로서비스로 표현되며 일반적으로 소비자 그룹으로 모델링된다.
    - 이는 여러 마이크로서비스 인스턴스가 있고 그중 하나가 메시지를 수신하길 원할 경우에 유용하다.
    - 메시지가 큐에 들어가면 소비자 그룹의 한 구성원만 해당 메시지를 받는다 → 부하 분산
- 토픽을 사용하면 여러 소비자 그룹을 가질 수 있다.
    
    <img width="1000" height="685" alt="Image" src="https://github.com/user-attachments/assets/4bbf9a6b-6b54-46d0-9000-349e1db19c17" />
    

**전달 보장**

- 브로커는 메시지를 소비자에게 성공적으로 전달할 때까지 보관한다. → 소비자가 일시적으로 다운돼도 메시지가 손실되지 않음.
- 이를 통해 업스트림 서비스는 신경 써야 할 실패 처리가 줄어든다.
- 신뢰성 확보를 위해 브로커는 보통 클러스터링 환경에서 실행되어 일부 노드 장애에도 메시지를 보존한다.
- 단, 전달 보장의 수준은 브로커마다 다르므로 정확히 이해하고 선택해야 한다.

**신뢰**

- 메시지의 안전한 전달을 위해서는 브로커 소프트웨어뿐 아니라 운영 환경(클러스터 설정, 복제, 장애 대응 등)도 신뢰할 수 있어야 한다.
- 즉, 기술적 신뢰 + 운영 신뢰가 모두 중요하다.
- 브로커를 얼마나 신뢰할 것인지 결정해야 한다.

**다른 특성**

- 메시지 순서 보장: 예를 들어 Kafka는 파티션 단위에서만 순서를 보장한다.
- 트랜잭션 지원: 일부 브로커는 메시지 쓰기에 대해 트랜잭션 기능을 제공한다.
- 정확히 한 번 전달(Exactly-once delivery):
    - 완벽하게 보장하기는 어렵지만, 메시지 ID를 통해 중복 처리를 방지할 수 있다.

**카프카**

- Kafka는 고성능 메시지 브로커이자 스트리밍 플랫폼이다.
- 특징:
    - 대용량 데이터 스트림 전송에 최적화 (배치 → 실시간 처리 전환 용이)
    - 여러 생산자·소비자 동시 지원
    - 메시지 영속성:
        - 소비 후에도 메시지를 삭제하지 않고 설정된 보관 기간(retention) 동안 유지 가능
        - 이를 통해 신규 소비자도 과거 메시지 재처리 가능
    - 스트림 프로세싱 내장:
        - 외부로 데이터를 내보내지 않고 Kafka 내부에서 실시간 처리 가능
        - `KSQL`을 통해 SQL 유사 문법으로 토픽 데이터를 처리
        - DB처럼 지속적으로 갱신되는 구체화 뷰(materialized view) 형태 구현 가능

## 5.3 직렬화 포맷

### 5.3.1 텍스트 포맷

- 사람이 읽기 쉽고 디버깅이 편하다.
- 다양한 언어와 플랫폼에서 쉽게 처리 가능해 상호 운용성이 높다.
- HTTP 기반 REST API에서 가장 널리 사용된다.
- JSON
    - 단순하고 가볍고 브라우저에 최적화
    - XML보다 간결하며, 사실상 표준으로 자리잡음
- XML
    - 구조적이고 하이퍼미디어 컨트롤 등 풍부한 표현 가능
    - 그러나 복잡하고 장황하여 현재는 잘 쓰이지 않음
- Avro (아브로)
    - JSON 기반이지만 스키마(schema)를 포함할 수 있는 포맷
    - 스키마 기반 직렬화를 지원해 구조화된 데이터 교환에 유용

### 5.3.2 바이너리 포맷

- 사람이 읽을 수 없지만, 전송 효율성과 처리 속도가 뛰어나다.
- 페이로드 크기 축소와 낮은 지연 시간이 필요한 환경에서 사용된다.
- 장점
    - 데이터 크기가 작아 네트워크 비용 절감
    - 직렬화/역직렬화 속도 빠름
    - CPU, 메모리 효율 향상

## 5.4 스키마

- 스키마(Schema) 는 데이터의 구조와 타입을 명시적으로 정의하는 규약이다.
- 직렬화 포맷에 따라 사용되는 스키마 기술이 다르다.
    - XML → XSD (XML Schema Definition)
    - JSON → JSON Schema
- 명시적 스키마는
    
    1️⃣ 서비스가 제공·수용하는 데이터 구조를 명확히 표현하고,
    
    2️⃣ 예상치 못한 변경으로 인한 엔드포인트 파손을 조기에 탐지하는 데 도움을 준다.
    

### 5.4.1 구조적 계약 위반 대 의미적 계약 위반

| 구분 | 설명 | 예시 |
| --- | --- | --- |
| **구조적 위반 (Structural Violation)** | 엔드포인트 구조 자체가 바뀌는 경우 | 필드나 메서드 제거, 필드명 변경, 새 필드 추가 |
| **의미적 위반 (Semantic Violation)** | 구조는 같지만 동작이나 의미가 바뀌는 경우 | 특정 필드의 의미나 값 해석 방식이 변경됨 |
- 구조적 위반은 스키마 비교로 탐지 가능 의미적 위반은 테스트로만 검증 가능

### 5.4.2 스키마를 사용해야 할까?

- 스키마를 사용하면 서로 다른 버전 간 구조적 불일치를 자동으로 감지할 수 있다.
- 스키마가 없으면, 이런 검증 책임이 전적으로 테스트 코드에 의존하게 된다.
- 특히 동적 타입 언어(JavaScript, Python 등) 에서는 컴파일러가 잡아주지 못하는 구조 오류를 테스트로 커버해야 한다.
- 명시적 스키마의 중요성
    - 문제는 “스키마를 사용하느냐”보다 “스키마를 명시적으로 정의하느냐” 이다.
    - 마이크로서비스가 **무엇을 노출할지/하지 않을지**를 명확히 하는 것이 중요하다.
    - 명시적 스키마는
        - 구조적 계약을 명확히 하고 팀 간 커뮤니케이션 비용을 줄이며, 안전망(safety net) 으로 작동한다.

## 5.5 마이크로서비스 간의 변경 처리

변화를 처리하는 방법은 실제로 두 가지 주제로 나뉜다.

- 중단 변경이 필요한 경우 어떻게 되는지
- 중단 변경을 피하기 위해 무엇을 할 수 있을지