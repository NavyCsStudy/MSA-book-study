## 1. 목표를 가져라

- msa는 합리적인 의사결정에 기반해야 한다. 현재 아키텍처로 목표를 달성할 수 없는 경우에만 msa로의 마이그레이션을 생각해야 한다.

- 다른 기술들을 먼저 살펴봐라. 로드밸런서 뒤에 모놀리식 시스템을 몇개 더 뛰우는 것이 효과적으로 시스템을 확장하는 방법일 수 있다.

- 현재 달성하려는 변화가 무엇인지 확실히 하라. 만일 msa가 최선이라면 최종 목표에 대한 진행 상황을 추적하고, 필요에 따라 진행 방향을 변경하라.

## 2. 점진적 마이그레이션

> 빅뱅식으로 재작성하면 보장되는 것은 빅뱅뿐이다.
> 마틴 파울러

- msa가 최선이라는 결론에 도달했다면 모놀리식을 조금씩 떼어내는 것이 좋다.
- 점진적 접근방식은 msa를 배우는 데 도움이 될 것이고, 문제가 생겼을 때 영향 범위도 제한될 것이다.
- 작은 곳부터 시작하라. 1, 2개의 기능 영역을 선택하고 마이그레이션 한 다음, 이러한 작업이 최종 목표에 더 가까워지는 데 도움이 됐는지 생각해보라.

## 3. 모놀리스가 적인 경우는 드물다.

- 모놀리식에서 발생하던 문제는 마이크로서비스 전한 후에 해결될 수도 있지만 보통 그대로 유지된다.
- 책에서 들어주는 예로는 부하 처리 개선을 위해 병목 현상이 있는 기능 10%를 제거하고 나머지 90%는 모놀리식 시스템에 남겨둠으로써 충족될 수 있다고 한다.
- 모놀리식과 마이크로서비스의 공존이 어색할 수 있다. 하지만 현실 세계의 아키텍처는 깔끔하지 않다. 시스템 시스템 아키텍처는 요구와 지식의 변화에 따라 진화한다.
- 점진적 마이그레이션은 기존 모놀리식을 조금씩 분해하고 그 과정에서 개선점을 도출할 수 있으며, 언제 중지해야 하는지 알 수 있다.

### 3.1 조급한 분해의 위험성

- 도메인에 대한 이해가 명확하지 않을 때는 마이크로서비스를 생성하는 데 위험이 따른다.

- 시스템을 조기에 마이크로서비스로 분해하면 많은 비용이 든다. 해당 도메인을 처음 접하는 경우에는 더욱 그렇다.

- 여러 측면에서 마이크로서비스로 분해하려는 기존 코드베이스를 보유하는 것이 처음부터 마이크로서비스로 진행하는 것보다 훨씬 쉽다.

## 4. 무엇을 언저 나눌까?

- msa가 좋은 아이디어라고 생각하는 이유를 확실히 파악해야 어떤 마이크로서비스를 먼저 만들지 우선순위를 정할 수 있다.

- 어떤 분해가 실행 가능한지도 고려해야 한다. 기존 모놀리식에 깊이 얽혀있는 기능은 방법을 알 수 없거나, 위험할 수 있다.

- 어떤 기능을 마이크로서비스로 분할할지 결정하는 것은 `추출하는 작업의 용이성`, `추출의 이점` 사이의 균형에 따라 결정될 것이다.

- 저자는 처음 전환할 서비스는 좀 더 쉬운쪽에 가까운 것을 택하라 한다. 이는 전환 초기의 추진력, 빠른 성공에 대한 경험이 될 것이다.

- 반면 쉬워보이던 서비스 전환이 실패했다면 정말로 msa가 적절한지 다시 한 번 재고해봐야 한다.

## 5. 계층별 분해

마이크로서비스와 사용자 인터페이스는 1:1로 매핑되지 않는 경우가 많다. 마이크로서비스와 관련된 ui 기능을 추출하는 것을 별도의 단계로 간주될 수 있다. 보통 마이크로서비스 제공 전에는 ui 분해의 가능성을 확인하기 어려우므로 백엔드 분해보다 뒤쳐지는 경향이 있다.

그럼 백엔드 코드와 관련 스토리지 중에서는 어떤 부분을 먼저 추출해야 하는가?

<img width="620" height="318" alt="image" src="https://github.com/user-attachments/assets/e8d5409d-5c6f-4743-a36c-9c4d289678ef" />

### 5.1 코드 우선

저자의 경험에 따르면 우선 코드를 추출하는 것이 첫 번째 단계인 경우가 많다고 한다. 보다 단기적인 이익을 전달하기 쉽다.

<img width="620" height="315" alt="image" src="https://github.com/user-attachments/assets/7d009903-8f15-4999-ad85-20a7b8e4cc24" />

- 코드 추출이 데이터베이스에서 내용을 추출하는 것보다 쉬운 경향이 있다. 코드 추출을 깔끔하게 할 수 없다면 데이터베이스 분해 전에 작업을 중단할 수 있다.
- 하지만 코드 추출은 성공했으나 데이터 추출이 불가할 수도 있다. 따라서 코드 추출을 결정했다면 데이터 또한 추출이 가능한지, 어떻게 진행할지 아이디어를 가지고 있어야 한다.

### 5.2 데이터 우선

데이터 우선 추출은 흔한 방식은 아니다. 그러나 데이터 분리가 깔끔하게 이루어질지 불확실한 상황에 유용하다.

<img width="623" height="337" alt="image" src="https://github.com/user-attachments/assets/98d643d4-3d33-4d0d-8ecb-a79dccc1b4db" />

## 6. 유용한 분해 패턴

### 6.1 strangler fig pattern

- 마틴 파울러가 만든 개념으로 시간이 지남에 따라 기존 시스템을 새 시스템으로 감싸는 과정을 설명한다.
- 점진적으로 새로운 시스템이 이전 시스템의 기능을 더 많이 차지하게 된다.

- msa에서 해당 기능에 대한 호출이 구현되면 마이크로서비스로 리다이렉션된다. 아직 구현되지 않은 기능은 기존의 모놀리식 서비스에서 처리한다.

<img width="617" height="341" alt="image" src="https://github.com/user-attachments/assets/92104b5f-bb47-4173-8c98-2338a7fae9cc" />

- 장점으로는 모놀리식 애플리케이션을 변경하지 않고 msa로의 전환을 수행할 수 있다는 것이다. 모놀리식 애플리케이션은 새로운 시스템이 자신을 감싸고 있다는 사실을 알지 못한다.

### 6.2 parallel run pattern(병렬 실행)

- 기존 시스템 동작을 위험에 빠뜨리지 않고 신규 기능의 작동을 확인하는 방법은 병렬 실행 패턴을 사용하는 것이다.
- 모놀리식 기능 구현과 새로운 마이크로서비스 구현을 나란히 실행해 같은 요청을 제공하고 결과를 비교한다.

### 6.3 feature toggle pattern(기능 토글)

- 기능을 켜고, 끄면서 제어하는 패턴이다.
- 프록시 레이어에서 기능 토글을 구현하여 모놀리식, 마이크로서비스 구현을 전환하는 제어를 할 수 있다.

## 7. 데이터 분해에 대한 우려

### 7.1 성능

마이크로서비스로 분리하게 되면 더이상 데이터베이스의 조인을 사용할 수 없다. 데이터 계층의 작업은 암만 노력해도 데이터베이스 조인만큼 빠르게 수행할 수는 없다.

<img width="617" height="477" alt="image" src="https://github.com/user-attachments/assets/09d0c49d-12e0-48bc-9c38-e10f6298d07a" />

<img width="620" height="395" alt="image" src="https://github.com/user-attachments/assets/7af1d0cd-2e37-4c44-a46e-a1f6a0da4fd0" />


- 여전히 논리적인 조인을 수행할 수 있지만 데이터베이스가 아닌 서비스 내부에서 수행하게 된다. 이는 데이터베이스의 조인만큼 효율적이지 않다.

- 보고서 생성과 같은 캐싱 가능한 작업이라면 성능 저하가 크지 않을 것이다. 그러나 다양한 조건이 결합되어 만들어지는 조회이거나 빈번한 작업이라면 더 큰 문제가 될 수 있다.

### 7.2 데이터 무결성

- 데이터베이스에서는 외래키 제약 조건을 통해 한 레코드의 외래키에 해당하는 다른 레코드가 항상 존재한다는 것을 보장할 수 있다.
- 그러나 개별 데이터베이스를 사용하는 마이크로서비스에서는 보장할 수 없을 것이다.

### 7.3 트랜잭션

- 분리된 데이터베이스를 사용하면서 모든 상태 변화는 하나의 물리적 트랜잭션 안에서 끝나지 않는다.

- 사가 패턴은 이러한 상황을 해결하기 위한 메커니즘을 제시하지만 복잡하다.

### 7.4 도구

- 데이터베이스 변경은 어려운 작업이다. 이러한 작업을 지원하는 도구는 보통 델타 스크립트를 통해 스키마 변경 사항을 제어한다. 이는 멱등적 방식으로 엄격한 순서에 의해 실행된다.

### 7.5 리포팅 데이터베이스

- 여러 데이터베이스의 데이터를 조합해야하는 경우 리포팅 데이터베이스를 사용할 수 있다.

- 외부 액세스용으로 데이터베이스를 설계하고 각 서비스는 내부 저장소의 데이터를 리포팅 데이터베이스로 전송한다.

<img width="625" height="374" alt="image" src="https://github.com/user-attachments/assets/19e8ba27-bf78-41b4-aa58-57744304db2d" />

여기서 주의해야할 점이 있다.
- 첫째, 정보 은닉은 여전히 중요하다. 따라서 리포팅 데이터베이스에는 필요 최소한의 데이터만 노출해야 한다. 동시에 이러한 특징을 통해 리포팅 데이터베이스는 다른 종류의 데이터베이스 기술을 사용할 수 있을 것이다.
- 둘째, 리포팅 데이터베이스를 다른 마이크로서비스 엔드포인트와 동일하게 취급해야 한다. 마이크로서비스 내부 구현의 세부 정보를 변경하더라도 엔드포인트의 호환성이 유지되도록 해야 한다.
