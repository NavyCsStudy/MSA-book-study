마이크로서비스 아키텍처로의 전환을 살펴보는 데 도움이 되는 팁!

## 3.1 목표를 가져라

- 마이크로서비스는 목표가 아니다.
- 현재 아키텍처로 최종 목표를 달성하는 더 쉬운 방법을 찾을 수 없는 경우에만 마이크로서비스 아키텍처로의 마이그레이션을 생각해야 한다.
- 마이크로서비스를 만드는 데만 집착하게 되면, 새로운 복잡성을 고려할 때 심각한 문제를 겪게 된다.
    - 또한 다른 방법을 생각해내지 못하도록 방해할 가능성도 있다.
- 따라서 달성하려는 변화가 무엇인지 명확히 하고 마이크로서비스를 고려하기 전에 최종 목표를 달성할 더 쉬운 방법을 고려하라.

## 3.2 점진적 마이그레이션

- 모놀리식을 한 번에 조금씩 떼어내는 것이 좋다.
- 마이크로서비스를 적용하게 된다면, 1~2개의 기능 영역을 선택하고 마이크로서비스로 구현해 운영 환경에 배포한 다음, 새 마이크로서비스를 만드는 것이 최종 목표에 더 가까워지는 데 도움이 됐는지 생각해보라.

## 3.3 모놀리스가 적인 경우는 드물다

- 모놀리식 아키텍처는 본질적으로 나쁘지 않기 때문에 적으로 간주하면 안된다.
    - 모놀리스와 마이크로서비스의 공존
- 마이크로서비스로의 마이그레이션을 점진적으로 진행하면 기존의 모놀리식 아키텍처를 조금씩 분해하고 그 과정에서 개선점을 도출할 수 있으며, 중요한 것은 언제 중지해야 하는지 알 수 있게 된다.

### 3.3.1 조급한 분해의 위험성

- 도메인에 대한 이해가 명확하지 않을 때는 마이크로서비스를 생성하는 데 위험이 따른다.
- 마이크로서비스로 분해하려는 기존 코드베이스를 보유하는 것이 처음부터 마이크로서비스로 진행하는 것보다 훨씬 쉽다.

## 3.4 무엇을 먼저 나눌까?

- 애플리케이션을 확장하고 싶은가? → 현재 시스템의 부하 처리 능력을 제한하는 기능이 가장 높은 순위를 차지할 것이다.
- 출시 시간을 단축하고 싶은가? → 시스템의 변동성을 살펴보고 가장 자주 변경되는 기능을 찾아내 마이크로서비스로 작동하는지 확인하라.
- 하지만 어떤 분해가 실행 가능한지 고려해야 한다.
- 마이크로서비스로 ‘추출하는 작업의 용이성’과 ‘추출의 이점’ 사이의 균형에 따라 결정될 것이다.
- 마이크로서비스들은 전체 목표를 달성하는 데 영향을 미칠 수 있는 것으로 선택하되, 쉽게 성취 가능한 것을 선택하는 것이 좋다.
    - 만약 가장 쉬운 마이크로서비스라고 생각되는 것을 추출하는 데 실패했다면, 마이크로서비스가 조직에 적합한지 다시 생각해야 한다.

## 3.5 계층별 분해

<img width="656" height="522" alt="Image" src="https://github.com/user-attachments/assets/0736933d-9cf0-49f2-9334-f66ee3961903" />

### 3.5.1 코드 우선

<img width="943" height="499" alt="Image" src="https://github.com/user-attachments/assets/6ae26d14-f96b-4142-9015-602d1f31fdf0" />

- 위시리스트 기능과 관련된 코드를 새 마이크로서비스로 추출하고, 위시리스트에 대한 데이터는 모놀리식 데이터베이스에 남아 있다.
- 일반적으로 이 작업이 마이크로서비스의 첫 번째 단계인 경우가 많다.
- 데이터베이스에서 내용을 추출하는 것보다 코드를 추출하는 것이 더 쉽다.
- 하지만 코드 분리 작업을 우선 수행하기로 했더라도, 모놀리식 데이터베이스에서 데이터를 추출하는 것이 가능한지, 어떻게 진행할 것인지를 아이디어를 갖고 있어야 한다.
- 따라서 시작하기 전에 코드와 데이터가 모두 추출되는 방법을 스케치하는 작업을 수행해야 한다.

### 3.5.2 데이터 우선

<img width="603" height="533" alt="Image" src="https://github.com/user-attachments/assets/b75a220b-9c96-4a6e-b283-5c0b632730b1" />

- 애플리케이션 코드보다 먼저 데이터가 추출되는 것
- 흔히 볼 수 없지만, 데이터를 깔끔하게 분리 가능한지 여부가 불확실한 상황에서 유용하다.

## 3.6 유용한 분해 패턴

### 3.6.1 교살자 무화과 패턴

<img width="711" height="528" alt="Image" src="https://github.com/user-attachments/assets/4e578a8d-9171-4146-9081-d522b7fa2fc6" />

- 시간이 지남에 따라 기존 시스템을 새 시스템으로 감싸는 과정으로, 새 시스템이 이전 시스템의 기능을 점진적으로 더 많이 차지하게 된다.
- 기존 시스템에 대한 호출을 가로채는 방식으로, 새로운 마이크로서비스에서 구현된 기능이 호출되면 마이크로서비스로 리디렉션된다.
- 장점은 모놀리식 애플리케이션을 변경하지 않고 수행할 수 있다는 것이다.

### 3.6.2 병렬 실행

- 모놀리식 기능 구현과 새로운 마이크로서비스 구현을 나란히 실행해 같은 요청을 제공하고 결과를 비교한다.
- 기존 시스템 동작에 영향을 안 주면서 새로운 기능이 잘 동작하는지 확인할 수 있다.

### 3.6.3 기능 토글

- 기능을 켜거나 끄는 등 기능에 대한 2개의 다른 구현 사이를 오가게 하는 매커니즘이다.

## 3.7 데이터 분해에 대한 우려

데이터베이스를 분리하기 시작하면 여러 문제가 발생한다.

### 3.7.1 성능

<img width="802" height="658" alt="Image" src="https://github.com/user-attachments/assets/f2893765-c083-4bdf-9eae-7ee8092d8020" />

<img width="808" height="551" alt="Image" src="https://github.com/user-attachments/assets/517eb510-5b18-44e2-a025-c826f3105706" />

- 마이크로서비스 아키텍처에서 데이터를 분리한다면 속도가 빨라지기 어렵다.
- 위의 예시에서 카탈로그 마이크로서비스를 호출해 필요한 정보를 요청해야 한다.
    - 카탈로그 마이크로서비스에서는 자신의 데이터베이스에서 SELECT 쿼리를 실행시켜 반환한다.
- 조인 작업은 데이터베이스 계층에서 애플리케이션 코드 계층으로 이동한 것이다.
    - 데이터베이스 조인보다 비효율적
    - SELECT 쿼리 최소 2번
- 이러한 조회를 대량 조회하거나, 필요한 정보를 로컬 캐싱해 완화할 수 있다.

### 3.7.2 데이터 무결성

- 데이터베이스는 외래키와 같은 제약 조건을 활용해 데이터 무결성을 보장하는 데 유용하다.
- 데이터베이스가 분리되면 이러한 엔티티간 관계의 무결성을 적용하기 위해 더 이상 데이터베이스에 의존할 수 없다.
    - 그 대안으로, soft delete

### 3.7.3 트랜잭션

- 데이터베이스 트랜잭션은 ACID 보장
- 대책으로 분산 트랜잭션이 있기는 하나 구현이 복잡하며 ACID가 기대만큼 보장되지는 않는다.
    - 사가 패턴

### 3.7.4 도구

- 데이터베이스 변경은 어려운 작업이다.
- Liquibase, Flyway
    - 관계형 데이터베이스의 스키마 변경 프로세스를 관리하는 도구
    - 각 스키마 변경 사항은 버전 제어되는 델타 스크립트에서 정의
    - 이러한 스크립트는 멱등적 방식으로 엄격한 순서에 의해 실행

### 3.7.5 리포팅 데이터베이스

- 외부 액세스 전용 DB 생성
- 마이크로서비스가 내부 데이터를 푸시→ 내부 상태 관리 은닉 유지하면서 DB에서 데이터 제공 가능
- 정보 은닉 유지
- 리포팅 DB를 다른 마이크로서비스 엔드포인트와 동일 취급
    - 리포팅 DB를 단순히 DB 처럼 취급하는 것이 아닌 하나의 독립된 마이크로서비스로 간주?