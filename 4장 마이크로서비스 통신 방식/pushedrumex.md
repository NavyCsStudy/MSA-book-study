# 4. 마이크로서비스 통신 방식

## 4.1 프로세스 내부에서 프로세스 사이로

### 4.1.1 성능
- 프로세스 간 호출의 오버헤드는 프로세스 내 호출의 오버헤드에 비해 큼
- 네트워크를 통해 MS 간 호출에서는 네트워크를 통해 전송될 수 있는 형태로 직렬화, 수신측에서는 역직렬화 필요
- 프로세스 간의 호출에서는 페이로드 크기도 고려 해야함
- 프로세스 간의 비정상적인 상호작용은 성능에 심각한 영향을 미쳐 병목 현상이 발생할 수 있음

### 4.1.2 인터페이스 변경
- MS 에서는 인터페이스를 노출하는 서비스와 해당 인터페이스를 사용하는 서비스는 개별 서비스
- MS 인터페이스를 변경할 경우, 해당 인터페이스에 의존하는 모든 서비스의 업데이트 필요

### 4.1.3 에러 처리
- 분산 시스템에서는 통제할 수 없는 에러가 많이 존재함
- 실패모드
    - 충돌 실패 : 서버가 멈추면 어떤 응답도 하지 못함
    - 누락 실패 : 다운스트림 서비스의 응답을 받지 못함
    - 타이밍 실패 : 일이 제시간에 발생하지 않음
    - 응답 실패 : 잘못된 응답을 받음
    - 임의 실패 : 서버가 고장났는데, 어떤 노드가 고장 난 건지 확신하지 못하는 상태
- MSA 간의 통신에서 발생하는 에러의 특성을 중심으로 한 의미 체계를 가춘다면, 클라이언트가 조치를 취할 수 있게 되고 더 견고한 시스템을 구축할 수 있음

## 4.2 프로세스 간 통신을 위한 기술 : 다양한 선택
- MSA 간의 통신을 위한 기술을 선택할 때, 필요한 통신 방식 중 적합한 기술을 선택하는 것이 중요함

## 4.3 마이크로서비스 통신 방식
- 동기식 블로킹 : MS 에서 다른 MS 를 호출하고 응답이 올 때까지 기다림
- 비동기식 논블로킹 : 호출을 한 MS 는 응답이 오지 않아도 처리를 계속 할 수 있음
- 요청 및 응답 : MS 는 작업을 수행하도록 다른 MSA로 요청을 보내고 응답을 기다림
- 이벤트 기반 : MS 는 다른 MS 가 소비하는 이벤트를 발행. 이벤트를 발생하는 MS 는 자신이 발행한 이벤트를 소비하는 MSA 가 어떤 서비스인지 알지 못함
- 공통 데이터 : 일부 공유 데이터 소스를 통해 협업

### 4.3.1 짜맞추기
MSA 전체에는 다야한 협업 형태 스타일이 혼재되며, 하나 이상의 협업 형태를 구현하는 것이 일반적

## 4.4 동기식 블로킹
- MS 가 다른 MS 에 요청을 보내고 응답이 수신될 때까지 대기
- 응답을 대기하는 이유는 호출 결과가 이후 로직에 필요하거나 결과에 따라 재시도 등의 작업이 필요하기 때문
- 모든 동기식 블로킹 호출은 `요청 및 응답` 호출로 구성

### 4.4.1 장점
- 간단하고 친숙함

### 4.4.2 단점
- 다운스트림 장애로 인한 연쇄적인 문제에 취약
- 호출한 MS 가 늦게 응답하거나 네트워크 지연이 발생한다면, 응답을 기다리며 오랜 시간 동안 블로킹이 됨

### 4.4.3 적용 대상
- 간단한 MSA 라면 동기식 블로킹 호출은 문제 없음
- 하지만, 호출 체인이 많아질 경우 문제가 되기 시작
    - 호출 체인에 속한 서비스 중 하나라도 문제가 발생하면 전체 작업이 실패할 수 있음
    - 커넥션이 고갈되거나 네트워크 정체가 증가하는 문제가 발생할 수 있음
    - 따라서, 백그라운드로 할 수 있는 작업을 호출 체인에서 제거하여 호출 체인의 길이를 줄여 작업의 지연 시간을 개선해야함

## 4.5 비동기식 논블로킹
- 응답을 기다릴 필요 없이 다른 처리를 계속 할 수 있음
- MSA 에서 사용하는 일반적인 비동기식 논블로킹 방식
    - 공통 데이터를 통한 통신 : 업스트림 서비스가 일부 공통 데이터를 변경하고 다른 서비스에서 해당 데이터를 사용하는 방식 
    - 요청 및 응답 : MS 는 다른 MS에 작업 요청을 보내고, 요청된 작업이 완료되면 성공 여부와 관계 없이 응답을 수신
    - 이벤트 기반 상호작용 : MS 는 이벤트를 발행하고 다른 MS 는 관심 있는 이벤트를 수신하여 대응

### 4.5.1 장점
- 호출을 수행하는 MS 와 호출을 수신하는 MS 가 분리됨
- 호출을 수신하는 서비스가 호출과 동시에 연결될 필요가 없음

### 4.5.2 단점
- 동기식 블로킹 통신 방법에 미해 복잡함

### 4.5.3 적용 대상
- 장기 수행 프로세스일 경우
- 호출 체인이 길 경우

## 4.6 공통 데이터를 통한 통신
- 하나의 MS 가 데이터를 정의한 위치에 넣고 다른 MS 가 해당 데이터를 사용
- 예시) 신제품 수입자, 카탈로그, 재고
    - 신제품 수입자 서비스가 신제품 파일을 생성하고 카탈로그 서비스와 재고 서비스가 해당 파일을 조회

### 4.6.1 구현
- 해당 패턴을 구현하기 위해서는 데이터의 영구 저장소가 필요 ex) 파일 시스템
    - ex) 주기적으로 파일 시스템을 스캔하여 새 파일의 존재를 확인하여 작업 수행
- 분산 메모리 저장소를 사용할 수도 있음
- 구현 예시 1: 데이터 레이크
    - 데이터 생산자는 자신이 적합하다고 생각하는 형식으로 원시 데이터를 업로드, 다운스트림 소비자는 이 데이터를 처리하는 방법을 알아야 함
- 구현 예시 2: 데이터 웨어하우스
    - 구조화된 데이터 저장소를 사용
    - 하위 호환이 불가능한 구조가 된다면, 생산자가 업데이터 되어야 함


### 4.6.2 장점
- 파일이나 데이터베이스를 대상으로 간단하게 구현 가능
- 대용량 데이터를 사용할 수 있음

### 4.6.3 단점
- 다운스트림 소비자는 폴링 메커니즘이나 스케줄링을 통해 신규 데이터가 있음을 체크해야함
- 더 많은 데이터를 전송하고 실시간으로 처리해야한다면 카프카와 같은 스트리밍 기술이 더 적합
- 데이터 저장소의 구조가 변경되면 MS 간의 통신이 중단될 수 있음

### 4.6.4 적용 대상
- 사용한 기술에 제약이 있는 프로세스 사이에서 상호 운용성을 활성화해야하는 경우
- 대용량 데이터를 공유해야하는 경우

## 4.7 요청 및 응답 통신
- MS는 다운 스트림 서비스에 작업을 요청하고 응답을 받음
- 동기식 블로킹 호출과 비동기식 논블로킹 호출로 구현될 수 있음
- 특정 순서로 호출을 완료해야하는 상황에서 사용하는 패턴

### 4.7.1 구현: 동기 대 비동기
- 동기식 호출
    - 다운스트림 서비스와 네트워크 커넥션이 형성되고 이 커넥션을 따라 전송
    - 업스트림 서비스는 응답이 올때까지 대기하며 그 동안 커넥션을 열린 상태로 유지
    - 업스트림 또는 다운스트림 서비스 인스턴스가 종료되어 커넥션이 끊어지면 문제 발생
- 비동기식 호출
    - 업스트림 서비스는 메시지 브로커를 통해 요청 메시지를 큐에 넣고 다운스트림 서비스는 응답 메시지를 다른 큐에 넣음
    - 큐에 여러 요청을 버퍼일 할 수 있고, MS 는 준비가 될 때 다음 요청을 소비할 수 있음
    - 데이터베이스에 요청과 응답의 연결관계를 저장하여 적절히 동작
    - 타임아웃 처리 필요

### 4.7.2 적용 대상
- 요청 결과를 확인해야하는 모든 상황에 적합
- 재시도와 같은 보상 조치를 수행 해야하는 환경에서도 적합

## 4.8 이벤트 기반 통신
- MS 가 다른 MS 에 수신 여부가 보장되지 않은 이벤트를 발행
- 이벤트를 발행하는 MS 는 이벤트를 사용하려는 MS 가 존재한다는 사실 조차 인식하지 못할 수도 있음
- 이벤으 발행자는 무엇을 할지 결정하는 것을 수신자에게 위임

### 4.8.1 구현
- 이벤를 발행하는 방법과 소비자가 이벤트 발생을 알아내는 방법을 구현해야함
- 메시지 브로커
    - 생산자는 API를 사용하여 이벤트를 브로커에 발행
    - 브로커는 구독을 처리해 이벤트가 도착하면 소비자가 알림을 받도록 구현
- HTTP
    - 피드에 이벤트를 게시하고, 소비자들은 피드를 폴링하여 변경 사항을 조회
    - 지연 시간이 발생할 수 있음
    - 소비자가 받은 메시지를 추적하고 자체 폴링 일정도 관리해야함

### 4.8.2 이벤트에 포함되는 것
- 식별자와 같은 데이터만 포함
    이벤트를 수신하는 서비스들은 필요한 정보를 얻기 위해 다른 서비스에 요청을 보내야함
- 많은 정보를 포함
    느슨한 결합이 가능해지고 감사 시스템에 도움을 주거나 특정 시점에 엔티티를 재구성하는 기능을 제공함. 하지만 이벤트 크기가 커진다는 단점이 존재

### 4.8.3 적용 대상
- 다른 요소와 느슨한 결합에 중점을 둬야하는 상황에 적합
- 하지만 이벤트 기반 통신을 사용할 경우 복잡성이 커질 수 있기에, 하나의 이벤트에서 시작해 확장해가는 것을 추천
- 

## 4.9 조심해서 진행하라
이벤트 기반 아키텍처와 비동기식 프로그래밍은 복잡성을 유발하므로 해당 방법을 채택하는데에 신중해야함.

