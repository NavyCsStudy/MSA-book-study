## 4.1 프로세스 내부에서 프로세스 사이로

### 4.1.1 성능

- 프로세스 내 호출은 컴파일러와 런타임이 다양한 최적화를 수행할 수 있지만, 프로세스 간 호출은 이러한 최적화가 불가능하며 패킷 전송 등 네트워크 오버헤드가 발생한다.
- 메서드 호출 시 매개변수를 전달할 때는 메모리 포인터를 직접 넘겨 데이터 복사에 필요한 메모리 할당을 최소화할 수 있다.
    - 반면 마이크로서비스 간 호출은 데이터를 네트워크를 통해 주고받기 때문에, 반드시 직렬화 및 역직렬화 과정을 거쳐야 한다.
    - 따라서 프로세스 간 통신에서는 전송되는 페이로드의 크기에 특히 주의해야 한다.

### 4.1.2 인터페이스 변경

- 마이크로서비스 인터페이스에 하위 호환성을 깨뜨리는 변경을 할 때는 둘 다 새 인터페이스를 사용하도록 업데이트하기 위해 소비자와 함께 락스텝 배포를 하거나, 새로운 마이크로서비스 계약의 출시를 단계적으로 수행할 방법을 찾아야 한다.

### 4.1.3 에러 처리

- 프로세스 내부에서 메서드를 호출하면 에러의 특성은 직관적인 편으로, 예측돼 처리하기 쉽거나 호출 스택의 위 방향으로 전파할 정도로 치명적이며 결정적이다.
- 분산 시스템에서 에러의 특정은 다양하다.
    - 통제할 수 없는 많은 에러
    - e.g. 네트워크 시간 초과, 다운스트림 마이크로서비스 일시적 중단, 네트워크 연결 끊김, 메모리 고갈, 데이터센터 화재
- 프로세스 간 통신에 나타나는 다섯 가지 유형의 실패 모드
    - 충돌 실패: 서버가 중단될 때까지 모든 것은 정상이다. 재부팅한다.
    - 누락 실패: 전송 후 응답을 받지 못했다.
    - 타이밍 실패: 어떤 일이 너무 늦게 발생했거나 너무 일찍 발생했다.
    - 응답 실패: 응답은 받았지만 잘못된 응답으로 보인다.
    - 임의 실패: 무언가 잘못됐지만 참여자들이 실패가 발생한 사실(또는 이유)에 동의하지 못하는 경우다.
- 클라이언트가 적절한 조치를 취할 수 있는 방식으로 에러를 반환하기 위한 더 풍부한 의미 체계를 갖추는 것이 중요하다.
    - 에러의 특성을 중심으로 풍부한 의미 체계를 갖춘다면, 클라이언트가 보상 작업을 수행하기 더 쉬워지고 결과적으로 더 견고한 시스템을 구축할 수 있다.

## 4.2 프로세스 간 통신을 위한 기술: 다양한 선택

## 4.3 마이크로서비스 통신 방식

<img width="922" height="398" alt="Image" src="https://github.com/user-attachments/assets/118926dc-6947-4f80-82a4-b871f60e6f22" />

- 신뢰할 수 있는 통신, 허용 가능한 지연 시간, 통신량에 대한 요구사항은 모두 기술을 선택하는 데 중요한 역할을 한다.
    - 하지만 필자는 주어진 상황에 더 적합한 방식이 ‘요청 및 응답인지’ 아니면 ‘이벤트 기반 협업 방식인지’ 살펴보기 시작한다.
    - 요청 및 응답을 살펴보고 나서 동기 및 비동기 구현 모두가 여전히 가용하다면, 두번째 선택을 해야 한다.
    - 하지만 이벤트 기반 협업 방식을 선택한다면 구현 선택지는 비동기식 논블로킹 방식으로 제한된다.
- 통신 방식 외에도 지연 시간이 짧은 통신의 필요성, 보안 관련 측면, 확장 기능 등 다양한 고려사항이 있다.
- 또한 마이크로서비스가 하나 이상의 협업 형태를 구현하는 것은 일반적이다.

## 4.4 동기식 블로킹

- 동기식 블로킹 호출은 다운스트림 프로세스의 응답을 기다리는 호출이다.
- 대기하는 이유는 호출 결과가 이후 연산에 필요하거나 호출이 제대로 작동했는지 확인하고 그렇지 않다면 재시도 등을 수행하려 하기 때문일 수 있다.

### 4.4.1 장점

- 간단하고 친숙

### 4.4.2 단점

- 고유한 시간적 결합
    - 만약 다른 MSA가 가용하지 않으면 수행할 보상 작업의 종류를 결정해야 한다. → 재시도, 호출 버퍼링, 포기 등
- 일반적으로 응답은 동일한 인바운드 네트워크 연결을 통해 업스트림 마이크로서비스에 전송된다.
    - 따라서 응답을 다시 보내려 할 때 상대 인스턴스가 바로 뒤에 종료됐다면 응답은 손실된다.
    - 여기서 시간적 결합은 단지 두 마이크로서비스 사이에 생기는 것이 아니라 이 마이크로서비스들의 특정 두 인스턴스에 발생한다.
- 호출 발신자가 블로킹돼 있고 다운스트림 마이크로서비스의 응답을 기다리고 있을 때 다운스트림 마이크로서비스가 늦게 응답하거나 혹은 네트워크 지연 이슈가 있다면 호출 발신자는 응답을 디라기며 오랜 시간 동안 블로킹될 것이다.
    - 만약 해당 서비스가 상당한 부하를 받고 있고 요청에 늦게 응답하는 경우라면 전체 서비스가 느려진다.
- 따라서 동기식 호출을 사용하면 비동기식 호출을 사용할 때보다 시스템이 다운스트림 장애로 인한 연쇄적인 문제에 더욱 취약해진다.

### 4.4.3 적용 대상

<img width="803" height="422" alt="Image" src="https://github.com/user-attachments/assets/2df79bc7-73e8-4b0a-a5bb-541a67538a7f" />

- 위의 문제는 호출 체인이 더 많아질 때 문제가 되기 시작한다.
- 긴 체인이 상당한 리소스 경합을 일으킬 수도 있다.
    - 4개의 MSA 중 하나 또는 이들 간의 네트워크 호출에 문제가 발생하면 전체 작업이 실패할 수 있다.
    - 응답을 기다리기 위해 커넥션을 계속 열어두고 있는데, 사용 가능한 커넥션이 부족해져 네트워크 정체가 증가하는 문제가 발생할 가능성도 있다.
- 개선을 위해 이상거래 감지 기능을 들어내 백그라운드에서 실행하도록 할 수 있다.
    - 작업의 일부를 병렬로 수행하고 호출 체인의 길이를 줄여 작업의 전반적인 지연 시간을 개선한다.

<img width="930" height="530" alt="Image" src="https://github.com/user-attachments/assets/36a3b5a9-33c0-4e38-b1ab-99343e96ea7c" />

## 4.5 비동기식 논블로킹

- 비동기식 통신을 사용하면, 네트워크를 통해 호출을 보내는 행위가 호출하는 MSA를 블로킹하지 않는다.
- 응답을 기다릴 필요 없이 다른 처리를 계속할 수 있다.

### 4.5.1 장점

- 초기 호출을 수행하는 MSA와 호출을 수신하는 MSA는 일시적으로 분리된다.
    - 연결될 필요 X
    - 이러한 통신 방식은 호출에 의해 트리거되는 기능을 처리하는 데 오랜 시간이 걸리는 경우 유용하다.
- callback을 통해 호출 MSA에 진행 상황을 알리는 것이 적절하다.

### 4.5.2 단점

- 복잡도
- 선택 가능한 비동기 통신이 다양하다.

### 4.5.3 적용 대상

- 장기 수행 프로세스
- 재구성하기가 쉽지 않은 긴 호출 체인

## 4.6 공통 데이터를 통한 통신

<img width="793" height="442" alt="Image" src="https://github.com/user-attachments/assets/b84b888f-ace6-46e7-95d2-5e8c91de5b7b" />

- 하나의 MSA가 데이터를 정의한 위치에 넣고 다른 MSA가 그 데이터를 이용할 때 사용된다.

### 4.6.1 구현

- 이 패턴을 구현하려면 영구 저장소가 필요하며, 대개는 파일 시스템으로 충분하다.
- 필자는 주기적으로 파일 시스템을 스캔해 새 파일의 존재를 확인하고 그에 따라 적절히 반응하는 많은 시스템을 구축했다. → 폴링 방식
- 이 패턴의 일반적인 예는 데이터 레이크와 데이터 웨어하우스가 있다.
    - 데이터 레이크를 사용하면 소스는 자신이 적합하다고 생각하는 형식으로 원시 데이터를 업로드하고, 이 원시 데이터의 다운스트림 소비자는 이 정보를 처리하는 방법을 알고 있어야 한다.
    - 즉, 구조가 하위 호환이 불가능한 방식으로 변경되면 생산자가 업데이트돼야 한다.

### 4.6.2 장점

- 매우 간단하게 구현 가능
- 한 번에 많은 데이터를 전송하는 경우 효과적

### 4.6.3 단점

- 폴링 메커니즘이나 주기적인 트리거로 인해 신규 데이터가 있음을 인식한다.
    - 대기 시간이 짧은 상황에서는 유용하지 못할 수 있다는 의미
- 물론 이 패턴은 다운스트림 MSA에 새 데이터가 사용 가능하다는 사실을 알리는 다른 종류의 호출과 결합할 수 있다.
- 일반적으로 아주 많은 양의 데이터에 대해 이 패턴을 사용하면 요구 사항 목록에서 짧은 지연 시간이 우선순위가 높을 가능성은 적다.
- 더 많은 양의 데이터를 전송하고 ‘실시간’으로 더 많이 처리하는 데 관심이 있다면 카프카와 같은 스트리밍 기술이 더 적합하다.
- 공통 데이터 저장소가 잠재적으로 결합의 원천이 된다는 것 또한 큰 단점
    - 해당 데이터 저장소의 구조가 변경되면 MSA 서비스 간 통신이 중단될 수 있다.

### 4.6.4 적용 대상

- 사용 가능한 기술에 제약이 있는 프로세스 사이에서 상호 운용성을 활성화할 때

## 4.7 요청 및 응답 통신

- 동기싱 블로킹 호출 / 비동기식 논블로킹 방식
- 일반적인 사용 사례
- 가끔은 작업이 완료됐는지 확인해야 한다.
- 특정 순서로 호출을 완료해야 하는 상황에서는 요청 및 응답 호출을 사용하는 것이 일반적

### 4.7.1 구현: 동기 대 비동기

- 동기식 호출을 사용하면 일반적으로 다운스트림 MSA와 네트워크 커넥션이 생성되며 이 커넥션을 따라 전송된다.
    - 업스트림 MSA가 응답할 때까지 대기하는 동안 커넥션은 열린 상태로 유지된다.
    - 대신 해당 커넥션이 끊어지면 문제가 발생할 수 있다.
- 비동기식에서 메시지 브로커를 사용한다면 MSA 서비스로 바로 이동하는 대신에 큐에 보관한다.
    - 비동기식 논블로킹으로 상호작용할 때 요청을 수신하는 MSA는 응답을 어디로 라우팅하는지 알고 있어야 한다.
    - 큐를 사용할 때 여러 요청을 버퍼링할 수 있다는 추가적인 이점이 있으며, 요청을 빠르게 처리하지 못하는 상황에서 도움이 된다.
- MSA가 이와 같은 방식으로 응답을 수신하면 원래 요청과 응답을 연결 지어야 할 때가 있다.
    - 어려운 일
    - 이를 쉽게 처리하는 방법은 원래 요청과 관련된 모든 상태를 데이터베이스에 저장하고 응답이 올 때 수신한 인스턴스가 관련된 상태를 다시 로드해서 적절히 동작을 수행할 수 있게 하는 것이다.
- 타임아웃 처리도 필요하다.

### 4.7.2 적용 대상

- 요청 및 응답 호출은 추가 처리가 일어나기 전에 요청 결과를 확인해야 하는 모든 상황에 적합하다.
- 호출이 되지 않아서 재시도와 같은 보상 조치를 수행 가능한 마이크로서비스 환경에서도 매우 적합하다.

## 4.8 이벤트 기반 통신

- 마이크로서비스가 다른 마이크로서비스에 작업을 요청하는 대신에 마이크로서비스가 다른 마이크로서비스에 수신 여부가 보장되지 않는 이벤트를 발행한다.
- 이벤트 리스너가 자체 실행 스레드에서 실행되기 때문에 본질적으로 비동기식 상호작용
- 이벤트는 발생한 일에 대한 진술
- 이벤트를 발행하는 마이크로서비스는 이벤트를 사용하려는 다른 마이크로서비스가 존재한다는 사실조차 인식하지 못할 수 있다. → 이벤트를 브로드캐스트할 뿐
- 이벤트 발행자는 무엇을 할 지 결정하는 것을 수신자에게 맡기고 있다.
    - 결합이 크게 줄어든다.

### 4.8.1 구현

- 마이크로서비스가 이벤트를 발행하는 방법과 소비자가 해당 이벤트 발생을 알아내는 방법
- 래빗엠큐와 같은 메시지 브로커는 두 문제를 모두 처리하려고 한다.
    - 생산자는 API를 사용해 이벤트를 브로커에 발행한다. 브로커는 구독을 처리해 이벤트가 도착하면 소비자가 알림을 받을 수 있도록 한다.
    - 이러한 브로커는 이전에 본 메시지를 추적하도록 도와서 소비자의 상태를 처리하는 등 확장성과 가용성 등을 제공하도록 다양한 기능을 제공하고 있다.
    - 이는 개발 과정에서 복잡성을 가증시킨다. 추가적인 머신과 전문 지식이 필요할 수 있다.
- 메시지 브로커는 미들웨어의 일부에 불과
    - 미들웨어는 멍청하게, 엔드포인트는 똑똑하게 유지해야 한다.
- 또 다른 접근 방식은 이벤트를 전파하는 방법으로 HTTP를 사용하는 것이다.
- 아톰은 리소스 피드를 게시하기 위한 시맨틱을 정의하는 REST 호환 명세다.
    - 고객 서비스가 변경될 때마다 고객 서비스는 피드에 이벤트를 바로 게시할 수 있으며, 소비자들은 단순히 피드를 폴링해 변경 사항을 찾는다.
    - HTTP를 사용하면 지연 시간 측면에서 나쁘며, 소비자가 자신이 받은 메시지를 추적하고 자체 폴링 일정을 관리해야 한다는 사실도 여전히 처리해야 한다.
- 우수하고 탄력적인 사용 간으한 메시지 브로커가 이미 있다면, 이를 재사용
    - 아직 없다면 아톰을 살펴보길 바란다.

### 4.8.2 이벤트에 포함되는 것

- 요청 방식에서는 마이크로서비스에 무언가를 요청하고 요청된 작업을 수행하는 데 필요한 정보를 제공한다.
- 이벤트 방식에서는 다른 당사자들이 관심을 가질 만한 사실을 브로드캐스트한다.
- 하지만 마이크로서비스는 누가 이벤트를 받는지 알 수 없고 알아서도 안된다.

**딱 ID만**

- 이벤트에 새로 등록된 고객의 식별자만 포함
- 이 경우 추가 정보를 위해 정보를 얻기 위한 호출을 해야 할 수도 있다.

<img width="925" height="491" alt="Image" src="https://github.com/user-attachments/assets/8d09138a-aa01-4e1a-9fcd-1306c5d9baf4" />

- 단점
    - 추가적인 도메인 결합
    - 수신 마이크로서비스가 많은 상황에서는 결과적으로 요청이 폭주할 수 있다.

**매우 자세한 이벤트**

- 필자가 선호하는 대안은 API를 통해 공유하는 모든 것을 이벤트에 삽입하는 방식
- 통지 서비스는 이제 자립적이며 고객 마이크로서비스와 통신하지 않고도 작업을 수행할 수 있다.
- 더 많은 정보가 포함된 이벤트가 더 느슨한 결합을 가능하게 한다.
    - 또한 해당 엔티티에 발생한 일에 대한 기록을 더 많이 할 수 있고, 감사 시스템에 도움을 주거나 특정 시점에 엔티티를 재구성하는 기능을 제공한다 → 이벤트 소싱
- 단점
    - 이벤트 크기
    - 불필요한 정보 수신
        - 민감 데이터라면 주의 필요
        - 해결책: 두 가지 유형의 이벤트 발행 → 복잡성
    - 데이터를 이벤트에 포함한다는 것은 외부 세계와 계약의 한 부분
        - 이벤트에서 필드를 제거하면 외부 당사자가 중단될 수도 있다는 것을 알아야 한다.
- 필자의 일반적 규칙은 요청 및 응답 API를 통해 동일한 데이터를 공유할 수 있다면 이벤트에 정보를 넣어도 괜찮다는 것이다.

### 4.8.3 적용 대상

- 정보를 브로드캐스팅하길 원하는 상황과 의도를 뒤집는 상황에서 효과가 있다.
    - 다른 일을 지시하는 모델에서 벗어나 다운스트림 마이크로서비스가 스스로 작업하게 만드는 것

## 4.9 조심해서 진행하라

- 이벤트 기반 아키텍처는 훨씬 더 분리되고 확장 가능한 시스템이 될 것으로 보이며, 실제로 그럴 수 있다.
    - 따라서 복잡성이 증가한다.
- 또한 고려해야 할 것들도 많다.
    - 장기 수행되는 비동기식 응답 및 요청 방식을 고려한다면, 응답이 반환될 때 무엇을 할지 생각해야 한다.
    - 요청을 시작한 동일 노드로 되돌아오는가? 노드가 다운되면? 복구 방법? 등등
- 적절한 모니터링이 존재하는지 확인하고, 프로세스 경계를 거쳐 요청을 추적하게 해주는 상관관계 ID 사용을 적극 고려해보길 바란다.