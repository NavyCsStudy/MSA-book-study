## 1. 프로세스 내부에서 프로세스 사이로

프로세스 내부 호출과 프로세스 간 호출은 매우 다르다.

### 1.1 성능

- 프로세스 간 호출에서는 컴파일러가 처리해주는 최적화가 불가능하며, 패킷을 전송해야 한다.
- 프로세스 내부 api는 걱정 없이 1000번의 호출을 할 수 있지만, 마이크로서비스 사이에서 1000번의 호출은 어떠할까?
- 프로세스 간 호출에서 dto는 네트워크를 통해 직렬화 -> 전송 -> 역직렬화의 과정을 거친다. 

### 1.2 인터페이스 변경

- 프로세스 내부 인터페이스 변경은 하나의 프로세스에 함께 패키징된다.
- 하지만 마이크로서비스는 하위 호환성을 깨뜨리는 변경을 할 때 소비자 서비스도 함께 배포해야 한다.
- 이를 위해 락스텝 배포(lockstep deployment, 복수의 서비스를 ci/cd로 동시에 배포하는 것)를 하거나, 새로운 마이크로서비스 계약의 출시를 단계적으로 수행할 방법을 찾아야 한다.

### 1.3 에러 처리

- 프로세스 내부에서 발생한 에러는 쉽게 예측할 수 있으며, 호출 스택의 위 방향으로 전파한다.
- 분산 시스템에서는 네트워크 시간이 초과하거나, 다른 서비스를 일시적으로 사용하지 못할 수도 있다. 분산 시스템(마틴 스틴 저)에서는 프로세스 간 통신에서 나타나는 다섯 가지 유형의 실패 모드를 다음과 같이 분류했다.

#### 충돌 실패(crash failure)
- 서버가 중단될 때까지 모든 것은 정상이다.

#### 누락 실패(omission failure)
- 전송 후 응답을 받지 못했다.
- 또는 하류 서비스가 메세지를 발행할 것으로 예상했으나 그냥 중지한 상황도 포함한다.

#### 타이밍 실패(timing failure)
- 어떤 일이 너무 늦게 발생하여 제시간에 처리하지 못했다.
- 또는 너무 일찍 발생했다.

#### 응답 실패(response failure)
- 응답은 받았지만 잘못된 응답으로 보인다.
- 주문 요약을 요청했지만 필요한 정보가 응답에 누락됐다.

#### 임의 실패(arbitary failure, 비잔티움 실패)
- 무언가 잘못됐지만 참여자들이 실패가 발생한 사실(또는 이유)에 동의하지 못하는 경우다.

대부분은 일시적인 경우가 많으며 곧 사라질 수 있는 단기간의 문제다. 재전송으로 해결할 수도 있다. 어떤 문제는 쉽게 처리하지 못해 사람이 개입해야할 수 있다. 때문에 클라이언트가 적절한 조치를 취할 수 있는 방식으로 에러를 반환하기 위한 더 풍부한 의미 체계(semantics)를 갖추는 것이 중요해진다.

## 2. 프로세스 간 통신을 위한 기술: 다양한 선택

> 그리고 선택의 폭이 너무 넓고 시간이 너무 부족한 세상에서 해야 할 당연한 일은 그냥 무시하는 것이다.
> 세스 고딘

프로세스 간 통신에 사용하는 기술의 범위는 방대하다.

어떤 기술을 골라야할지 모르겠다면, 먼저 원하는 통신 방식을 이야기하고 나서 해당 방식을 구현하는 데 적합한 기술을 찾는 것이 중요하다. 

## 3. 마이크로서비스 통신 방식

<img width="737" height="304" alt="image" src="https://github.com/user-attachments/assets/6b74ba05-ef46-4e93-bd64-3b567c047508" />

#### 동기식 블로킹(synchronus blocking)
- 마이크로서비스는 다른 마이크로서비스를 호출하고 응답을 기다리는 작업을 차단한다.

#### 비동기식 논블로킹(asynchronus nonblocking)
- 호출을 보낸 마이크로서비스는 호출 수신 여부에 관계없이 처리를 계속할 수 있다.

#### 요청 및 응답(request-response)
- 마이크로서비스는 작업을 수행하도록 다른 마이크로서비스에 요청을 보낸다. 결과를 알려주는 응답을 받을 것을 기대한다.

#### 이벤트 기반(event-driven)
- 마이크로서비스는 다른 마이크로서비스가 소비하고 반응하는 이벤트를 발행한다.
- 이벤트를 발행자는 소비자의 존재를 알지 못한다.

#### 공통 데이터(common data)
- 일부 공유 데이터 소스를 통해 협업한다.

신뢰할 수 있는 통신, 허용 가능한 지연 시간, 통신량에 대한 요구 사항은 모두 기술을 선택하는 데 중요한 역할을 한다.

요청 및 응답을 살펴보고 동기, 비동기 모두 구현 가능하다면 적절한 선택지를 고르면 된다. 그러나 이벤트 기반을 선택한다면 비동기식 논블로킹으로 선택지가 제한된다.

올바른 기술을 선택할 때는 통신 방식 외에도 지연 시간이 짧은 통신, 보안, 확장 기능 등 다양한 고려 사항이 있다. 특정 문제의 요구 사항, 제약 조건을 고려하지 않고 합리적인 기술을 선택할 가능성은 매우 낮다.

### 3.1 짜맞추기

msa 전체에 다양한 협업 스타일이 혼재될 수 있으며, 이는 일반적인 일이다. 어디는 요청 및 응답으로, 어디는 이벤트 중심으로 이루어질 수 있다.

## 4. 동기식 블로킹

마이크로서비스는 다른 서비스에 호출을 보내고 응답이 수신될 때까지 대기한다.

<img width="740" height="144" alt="image" src="https://github.com/user-attachments/assets/5d4aa43d-8d53-4899-b014-2e6f892a3ccd" />

- 동기식 블로킹 호출은 하류 프로세스의 응답을 기다리는 호출이다.
- 대기의 이유는 호출 결과가 이후 연산에 필요하거나, 호출이 제대로 작동했는지 확인한 후 재시도 등을 수행하기 위함일 수 있다.

### 4.1 장점

- 친숙하다.
- 프로세스 간 호출을 사용했던 대부분의 상황에서는 동기식 블로킹 방식을 사용해왔을 것이다.
- 모놀리스에서 msa로 전환할 때 새로운 일이 벌어진다면 익숙한 아이디어를 고수하는 것이 합리적이다.

### 4.2 단점

- 시간적 결합이 생긴다.
- 만약 필요한 서비스가 가용한 상태가 아니라면 수행할 보상 작업의 종류를 결정해야 한다. 여기에는 즉각적인 재시도, 나중에 재시도하기 위한 호출 버퍼링 또는 아예 포기하는 것이 포함될 수 있다.
- 이 결합은 양방향이다. 일반적으로 응답은 동일한 인바운드 네트워크 연결을 통해 전송되는데 만일 요청한 서비스의 인스턴스가 종료되었다면 응답은 손실된다.
- 응답이 지연되면 호출자는 오랜 시간 블로킹된 상태에 머무른다.
- 동기식 호출은 시스템이 다운스트림 장애로 인한 연쇄적인 문제에 더욱 취약해진다.

### 4.3 적용 대상

- 이러한 호출 유형은 호출 체인이 많아질 때 문제가 된다.

<img width="747" height="296" alt="image" src="https://github.com/user-attachments/assets/941125c1-4325-4577-b440-521b1f76e589" />

호출 체인 중 하나라도 문제가 발생하면 전체 작업이 실패할 수 있다. 또한, 그림에서 가장 상류 서비스는 다른 서비스의 응답을 기다리며 네트워크 커넥션을 열어두고 있다. 열린 커넥션이 많으면 실행 중인 시스템에 영향을 줄 수 있다.

이러한 상황을 개선하려면 서비스간의 상호작용을 재검토해야 한다. 모든 작업이 즉시 수행될 필요는 없다. 검토를 통해 일부 작업은 백그라운드로 옮기고 기존의 작업과 병렬로 수행한다. 이러면 호출 체인의 길이가 줄어들어 전반적인 지연 시간을 개선할 수 있다.

<img width="737" height="346" alt="image" src="https://github.com/user-attachments/assets/04b1eb4e-12a2-4485-8f7b-fdb4d68d6ba0" />

## 5. 비동기식 논블로킹

비동기식 통신에서는 네트워크를 통해 호출을 보내는 행위가 서비스를 블로킹하지 않는다. 서비스는 응답을 기다리지 않고 다른 일을 수행할 수 있다.

#### 공통 데이터를 통한 통신

- 상류 서비스는 일부 공통 데이터를 변경하고 이는 나중에 다른 서비스에서 사용한다.

#### 요청 및 응답

- 서비스는 다른 서비스에 작업 요청을 보낸다. 작업이 완료되면 성공 여부와 관계없이 상류 서비스는 응답을 수신한다. 이때, 상류 서비스의 어떤 인스턴스라도 응답을 처리할 수 있어야 한다.

#### 이벤트 기반 상호작용

- 서비스는 이벤트를 발행한다. 다른 서비스는 관심 있는 이벤트를 수신하고 대응한다.

### 5.1 장점

- 비동기식 논블로킹에서 초기 호출을 수행하는 서비스와 수신하는 서비스는 일시적으로 분리된다. 서비스는 호출과 동시에 연결될 필요가 없으며 시간적 결합을 회피할 수 있다.

<img width="747" height="346" alt="image" src="https://github.com/user-attachments/assets/50a38b62-7d19-4468-9601-905b4362fa57" />

이는 호출에 의해 트리거된 기능을 처리하는 데 시간이 오래 걸릴 때 유용하다. 상류 서비스는 비동기식 논블로킹 호출을 하고 이후 하류 서비스가 콜백(callback)을 통해 상류 서비스에 진행 상황을 앙리는 식으로 해결할 수 있다.

### 5.2 단점

- 동기식 블로킹이 친숙하다는 데 비해 비동기식 논블로킹은 복잡도와 선택 범위에서 고민해야 한다. 수많은 방식중에서 우리에게 적합한 방식을 찾아야 한다.

### 5.3 적용 대상

- 각 유형마다 장단점이 있기 때문에 어떤 유형을 선택할지 고려해야 한다. 

## 6. 공통 데이터를 통한 통신

하나의 서비스가 데이터를 정의한 위치에 넣고 다른 서비스는 그 데이터를 사용한다. 이러한 통합 방식은 기본적으로 비동기식이다.

<img width="749" height="341" alt="image" src="https://github.com/user-attachments/assets/101fdd52-0265-412c-9fdc-a34e827b5c3e" />

가장 흔한 프로세스 간 통신 패턴이지만, 이러한 통신이 간접적이어서 통신 패턴으로 인지하지 못할 수 있다.

### 6.1 구현

- 이를 구현하려면 영구 저장소가 필요하며, 대개는 파일 시스템으로 충분하다.
- 서비스는 이러한 데이터를 사용 가능하다고 인식하는 메커니즘이 필요하다. 폴링(polling)은 이에 대한 가장 일반적인 해결책이다.

이 패턴의 일반적인 예는 데이터 레이크(data lake)와 데이터 웨어하우스(data warehouse)이다. 
데이터 레이크를 사용하면 소스는 자신이 적합하다고 생가갛는 형식으로 원시 데이터를 업로드한다. 데이터 소비자는 이 정보를 처리하는 방법을 알고 있어야 한다.
데이터 웨어하우스에서 웨어하우스는 구조화된 데이터 저장소이다. 즉, 구조가 하위 호완이 불가능한 방식으로 변경되면 생산자가 업데이트되어야 한다.

둘 모두 정보의 흐름은 한 방향이라고 가정한다. 하나의 서비스는 공통 데이터 저장소에 데이터를 추가하고, 다른 서비스는 이러한 데이터를 읽어 적절한 작업을 수행한다. 문제는 여러 서비스가 동일한 데이터 저장소를 읽고 쓰는 공유 데이터베이스를 쓸 때 발생한다.

<img width="734" height="399" alt="image" src="https://github.com/user-attachments/assets/16be9745-c225-4a39-9bfe-234cdf2374dc" />

### 6.2 장점

- 간단하게 구현할 수 있다. 파일이나 데이터베이스를 대상으로 읽고 쓴다면 유용한 패턴이다.
- 전송할 데이터양도 문제가 되지 않으므로 한 번에 많은 데이터를 전송한다면 이 패턴이 효과적이다.

### 6.3 단점

- 신규 데이터가 존재한다고 해도 다음 폴링 주기가 돌아오기 전까지는 처리되지 않는다.
- 이러한 문제는 상류 서비스가 하류 서비스를 호출하여 신규 데이터가 있음을 알리는 방식으로 해결할 수 있다.
- 만일 더 많은 양의 데이터가 실시간으로 처리하는 것을 원한다면 카프카와 같은 기술이 적합할 것이다.
- 결합의 관점에서 보면 공통 데이터 저장소는 결합의 원천이 될 수 있다. 만일 데이터 저장소 구조가 변경된다면 서비스 간 통신이 중단될 수 있다.
- 통신의 견고성은 기본 데이터 저장소의 견고성에 따라 결정된다는 특성을 알아둬야 한다.

### 6.4 적용 대상

- 이 패턴이 빛을 발하는 순간은 사용 가능한 기술에 제약이 있는 프로세스 사이에서 상호 운용성을 활성화할 때다. 지원 가능한 기술에 제한이 있는 구형 시스템은 카프카를 도입하기 어려울지도 모른다. 하지만 파일 시스템은 구현 시스템이라도 얼마든지 지원할 수 있다. 
- 대용량 데이터를 공유할 수 있다는 점도 이 패턴의 장점이다. 수 기가바이트 파일을 파일 시스템으로 보내거나 데이터베이스에 수백만 개의 행을 로드해야 한다면 이 패턴이 적합하다.

## 7. 요청 및 응답 통신

서비스는 하류 서비스에 요청을 보내고 응답을 기다린다. 이러한 상호작용은 동기식 블로킹 또는 비동기식 논블로킹 방식으로 구현할 수 있다.

<img width="744" height="178" alt="image" src="https://github.com/user-attachments/assets/48eb3935-d4d7-4192-b282-8103f8b956c6" />

특정한 순서의 프로세스가 필요할 때도 이와 같은 패턴은 빈번하게 사용된다.

<img width="741" height="388" alt="image" src="https://github.com/user-attachments/assets/89e8d90f-49b9-48e0-81fa-1c16d148a251" />

### 7.1 구현: 동기 대 비동기

- 동기식 호출은 일반적으로 하류 서비스와 네트워크 커넥션이 생성되며 이 커넥션을 따라 전송된다. 하류 서비스가 응답할 때까지 대기하는 동안 커넥션은 열린 상태로 유지된다. 
- 이때, 하류 서비스는 상류 서비스가 어떤 서비스인지 알 필요가 없다. 단지 열려 있는 커넥션을 통해 응답을 보낼 뿐이다. 따라서 둘 중 하나의 인스턴스가 종료되어 커넥션이 끊기면 문제가 발생할 수 있다.

비동기식 호출의 일반적인 예는 큐를 통한 메세지 전송이다. 메세지는 하류 서비스로 바로 이동하는 대신 큐에 보관된다. 하류 서비스는 가용한 상황에서 이 큐의 메세지를 사용한다. 하류 서비스의 작업이 완료되면 상류 서비스가 사용하는 다른 큐를 통해 응답을 보낸다.

<img width="742" height="455" alt="image" src="https://github.com/user-attachments/assets/98b3d78f-fecc-443b-ae5f-90e0d6927e01" />

따라서 비동기식 논블로킹으로 상호작용할 때는 요청을 수신하는 서비스가 응답을 어디로 보내야하는지 알고 있어야 한다. 큐를 사용하면 처리 대기 중인 큐에 여러 요청을 버퍼링하거나 처리 속도가 빠르지 못한 상황에서 도움이 된다.

이 같은 방식에서 응답을 받은 서비스는 원래 요청과 연결을 짓는 방법을 알아야 할 때가 있다. '재고 예약됨' 응답과 해당 주문을 연결하는 방법을 알아야 주문을 계속 처리할 수 있다. 이를 쉽게 처리하는 방법은 원래 요청과 관련된 모든 상태를 데이터베이스에 저장하고 응답이 올 때 수신한 인스턴스가 관련된 상태를 다시 로드해서 적절히 동작할 수 있게 하는 것이다.

마지막으로, 요청 및 응답의 상호작용 형태에서 끝나지 않는 작업을 기다리며 블로킹되는 문제를 피하기 위해서는 일종의 타임아웃 처리가 필요하다. 이는 필수적이다.

### 7.2 적용 대상

- 이 패턴은 추가 처리가 일어나기 전에 요청 결과를 확인해야 하는 모든 상황에 적합하다.
- 호출이 실패하여 재시도 같은 보상 조치를 수행해야 하는 환경에서도 매우 적합하다.
- 유일한 문제는 동일한 장단점이 있을 때, 동기식 구현과 비동기식 구현 중 어느 것을 선택할지 결정하는 것이다.

## 4.8 이벤트 기반 통신

다른 서비스에게 작업을 요청하는 대신 수신 여부가 보장되지 않는 이벤트를 발행한다. 이 방식은 이벤트 리스너가 별도의 스레드에서 실행되기 떄문에 본질적으로 비동기식 상호작용이다.

이벤트는 과거에 벌어진 어떠한 사건을 의미한다. 이벤트의 발행자는 다른 서비스가 존재한다는 사실을 모를 수도 있다. 그저 사건의 발생에 따라 이벤트를 발행하면 책임을 다 한 것이다.

<img width="750" height="391" alt="image" src="https://github.com/user-attachments/assets/ee2ab25a-33da-43a3-97b3-16902f02fd46" />

요청 및 응답 구조에서는 요청을 보내야하는 서비스를 알고 있어야 했다. 이벤트 기반에서는 반대다. 이벤트의 소비자가 자신이 필요한 이벤트를 알아야 하는 책임을 가진다.

요청 및 응답 구조에서는 요청자가 다음에 일어나야 하는 일이 무엇인지 알아야 한다. 이는 도메인 결합이 발생함을 나타낸다. 반면, 이벤트 기반 구조에서는 다른 서비스가 무엇을 하는지, 존재는 하는지도 알 필요가 없다. 결과적으로 결합은 크게 줄어든다.

> 이벤트와 메세지
> 이벤트는 과거에 벌어진 사건을 의미한다. 어떠한 일이 벌어졌는지 알 수 있는 최소한의 정보를 내부에 담는다.
> 메세지는 메시지 브로커와 같은 비동기 통신 메커니즘을 통해 전송되는 것을 의미한다.
> 즉, 메세지는 전달 매체이며 이벤트는 페이로드이다. 이벤트 기반 협업 방식에서는 메세지에 이벤트를 담아서 브로드캐스트한다. 만약 메세지의 페이로드에 이벤트가 아니라 요청이 담기면 무엇이 되는 것인가? 이 경우 비동기 요청 및 응답 형식을 구현하는 것이다.

### 8.1 구현

구현에서 고려해야 하는 것은 이벤트를 발행하는 방법과 소비자가 이벤트를 알아내는 방법이다.

우수한 메세지 브로커가 있다면 이를 사용하는 것이 좋다. 전통적으로는 rabbitMQ와 같은 메세지 브로커를 이용할 수 있다.

### 8.2 이벤트에 포함되는 것

<img width="741" height="306" alt="image" src="https://github.com/user-attachments/assets/b9eee3aa-faad-4fd8-9859-a2339ff87ef3" />

이벤트에는 어떤 것이 포함되어야 하는가?

#### 딱 ID만

어떤 소비자는 식별자만으로 필요한 일을 처리할 수 있다. 반면, 식별자만으로 작업을 수행할 수 없는 서비스의 경우 이벤트 발행자에게 필요한 정보를 추가로 요청해야 한다.

<img width="749" height="352" alt="image" src="https://github.com/user-attachments/assets/d131d6ed-27d2-4472-aef3-4f422a29e83f" />

이 때의 단점은 다음과 같다.
- 첫째, 소비자 서비스는 발행자 서비스에 대해 알아야 하며 추가적인 도메인 결합이 생긴다. 
- 둘째, 추가적인 정보를 많은 소비자가 필요로 한다면 이벤트 발행자에 대한 요청이 폭주할 수 있다.

#### 매우 자세한 이벤트

대안은 api를 통해 공유하는 모든 것을 이벤트에 삽입하는 방식이다. 다른 서비스는 이벤트 발행자에게 추가 요청을 보낼 필요가 없을 것이다.

<img width="736" height="386" alt="image" src="https://github.com/user-attachments/assets/d2bfbde2-d91e-472d-a3d2-b8363a90fd25" />

이는 느슨한 결합을 가능하게 한다. 감사 시스템에 도움을 주거나 특정 시점에 엔티티를 재구성하는 것도 가능하다.

이 방식은 저자가 선호하는 방식이지만 다음과 같은 단점이 존재한다.
- 첫째, 이벤트의 크기가 커질 수 있다. 카프카 메세지의 최대 크기는 1mb, rabbitMQ의 이론적 상한선은 512mb이다. 하지만 1mb도 상당히 큰 크기이다. 저자는 이벤트 크기가 걱정되기 시작했다면 더 큰 데이터의 조회는 필요한 경우에만 조회할 수 있는 하이브리드 방식이 좋을 것이라 말한다.
- 둘째, 민감한 개인정보를 볼 수 있는 마이크로서비스의 범위를 어떻게 제한하나? 해법은 두 가지 유형의 이벤트를 동시에 보내는 것이다. 하나의 이벤트는 개인정보를 포함하고, 다른 이벤트는 개인정보를 제외하여 광범위한 브로드캐스트를 수행한다. 하지만 이는 복잡성을 높이는 방법이다. 만약 첫번째 이벤트는 발행했지만, 두번째 이벤트를 보내기전에 인스턴스가 죽으면 어떻게 될까?
- 셋째, 이벤트에 데이터가 포함되는 시점부터 이는 계약의 한 부분이 된다는 사실이다. 이벤트에서 특정 필드가 제외되면 소비자의 서비스가 중단될 수 있음을 알아야 한다. 

저자의 규칙은 api를 통해 동일한 데이터를 공유할 수 있다면 이벤트에 정보를 넣어도 괜찮다는 것이다.

### 8.3 적용 대상

느슨한 결합에 중점을 둔다면 이는 매력적인 패턴이다.

하지만 이러한 협업 방식은 새로운 복잡성의 원인이 될 수 있다. 이벤트 기반 방식에 대한 확신이 서지 않는다면 하나의 이벤트부터 시작해 점차 확장해나가는 방법을 택할 수도 있다. msa에서는 다양한 상호작용 방식이 혼합될 수 있음을 상기하라.

## 9. 조심해서 진행하라.

저자의 경험을 말한다.

처리할 수 없는 메세지가 하나의 워커를 터트리고 큐로 되돌아간다. 다른 워커가 요청을 집어들고 같은 과정이 반복된다. 마틴 파울러가 파국적 페일오버(catastrophic failover)라고 부르는 전형적인 경우다. 큐에 있는 작업의 최대 재시도 제한도 없었다.

이를 해결하기 위해 작업에 대한 최대 재시도 제한을 설정하고, 실패한 메세지가 이동할 데드 레터 큐(dead letter queue)를 추가하였다. 그리고 재시도 처리가 가능한 ui도 만들었다.

이처럼 이벤트 기반 또는 비동기식 상호작용의 복잡성으로 인해 이러한 아이디어를 택하는데 신중해야 한다. 그리고 동일하게 더 단순한 것처럼 보이는 동기식 상호작용에서도 유사한 문제가 발생할 수 있다. 단지 이러한 문제는 우리에게 더 친숙한 것일 뿐이다.
