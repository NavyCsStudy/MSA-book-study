## 1. 데이터베이스 트랜잭션

### 1.1 ACID 트랜잭션

- 일반적으로 이야기하는 트랜잭션
- 저장소의 내구성과 일관성을 보장하기 위한 주요 속성을 의미하는 약어

#### 원자성

- 일련의 작업을 모두 완료하거나, 모두 실패해야 함

#### 일관성

- 데이터 변경 후는 변경 전과 같이 유효하고 일관적이어야 함

#### 격리성

- 한 트랜잭션이 다른 트랜잭션의 작업에 끼어들지 않음

#### 내구성

- 성공적으로 수행된 트랜잭션은 영구적으로 반영되어야 함


- 모든 db가 acid 트랜잭션을 제공하지는 않음

### 1.2 여전히 ACID이지만 원자성이 부족한가?

<img width="563" height="444" alt="스크린샷 2025-11-17 오후 5 23 09" src="https://github.com/user-attachments/assets/bf203625-b92b-480a-9090-a13bf371a9bf" />

- 모놀리식에서는 하나의 트랜잭션 안에서 수행될 수 있는 작업이 ms에서는 2개 이상으로 나누어질 수 있음
- 트랜잭션의 순서를 정할 수 있겠지만 만약 실패한다면?
- 더이상 전체 일련의 작업에 대한 원자성을 보장하지 못함

## 2. 분산 트랜잭션 - 2단계 커밋

- 투 페이즈 커밋(2단계 커밋, Two-Phase Commit, 2PC) 알고리즘은 분산 시스템에서 트랜잭션을 변경할 수 있는 기능을 제공하려는 시도로 자주 사용됨
- 2pc는 투표(voting)와 커밋(commit) 단계로 나뉨

#### 투표 단계

- 코오디네이터(중앙 조정자, coordinator)는 트랜잭션에 참가할 모든 워커(worker)에 연락하고 일부 상태 변경이 가능한지 여부를 확인 요청

<img width="663" height="441" alt="스크린샷 2025-11-17 오후 5 29 57" src="https://github.com/user-attachments/assets/f874f02d-f934-4389-a913-0cd62d2c0c69" />

- 모든 워커가 상태 변경이 가능하다고 동의하면 다음 단계 진행
- 일부 워커가 유효하지 않은 상태 변경이라고 하면 전체 연산은 중단
- 변경은 즉시 적용되는 대신 미래 어느 시점에 수행할 수 있음을 보장
  - 레코드를 잠그는 방식으로 상태 변경이 가능함을 보장할 수 있음
  - 커밋에 찬성하지 않은 워커가 있는 경우, 모든 당사자에게 롤백 메세지를 보내 잠금을 해제하도록 보장해야 함
 
- 코오디네이터의 커밋 요청은 모든 워커에게 동시제 도착할 수 없음
- 코오디네이터와 워커 사이의 통신 지연이 발생하거나, 워커의 응답 처리 속도가 늦을 수 있음
- 더이상 격리성이 보장되지 않음. 즉, 트랜잭션 중간 상태를 관측할 수 있음

<img width="671" height="417" alt="스크린샷 2025-11-17 오후 5 39 28" src="https://github.com/user-attachments/assets/9ab78165-be4c-45f9-8e70-e2fee64e8f68" />

- 어떤 워커는 투표까지 했지만 커밋 요청에 응답하지 않는다면 어떻게 처리해야 할까?
- 참여자가 많을 수록, 시스템 지연 시간이 길수록 많은 문제가 발생

## 3. 분산 트랜잭션 - 그냥 안 된다고 하라

- 트랜잭션을 어떻게 분해해야 할지 모르겠다면 우선 다른 부분부터 작업하자

> 데이터베이스 분산 트랜잭션
> 분산 트랜잭션은 일부 대규모 데이터베이스에 사용되고 있다. 구글에서는 이를 위해 매우 비싼 데이터 센터와 위성 기반의 원자 시계가 돌아가고 있다고 한다.

## 4. 사가 패턴

- 사가(saga)는 여러 상태 변경을 조정할 수 있음
- 2pc와 달리 자원을 잠글 필요가 없는 알고리즘으로 설계됨
- 관련된 단계는 독립적으로 실행할 수 있는 개별 활동으로 모델링하여 작업을 수행함
- 핵심 개념은 장기 트랜잭션(Long Lived Transaction, LLT). 트랜잭션은 몇 분, 몇 시간, 며칠이 걸릴 수 있음
- 일반적인 트랜잭션에서는 llt가 진행되는 동안 여러 행이 오랜 시간 잠길 수 있음
- llt를 일련의 트랜잭션으로 분해하면 잠금 범위 및 지속 시간이 줄어듬
- 사가는 본래 단일 데이터베이스에 대해 작동하는 llt를 지원하기 위한 메커니즘. 그러나 여러 서비스에 걸친 변경 사항을 조정할 경우에도 효과적

<img width="748" height="621" alt="image" src="https://github.com/user-attachments/assets/eab12840-16d6-4948-b9b6-70811fd50678" />

- 주문 처리 프로세스는 하나의 사가로 표현됨
- 각 서비스 내부의 상태 변경은 로컬 트랜잭션으로 처리됨

### 4.1 사가 실패 모두

#### 역방향 복구(backward recovery)

- 실패 복구와 이후에 일어나는 정리 작업인 롤백이 포함
- 이전에 커밋된 트랜잭션을 취소하는 보상 조치를 정의해둬야 함

#### 정방향 복구(forward recovery)

- 실패 발생 지점에서 데이터를 가져와 계속 처리할 수 있음
- 우리 시스템이 재시도를 위한 충분한 정보를 보유하고 있어야 함


- 비즈니스 특성에 따라 두 가지 방식을 모두 혼합할 수도 있음
- 사가를 통해 비즈니스 실패를 복구할 수 있다는 점이 중요
- 사가는 기반 구성 요소가 안정적으로 동작하고 있다는 것을 가정함

#### 사가 롤백

- 사가에서 일부 트랜잭션이 커밋된 이후에는 어떻게 롤백하는가?

<img width="742" height="616" alt="image" src="https://github.com/user-attachments/assets/d565bc95-f1c6-40bb-b7b2-149777a83d76" />

- 롤백을 원한다면 보상 트랜잭션(compensating transaction)을 구현해야 한다.
- 사가에서 커밋된 일련의 트랜잭션들에 대해 보상 트랜잭션을 일으켜야 함

<img width="761" height="622" alt="image" src="https://github.com/user-attachments/assets/13e0fc28-9532-4c8a-b737-5cd9cae01afc" />

- 보상 트랜잭션은 일반적인 데이터베이스 롤백과 동일한 동작을 수행하지 않을 수 있음
  - 단일 트랜잭션 롤백처럼 트랜잭션이 전혀 없었던 것으로는 만들 수 없음

 - 고객에게 이미 전송된 이메일을 되돌릴 수는 없음
 - 대신 주문이 취소됐음을 알리는 이메일을 보낼 수는 있음

#### 롤백을 줄이는 워크플로의 단계 재정렬

- 롤백 가능성이 있는 시나리오를 재정렬하여 문제를 간단하게 만들 수도 있음
  - 주문이 처리된기 전에 포인트를 주는 대신, 주문이 실제로 발송된 경우에만 포인트를 부여한다.
 
- 실패할 가능성이 높은 작업을 먼저 처리하고 일찍 실패하면 보상 트랜잭션 자체가 필요없을 수 있음
- 이러한 작업으 보상 트랜잭션을 구현하기 어려운 경우라면 특히 중요함

<img width="745" height="753" alt="image" src="https://github.com/user-attachments/assets/64d2a2e2-cc65-4ea7-821f-f0cf19a03f39" />

#### 역방향 실패 및 정방향 실패 상황의 혼합

- 롤백이 필요한 실패(역방향 실패)도 있고, 정방향 실패가 필요한 경우도 있음
- 주문은 성공했지만, 택배 물품 발송이 실패했다고 전체 주문을 돌리는 것은 이상함
- 대신 배송을 재시도하고 그래도 실패한다면 사람이 직접 개입하는 것이 합리적

### 4.2 사가 패턴 구현

#### 오케스트레이션 사가(orchestrated saga)

- 중앙 집중식 조정과 추적에 의존
- 오케스트레이터(중앙 조정자)가 실행 순서를 정의하고 필요한 보상 조치를 트리거

<img width="748" height="448" alt="image" src="https://github.com/user-attachments/assets/5f241158-0e67-402e-a45a-776b869fd1d0" />

- 오케스트레이터는 작업을 위해 필요한 서비스가 무엇인지 알고 있으며, 언제 호출해야 할지 결정
- 호출이 실패하면 결과에 따라 어떤 작업을 수행할지 결정
- 서비스간 요청/응답 호출을 많이 사용하는 편
- 오케스트레이터 내부의 비즈니스 프로세스를 명시적으로 모델링해두면 유용함
  - 오케스트레이터만 봐도 프로세스가 어떻게 작동하는지 이해할 수 있음
 
- 단점
  - 오케스트레이터는 관련된 서비스들과 높은 도메인 결합도를 가짐
  - 서비스 로직이 오케스트레이터에 흡수될 수 있음


- 중앙 집중화를 피하기 위해 해당 비즈니스 로직을 잘 알고 있는 서비스가 오케스트레이터의 역할을 수행해야 함
- 즉, 서로 다른 흐름에 대해 그 흐름에 대해 가장 잘 알고 있는 서비스가 오케스트레이터가 될 수 있음
 
#### 코리오그래피 사가

- 여러 협력 서비스 사이에서 사가 운영에 대한 책임을 분산시키는 것이 목표

<img width="751" height="510" alt="image" src="https://github.com/user-attachments/assets/84092ef0-570f-4169-9a60-9f2182d4cad8" />

- 모든 서비스는 상대 서비스를 알지 못함
- 특정 이벤트가 수신될 때 자신이 할 일만 파악하면 됨
- 도메인 결합도가 낮고 비즈니스 로직의 중앙 집중화를 피할 수 있음
- 단점
  - 어떤 일이 일어나는지 파악하기 어려울 수 있음
  - 오케스트레이터의 프로세스만 파악하면 되는 것과 달리 각 서비스 동작을 살펴보고 프로세스를 구성해야 함
  - 사가의 현재 상태를 파악하기 어려움
 
- 발행된 이벤트를 사용해 사가의 현재 상태를 파악하기 위한 view를 구성할 수 있음
- 이벤트에 사가에 대한 상관관계 id를 부여하여 로깅과 추적에 활용할 수 있음

#### 혼합 방식

- 코리오그래피 사가의 일부가 오케스트레이터 사가로 구성된 흐름을 사용할 수도 있음
- 혼합 방식을 사용할 때도 현재 사가의 상태가 어떤지 명확하게 파악할 수 있는 방법을 마련해야 함
- 그렇지 않으면 실패 복구가 어려워질 것임

#### 둘 중 어느 것을 사용해야 하는가?

- 코리오그래피 사가는 이벤트에 기반한 방식
- 사가의 진행 상황 추적의 복잡성이 느슨한 결합을 가진 아키텍처의 이점보다 큼
- (저자의 경험에 따르면)
- 한 팀이 전체 사가를 구성할 때는 오케스트레이션이 편함
  - 결합된 아키텍처일수록 팀 경계 내에서 관리하기 쉬움
 
- 여러 팀이 관여할 때는 코리오그래피 사가가 편함
  - 구현에 대한 책임을 각 팀에 분배하기 쉬움
  - 느슨하게 결합된 아키텍처로 각 팀의 독립적 작업이 가능
 
