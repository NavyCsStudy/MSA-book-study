# 6 워크플로

## 6.1 데이터베이스 트랜잭션
- 트랜잭션 : 단일 단위로 취급하고 싶은 하나 이상의 작업
- 트랜잭션을 사용해 하나 이상의 상태 변경이 성공적으로 수행됐는지 확인
- 관계형 데이터베이스에서는 하나의 트랜잭션 내에서 여러 테이블이 업데이트 됨

### 6.1.1 ACID 트랜잭션
- 원자성: 모두 완료한 상태거나 모두 실패한 상태
- 일관성: 데이터베이스가 변경되면 유효하고 일관된 상태가 유지
- 격리성: 여러 트랜잭션이 독립적으로 실행
- 내구성: 트랜잭션 완료 후 데이터가 손실되지 않고 변경 사항이 반영

### 6.2.1 여전히 ACID이지만 원자성이 부족한가?
- MSA에서는 트랜잭션 상태 변경 범위는 한 MS 내부의 로컬에 국한
- MSA 에서는 트랜잭션이 분해되고 전체적으로 작업의 원자성을 보장할 수 없는 상황이 불가피함
- 기존 모놀리식 환경에서는 DB 레벨에서 쉽게 되던 것들이 MSA로 갈 때 큰 문제가 됨

## 6.2 분산 트랜잭션 - 2단계 커밋
- 2-Phase Commit(2PC): 분산 트랜잭션을 위해 등장한 가장 대표적인 알고리즘
- 2PC는 두 단계로 구성됨
1. Prepare(투표) 단계
    - 중앙 조정자(Coordinator) 가 각 워커(참가자 서비스)에게 “이 변경 가능해?”라고 물어봄
    - 각 워커는 변경을 바로 수행하지 않고 “나중에라도 이 변경을 수행할 수 있음”을 보장하기 위해 리소스 잠금을 걸어둠
    - 모든 워커가 OK(vote yes)를 하면 다음 단계로 진행
    - 하나라도 NO(vote no)이면 전체 트랜잭션 중단(rollback)

2. Commit 단계
    - 조정자가 “커밋해!” 메시지를 모든 워커에 전송
    - 각 워커는 실제 변경을 수행하고 잠금을 풀어줌

#### 2PC의 한계
1. 강한 일관성이 완전히 보장되지 않음. 메시지 지연 때문에 워커 A는 이미 커밋됐는데 워커 B는 아직 커밋되지 않을 수 있음
2. 트랜잭션 중에 중간 상태를 볼 수 있음. ACID의 ‘격리성(Isolation)’이 완벽히 깨짐.
3. 워커들이 “나중에 커밋해야 하니까” 잠금을 걸어둠 -> 잠금은 오래 유지될수록 시스템 전체 성능을 떨어뜨림
4. 장애 상황이 매우 다루기 힘듦. 예: 투표에서는 OK했는데 커밋 메시지를 받을 때 워커가 죽음
5. 트랜잭션 지속 시간이 길수록 시스템 전체가 느려짐. 잠금이 길게 유지됨
6. 참가자(service)가 많을수록, 네트워크 지연이 클수록 문제 심각해짐

## 6.3 분산 트랜잭션 - 그냥 안 된다고 하라
- 마이크로서비스 전체에 걸친 분산 트랜잭션(특히 2PC) 는 웬만하면 쓰지 않는 것을 추천

- 대안 1: 그냥 쪼개지 말자 (단일 DB/모놀리스 유지)
    - 정말 강한 원자성과 일관성이 꼭 필요한 데이터가 있는데 그걸 ACID 없이 현명하게 처리할 방법을 못 찾겠다 -> 그 데이터는 한 DB + 한 서비스(또는 모놀리스) 에 그대로 관리

- 대안 2: 데이터는 쪼개야 하는데 분산 트랜잭션은 싫다 -> 사가 패턴

## 6.4 사가 패턴
- 여러 서비스에 걸친 긴 비즈니스 프로세스를 조정하는 패턴
- 2PC(분산 트랜잭션)처럼 자원 잠금이 필요 없음
- 긴 작업을 여러 개의 독립적인 로컬 트랜잭션으로 분해하여 처리함

### 6.4.1 사가 실패 모드
- 사가는 여러 단계로 나뉘어 있으므로 실패 시 어떻게 복구할지를 반드시 정의해야 함

#### 복구 방식 두 가지

1. 역방향 복구 (Backward Recovery)
- 이미 커밋된 작업을 되돌리는 방식
- 각 단계마다 보상 트랜잭션(Compensating Transaction) 을 정의해둠
    예: 재고 예약 → 예약 취소, 포인트 적립 → 포인트 차감 등

2. 정방향 복구 (Forward Recovery)
- 실패한 지점에서 다시 시도하거나, 다른 경로로 계속 진행
    예: 배송 실패 시 다음날 배송 큐에 다시 넣기

#### 사가 롤백
- ACID 트랜잭션처럼 “애초에 아무 일도 없던 것처럼” 만드는 롤백이 아님
- 여러 단계가 이미 각기 커밋된 상태이기 때문에 새 트랜잭션을 실행해서 반대 의미의 작업으로 상태를 되돌려야 함
- 보상 트랜잭션 : 이전에 트랜잭션을 취소하는 연산

#### 롤백 부담 줄이기 (워크플로 재정렬)
- 실패 가능성이 높은 단계는 앞에, 보상 트랜잭션 만들기 어려운 단계는 뒤에 배치
- 예: 포인트 적립을 “배송 완료 이후”로 옮기면 중간에서 주문이 깨져도 “포인트 취소” 보상 트랜잭션을 안 만들어도 됨

### 6.4.2 사가 패턴 구현

#### 오케스트레이션 사가 (Orchestrated Saga)
- 중앙 오케스트레이터(orchestrator) 가 전체 흐름을 제어
    - 어떤 서비스가 언제 호출될지
    - 실패 시 어떤 보상 트랜잭션을 호출할지

- 장점
    - 비즈니스 프로세스를 한 곳에서 명시적으로 모델링 가능
    - 새로 온 사람이 이해하기 쉬움

- 단점
    - 오케스트레이터가 여러 서비스에 대해 많이 알게 되어 결합도 증가
    - 서비스 내부에 있어야 할 로직이 오케스트레이터로 빨려 들어갈 위험 (서비스가 수동적이 됨)

#### 코레오그래피 사가 (Choreographed Saga)
- 중앙 조정자 없이 이벤트 기반으로 느슨하게 협업
- 각 서비스는 특정 이벤트를 수신하면 내가 할 일을 하고, 필요하면 다음 이벤트를 발행

- 장점
    - 서비스 간 결합도 낮음, 독립적으로 진화/배포하기 좋음

- 단점
    - 전체 비즈니스 플로우를 한눈에 보기 힘듦
    - 사가의 현재 상태를 파악하기 어려움 -> 보상 타이밍을 놓칠 수 있음

#### 상태 추적 – 상관관계 ID(Correlation ID)
- 코레오그래피 방식에서 필수에 가깝게 쓰임
- 하나의 사가(예: 주문 1건)에 대해 고유한 ID를 부여하고 이 ID를 모든 관련 이벤트에 포함시켜 나중에 “이 주문이 어떤 단계를 거쳤는지”를 재구성

#### 혼합 모델
- 일부는 오케스트레이션, 일부는 코레오그래피로 섞어 사용하는 것도 가능
- 어떤 방식이든 사가의 상태와 이미 수행된 단계들을 추적할 수 있게 설계하는 것이 핵심

### 6.4.3 사가 vs 분산 트랜잭션

#### 분산 트랜잭션(2PC 등)
- 노드 하나만 장애 나도 전체 트랜잭션이 멈출 수 있음
- 노드가 많아질수록 가용성 떨어짐
- 잠금/지연/복잡성이 매우 크다

#### 사가
- 분산 트랜잭션 없이, 비즈니스 프로세스를 로컬 트랜잭션 + 보상 트랜잭션 조합으로 명시적으로 모델링
- 마이크로서비스 환경에 더 적합한 접근