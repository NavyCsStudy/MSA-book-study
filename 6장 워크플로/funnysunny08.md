## 6.1 데이터베이스 트랜잭션

트랜잭션은 하나 이상의 작업을 하나의 단일 단위로 묶어 처리하기 위한 개념이다.

여러 변경 사항이 하나의 전체 작업으로 묶여 있을 때,

- 모든 변경이 성공적으로 적용되거나
- 오류 발생 시 전체 작업이 취소되어야 한다.

즉, 일관된 상태 보장과 실패 시 복구(롤백) 기능이 필요하다.

### 6.1.1 ACID 트랜잭션

ACID 트랜잭션은 다음 네 가지 특성으로 정의된다.

- 원자성(Atomicity): 모든 작업이 전부 완료되거나 전부 실패해야 한다.
- 일관성(Consistency): 데이터베이스의 유효성과 제약 조건이 항상 유지되어야 한다.
- 격리성(Isolation): 동시에 실행되는 트랜잭션 간 간섭이 없어야 하며, 중간 상태가 다른 트랜잭션에 보이지 않아야 한다.
- 내구성(Durability): 트랜잭션이 완료되면 시스템 오류가 발생해도 데이터는 보존되어야 한다.

단, 모든 데이터베이스가 ACID를 완전하게 지원하지는 않는다.

예를 들어 MongoDB는 단일 문서 단위에 대해서만 ACID를 보장한다.

### 6.1.2 여전히 ACID이지만 원자성이 부족한가?

<img width="770" height="1197" alt="Image" src="https://github.com/user-attachments/assets/d608ca15-aa04-48a7-ba98-53fbe98e8f0d" />

마이크로서비스는 각자 자신의 데이터베이스 내에서는 ACID 트랜잭션을 자유롭게 사용할 수 있다.

하지만 서로 다른 서비스 간 상태 변경이 필요한 경우, 즉 여러 데이터베이스를 아우르는 트랜잭션이 발생하면 문제가 된다.

[그림 6-2]의 예처럼 두 개의 데이터베이스에서 변경이 일어나면, 트랜잭션은 두 개로 나뉘고 각 트랜잭션은 서로 독립적으로 성공하거나 실패할 수 있다.

이때 순서를 조정하거나 예외 처리를 직접 구현할 수 있지만 **결국 전체 작업의 원자성을 완벽히 보장할 수는 없다.**

## 6.2 분산 트랜잭션 - 2단계 커밋 (2 Phase Commit, 2PC)

<img width="1069" height="673" alt="Image" src="https://github.com/user-attachments/assets/7d8690f4-51ee-4037-934c-05793e3b1e43" />

<img width="965" height="637" alt="Image" src="https://github.com/user-attachments/assets/2d79cdee-a954-4672-bc4a-1cdb68aba243" />

분산 시스템에서는 하나의 논리적 트랜잭션을 여러 프로세스에 걸쳐 수행해야 할 때가 있다. → 2PC

2PC는 다음 두 단계로 구성된다.

1. 투표(Voting) 단계
    - 중앙 조정자(Coordinator)가 트랜잭션 참여자(Worker)들에게 변경 가능 여부를 확인하며 모든 참여자가 “OK”를 반환해야 다음 단계로 진행된다.
    - 한 곳이라도 실패하면 전체 트랜잭션은 중단되고, 조정자는 각 참여자에게 롤백 메시지를 보내 잠금을 해제하도록 한다.
2. 커밋(Commit) 단계
    - 모든 참여자가 승인한 경우 실제 변경이 수행되고 잠금이 해제된다.
- 단점
    - 동시 커밋 보장 불가: 네트워크 지연과 처리 속도 차이로 인해 커밋 시점이 다를 수 있다.
    - 격리성 손실: 중간 상태를 완전히 숨기기 어렵다.
    - 잠금 지속 문제: 커밋이 완료될 때까지 자원을 잠가야 하므로 지연이 길어지면 병목이 발생한다.
    - 복잡한 실패 처리: 일부 노드가 응답하지 않거나 네트워크가 끊길 경우, 조정자가 직접 개입해야 할 수도 있다.

따라서 2PC는 **지속 시간이 짧고 단순한 작업**에만 주로 사용된다.

## 6.3 분산 트랜잭션 - 그냥 안 된다고 하라

애초에 데이터를 분리하지 않는 것 → 상태를 단일 데이터베이스에 두고 하나의 서비스가 이를 전담 관리하게 하는 방식

그러나 서비스 분리가 불가피하다면, 분산 트랜잭션의 복잡함 대신 사가(Saga) 패턴을 사용하는 것이 현실적인 대안이다.

## 6.4 사가 패턴

사가 패턴은 자원 잠금 없이 여러 상태 변경을 조율할 수 있도록 설계된 알고리즘이다.

각 단계를 독립적인 트랜잭션으로 모델링해 순차적으로 실행하며, **비즈니스 프로세스를 명시적으로 표현할 수 있다는 장점**이 있다.

> **LLT (장기 트랜잭션, Long-Lived Transaction)**
> 
> - LLT를 하나의 트랜잭션으로 처리하면 오랜 시간 동안 락이 유지되어 성능 문제가 발생할 수 있다.
> - 따라서 LLT를 여러 짧은 하위 트랜잭션으로 분리해 각각 독립적으로 처리한다.
> - 이렇게 하면 전체 프로세스를 유지하면서도 데이터 락을 최소화할 수 있다.

<img width="722" height="887" alt="Image" src="https://github.com/user-attachments/assets/6c77adbb-ba28-46a0-8d82-2c57dd4ac396" />

여기서 주문 처리 프로세스를 하나의 사가로 표현

### 6.4.1 사가 실패 모드

사가를 개별 트랜잭션으로 분해하려면, 실패 처리(복구) 방법을 고려해둬야 한다.

- 역방향 복구(보상 트랜잭션)
    - 이미 커밋된 트랜잭션을 되돌리는 연산을 수행한다.
    - 예: 주문 취소 이메일 발송
- 정방향 복구(재시도)
    - 실패한 지점부터 처리를 재개한다.
    - 예: 배송 실패 시 다음 날 재시도
- **혼합 방식**
    - 상황에 따라 역방향과 정방향 복구를 병행한다.
- 사가를 통해 기술적인 실패가 아닌 비즈니스 실패로부터 복구할 수 있다는 점을 기억하는 것이 중요하다.
    - 비즈니스 실패 → 결제 시도 했지만 잔액 부족
    - 기술적 실패 → 게이트웨이 타임아웃

**사가 롤백**

<img width="1173" height="1030" alt="Image" src="https://github.com/user-attachments/assets/99c24947-07b9-4f45-afed-6281c37b0ead" />

- 트랜잭션이 이미 커밋된 이후에 어떻게 트랜잭션을 롤백할 수 있을까?
    - 보상 트랜잭션 : 이전에 커밋된 트랜잭션을 취소하는 연산
- 사가의 롤백은 데이터베이스 롤백처럼 “없던 일로” 만드는 것이 아니라, 새로운 트랜잭션을 생성해 의미적으로 복원하는 것 ⇒ 보상(Compensation), 의미적 롤백

**롤백을 줄이는 워크플로의 단계 재정렬**

<img width="1015" height="1019" alt="Image" src="https://github.com/user-attachments/assets/54cfd4eb-26f7-4cbe-a921-8513d10ee097" />

- 프로세스 실행 방식을 조율하는 방법만으로도 롤백 연산을 단순화할 수 있다.
- 실패할 가능성이 가장 높은 단계를 앞으로 당기고 해당 프로세스를 더 일찍 실패하면, 해당 단계는 애초에 수행되지도 않았으므로 나중에 보상 트랜잭션을 할 필요가 없다.

**역방향 실패 및 정방향 실패 상황의 혼합**

- 롤백(역방향 실패)이 필요한 실패도 있고, 정방향 실패가 필요한 경우도 있다.
- 예를 들어, 택배 발송을 하지 못 했다면 주문으 되돌리는 것보다 배송을 재시도(다음 날 배송 대기열에 넣는 방식)하는 것이 더 적합하다.

### 6.4.2 사가 패턴 구현

**오케스트레이션형 사가**

<img width="556" height="469" alt="Image" src="https://github.com/user-attachments/assets/d6d1025e-68b8-43a8-a92d-34316f8e665f" />

- 중앙 조정자(Orchestrator)가 전체 흐름을 제어하는 방식
- 오케스트레이터는 각 서비스 호출 순서와 보상 조치를 정의하고 실행을 관리
- 장점: 흐름이 명확하고 제어가 쉬움
- 단점:
    - 중앙 집중화로 인한 높은 결합도
    - 오케스트레이터가 비즈니스 로직을 과도하게 흡수할 수 있다.
        - 서로 다른 프로세스별로 별도의 오케스트레이터를 두어 분산시키는 것이 좋다.

**코레오그래피형 사가**

<img width="1020" height="727" alt="Image" src="https://github.com/user-attachments/assets/f4ab820f-66bf-4653-99d1-1dc6c1844965" />

- 중앙 조정자 없이 이벤트 기반으로 서비스들이 자율적으로 협력하는 방식
- 서비스들은 이벤트를 구독, 발행하며 필요한 작업을 수행한다.
    - ex) 창고 서비스는 첫 번째 주문 접수 이벤트를 수신할 경우 재고 예약을 완료한 후 이벤트를 다시 발행
        - 재고가 부족하다면 관련하여 적절한 이벤트를 발행하여 주문을 중단하게 만든다.
- 장점: 낮은 결합도, 병렬 처리 용이
- 단점:
    - 흐름 파악이 어려워 모니터링이 복잡함
        - 이를 보완하기 위해 사가 ID(상관관계 ID) 를 이벤트에 포함시켜 추적한다.
        - 모든 이벤트를 수집해 상태를 집계하는 별도의 모니터링 서비스를 두기도 한다.

**혼합 방식**

오케스트레이션과 코레오그래피 방식을 상황에 맞게 결합한 형태로 중앙 제어와 이벤트 분산의 장점을 동시에 취한다.

**코레오그래피형 사가와 오케스트레이터형 사가(또는 혼합형) 중 어느 것을 사용해야 할까?**

- 한 팀이 전체 사가를 관리한다면 → 오케스트레이션형
- 여러 팀이 참여하고 느슨한 결합이 필요하다면 → 코레오그래피형

### 6.4.3 사가와 분산 트랜잭션 비교

저자는 분산 트랜잭션보다는 사가를 선호한다.

사가를 사용하면 복잡한 분산 잠금 문제를 피하면서도 비즈니스 프로세스를 명확히 모델링할 수 있고, 개발자에게 시스템 동작이 훨씬 투명하게 드러난다.