## 14.1 디지털을 향해

- 웹/모바일 구분 → 디지털 경험 전체로 사고 전환
- 핵심 질문
    - 고객은 어떻게 서비스를 사용할까?
    - 이는 시스템 아키텍처에 어떤 영향을 주는가?
- 고객 행동 예측 불가 → 세분화된 API (마이크로서비스) 도입 촉진
- UI 설계는 두 관점에서 접근 필요
    - 누가(조직/책임)
    - 어떻게(기술/패턴)

## 14.2 소유권 모델

- 전통적 계층형 구조의 문제
    - 프론트엔드 팀 / 백엔드 팀 분리 ⇒ 작은 UI 변경에도 여러 팀 협업 필요, 전달 속도 저하
- 독립 배포를 위한 이상적 모델 = UI + 서버 구성요소를 한 팀이 함께 소유하고 엔드투엔드 변경 책임
- 장점
    - 변경 속도 향상
    - 팀이 최종 사용자와 직접 연결됨
- 현실
    - 여전히 전담 프론트엔드 팀 모델이 널리 사용됨

### 14.2.1 전담 프론트엔드 팀 추구

전담 프론트엔드 팀이 생기는 이유는 크게 세 가지:

- 전문성
    - 인터랙션, 그래픽 디자인, 접근성
    - 웹 + 네이티브 모바일(iOS/Android) 기술
    - 희소한 인력 → 한 팀에 모으고 싶은 유혹
- 일관성
    - 공통 컨트롤과 인터랙션 패턴
- 기술적 제약
    - SPA(Single Page Application)는 분리가 어려움
    - Angular / React / Vue 기반 UI는 구조상 모놀리식해지기 쉬움
- 이후 대안
    - 마이크로 프론트엔드
    - SPA를 유지하면서도 UI 분해 가능

## 14.3 스트림 정렬 팀을 향해

- 전담 프론트엔드 팀의 문제
    - 새로운 핸드오프 지점 생성
    - 처리량 감소
- 이상적 조직 구조
    - 엔드투엔드 기능 중심 팀 (= 풀스택 팀)
    - 고객 가치 흐름(Stream)에 정렬
- 스트림 정렬 팀 특징
    - 단일 업무 스트림에 책임
    - 다른 팀에 의존하지 않고 기능 전달
- 효과
    - 사용자와 직접 연결
    - 요구사항 오해 감소
    - KPI가 고객 경험 중심으로 이동
- 사례: 핀테크 기업
    - 기능 출시 수보다 고객 경험 개선을 성공 기준으로 삼음

### 14.3.1 전문가 공유

- UI 전문가는 희소 (웹 + 모바일 + 디자인 + 접근성)
- 전통적 방식 문제
    - 전문가를 한 팀에 고립 → 다른 개발자의 성장 기회 차단 (기술이 전파되지 못해서)
- 대안
    - 전문가가 팀 내에서 역할 분담
    - 쉬운 작업은 일반 개발자
    - 어려운 작업은 전문가 집중
- 전문가 배치 전략
    - 풀타임 소속
    - 여러 팀에 시간 분배
    - 활성화 팀(Enabling Team) 운영
- 활성화 팀
    - 내부 컨설팅 역할
    - 팀이 자립하도록 지원
    - 어려운 문제 해결에 집중

### 14.3.2 일관성 보장

- 전담 프론트엔드 팀이 필요한 이유 → 일관성
- 일관성의 가치
    - 제품 완성도 향상
    - 신규 기능 학습 비용 감소
- 일관성 유지 방법
    - 활성화 팀을 통한 가이드
    - 공통 UI 컴포넌트
    - 디자인 시스템 / CSS 스타일 가이드
- 단, 일관성이 항상 정답은 아님
    - 사례: 아마존 / AWS → UI 일관성 낮음, 팀 자율성 극대화, 제공 속도를 UX 일관성보다 우선
- 일관성 vs 자율성은 트레이드오프

### 14.3.3 기술적 문제 극복

- UI 기술은 계속 진화 (터미널 → 데스크톱 → 웹 → 모바일)
- 변하지 않은 것: 버튼, 체크박스, 폼 등 기본 UI 컨트롤
- 변한 것: UI를 만드는 기술 스택
- 문제점
    - SPA는 UI 분해가 어려움
    - 다양한 기기에서 동일한 경험 기대
- 사용자 관점
    - 내부 구조는 관심 없음
    - 하나의 매끄러운 경험을 원함
- 과제: UI 기능을 분리하면서도 사용자에게는 단일한 경험 제공

## 14.4 패턴: 모놀리식 프론트엔드

<img width="1078" height="790" alt="Image" src="https://github.com/user-attachments/assets/1c57ba86-9d19-4f42-bab3-8a9e7bf4f0f6" />

- UI가 직접 여러 백엔드 마이크로서비스 호출
- 모든 UI 상태·동작을 단일 프론트엔드 애플리케이션에서 관리
- 백엔드 서비스는 UI가 해석하기 쉬운 데이터(JSON 등)만 제공
- 단일 페이지 애플리케이션(SPA) + 전담 프론트엔드 팀에서 흔히 사용
- UI가 화면 구성, 상태 동기화, 여러 서비스 응답 조합을 직접 처리

### 14.4.1 적용 시점

- 단점
    - 전담 프론트엔드 팀 필요
    - 여러 팀이 하나의 UI를 공동 소유하기 어려움
    - 기기별 요구사항 대응이 어려움
- 적합한 경우
    - UI 전체를 하나의 배포 단위로 관리하고 싶을 때
    - 프론트엔드 + 관련 마이크로서비스를 한 팀이 모두 개발할 때
- 조직이 계층형 구조라면 현실적으로 선택될 가능성 높음

## 14.5 패턴: 마이크로 프론트엔드

- 프론트엔드를 독립적으로 개발·배포 가능한 여러 부분으로 분해
- 정의: 독립적으로 제공 가능한 프론트엔드 애플리케이션들이 하나의 전체 UI 구성
- 스트림 정렬 팀에 필수적인 패턴
    - 팀이 백엔드 서비스 + 해당 UI를 함께 소유
- 백엔드의 독립 배포성 ↔ 프론트엔드의 독립 배포성 제공
- 대규모 SPA의 과도한 복잡성 문제 해결
- 여러 팀이 UI의 서로 다른 영역을 독립적으로 변경 가능

### 14.5.1 구현

- 웹 기반에서 두 가지 분해 방식
    - 위젯 기반 분해: 하나의 화면에 여러 독립 UI 컴포넌트 결합
    - 페이지 기반 분해: UI를 여러 독립 웹 페이지로 분리

### 14.5.2 적용 시점

- 적합한 경우
    - 계층형 아키텍처에서 벗어나 엔드투엔드 스트림 정렬 팀 도입 시
    - 프론트엔드가 너무 커져 여러 팀이 필요한 경우
- 한계
    - 백엔드 기능이 위젯/페이지 경계와 딱 맞지 않을 수 있음
    - 상호작용이 복잡해질수록 API 호출 방식으로 회귀할 가능성 증가

## 14.6 패턴: 페이지 기반 분해

<img width="1050" height="740" alt="Image" src="https://github.com/user-attachments/assets/347f1242-5825-4ad5-a4ca-4909cfc4099a" />

- UI를 여러 웹 페이지로 분해
- 각 페이지를 서로 다른 마이크로서비스가 제공
- URL 기반 라우팅으로 서비스 직접 연결
    - `/album` → Album 서비스
    - `/artists` → Artists 서비스
- 공통 탐색(Navigation)만 공유
- 각 서비스가 페이지 렌더링 전체를 책임
- 장점
    - 팀이 자신의 변경이 사용자에게 미치는 영향 파악 쉬움
    - 기술적으로 단순

### 14.6.1 적용 대상

- 웹 기반 UI 분해의 기본 선택지
- 웹 페이지는 웹의 핵심 개념 → 이해하기 쉽고 명확
- 문제점
    - SPA 증가로 페이지 기반 UI가 점점 줄어듦
    - SPA에 맞지 않는 UX를 억지로 끼워 맞추는 경우 증가
- 다른 패턴과 결합 가능 (페이지 + 위젯 조합 가능)

## 14.7 패턴: 위젯 기반 분해

<img width="894" height="672" alt="Image" src="https://github.com/user-attachments/assets/29236be2-82ef-4ebb-882a-9a9ea0e8f1cc" />

- UI를 독립적으로 변경 가능한 위젯 단위로 분해
- 각 위젯은 자체 UI, 이를 지원하는 마이크로서비스와 연계
- 예
    - 장바구니 위젯
    - 추천 위젯
- 위젯과 백엔드를 같은 팀이 소유하는 구조에 적합
- 컨테이너 애플리케이션 필요
    - 공통 탐색
    - 기본 레이아웃 제공
- 실제 사례: Spotify UI (재생목록, 아티스트 정보, 추천 등)

### 14.7.1 구현

- 위젯 연결 방식
    - 서버 측 템플릿
    - 클라이언트 측 동적 삽입
- iframe은 일반적으로 비권장
    - 크기 조정 어려움
    - 위젯 간 통신 문제
- 문제점
    - 동일 페이지 내에서 실행 → 충돌 위험
    - 서로 다른 프레임워크/버전 공존 가능
        - 장점: 점진적 업그레이드 가능
        - 단점: 중복 의존성으로 페이지 무게 증가
- 페이지 로드 크기 급증 가능
    - 여러 프레임워크 중복 로딩
- 페이지 내 위젯 간 통신
    - 사용자 정의 이벤트 사용
    - 이벤트 기반 통신 (마이크로서비스 이벤트 모델과 유사)

### 14.7.2 적용 시점

- 여러 스트림 정렬 팀이 동일 UI에 동시에 작업할 때 유리
- 페이지 기반 분해보다 더 높은 유연성
- 재사용 가능한 위젯 제공 가능
- SPA 기반 리치 UI에 특히 적합
- 주의 사항
    - 번들링 설정 복잡성
    - 페이지 무게 관리 필요 (임계값 초과 시 경고하는 자동 검사 권장)
- 단순·정적 위젯은 구현 부담 적음

## 14.8 제약

- 다양한 기기 → 서로 다른 제약 조건 존재
    - 화면 크기, 입력 방식, 접근성(장애 지원)
- 접근성은 윤리적 문제, 법적 문제로도 연결 가능
- 모바일의 추가 제약
    - 대역폭, 배터리 소모, 상호작용 방식 차이
- 일반적 해결책
    - 클라이언트 측 필터링
    - 호출 집계
- 다음 패턴
    - 중앙 집계 게이트웨이
    - 프론트엔드를 위한 백엔드
    - GraphQL

## 14.9 패턴: 중앙 집계 게이트웨이

<img width="1002" height="688" alt="Image" src="https://github.com/user-attachments/assets/29e2ca82-7cfb-4034-b425-c434f3936f95" />

- UI와 백엔드 마이크로서비스 사이에 위치
- 역할: 호출 집계, 데이터 필터링
- UI가 여러 서비스 호출할 필요 없이 단일 호출
- 응답에서 UI에 필요 없는 데이터 제거
- 장점
    - 호출 수 감소
    - 네트워크 비용 감소
    - 응답 시간 개선

### 14.9.1 소유권

- 문제
    - 게이트웨이 소유 주체가 불분명
    - 전담 팀이 생기기 쉬움 → 계층형 아키텍처 회귀
- 원칙: 호출 집계는 UI 요구사항 중심 → UI 팀 소유가 자연스러움
- 위험
    - 게이트웨이가 배포 병목이 됨
    - 여러 팀이 동시에 변경 필요

### 14.9.2 다양한 종류의 사용자 인터페이스

- 기기마다 필요한 데이터, 상호작용 방식 다름
- 동일 게이트웨이에서 웹용 집계 로직, 모바일용 집계 로직 분기
- UI 종류 증가 시
    - 게이트웨이 비대화
    - 단일 배포 유닛 병목 발생

### 14.9.3 여러 문제

- 추가로 처리해야 할 것들: 인증, API 키 관리, 라우팅, 속도 제한
- API 게이트웨이 제품 활용 가능
    - 하지만 집계·필터링까지 맡기면 위험
- 제품 종속성 문제
    - 기술 선택 제한
    - 특정 벤더 DSL에 로직 종속
- 집계 로직이 도메인 기능과 결합되면 이동·재구현 어려움
- 최악의 경우 UI 팀, 게이트웨이 팀, 마이크로서비스 팀 모두 변경해야 기능 출시 가능

### 14.9.4 적용 시점

- 단일 팀이 UI + 백엔드를 모두 소유하면 사용 가능
- 다수 팀 조직에서는 조율 비용 큼
- 중앙 게이트웨이를 쓰더라도 포함할 기능을 매우 신중히 선택해야 함
- 집계·필터링은 중요하지만 중앙 소유 모델의 문제를 피해야 함
- 해결책: 프론트엔드를 위한 백엔드(BFF) 패턴

## 14.10 패턴: 프론트엔드를 위한 백엔드 (BFF)

<img width="1078" height="938" alt="Image" src="https://github.com/user-attachments/assets/9c507c4f-8440-41de-b06e-511bf2470f9e" />

- BFF(Backend for Frontend)는 특정 사용자 인터페이스(UI)를 위해 설계된 백엔드
- 중앙 집계 게이트웨이와 달리
    - “모든 UI를 위한 하나”가 아니라
    - “하나의 UI를 위한 하나”를 목표로 함
- SoundCloud, REA 등에서 효과가 검증됨
- 각 UI(웹, 모바일 등)는 자체 집계 백엔드를 가질 수 있음
- 장점
    - 여러 팀이 하나의 게이트웨이를 공유하며 생기는 병목 회피
    - UI와의 강한 결합을 허용 → 요구사항 반영 쉬움
    - UI 팀이 API 정의와 릴리스 주기를 직접 통제 가능
- 개념적으로 UI는 두 부분으로 나뉨
    - 클라이언트 측 UI (웹/모바일 앱)
    - 서버 측 UI 역할을 하는 BFF
- UI 요구에 맞는 API 설계 가능
- 클라이언트·서버 릴리스 과정 단순화

### 14.10.1 얼마나 많은 BFF가 필요한가?

- 기본 접근 방식 (저자가 선호)
    - 클라이언트 유형별로 하나의 BFF (예: Android BFF, iOS BFF, Web BFF)
- REA 사례: Android와 iOS가 유사하지만 각각 별도의 BFF 사용
- 대안적 접근
    - 동일한 사용자 경험을 제공하는 여러 클라이언트가 하나의 BFF 공유
    - SoundCloud: Android + iOS 청취 앱 → 단일 BFF
- 단일 BFF 공유의 위험: 클라이언트 수가 늘수록 BFF가 비대해짐
- 핵심 판단 기준
    - 같은 사용자 경험인가?
    - 같은 팀이 소유하는가?
- 팀 구조가 가장 중요한 결정 요인
- REA 지침
    - “하나의 사용자 경험, 하나의 BFF”
    - UX가 크게 다르면 BFF 분리 권장
- 겉보기엔 하나의 모바일 팀이어도 실제로 Android/iOS 전문 인력이 분리돼 있다면 사실상 두 팀 → BFF 분리 고려

### 14.10.2 재사용과 BFF

- UI별 BFF의 대표적 우려: BFF 간 코드 중복 증가
- 중복 발생 지점
    - 집계 로직
    - 하위 마이크로서비스 호출 코드
- 서버 측에서 공통 기술 스택을 쓰면 중복 발견과 제거는 상대적으로 쉬움
    - 하지만 중복 제거를 위해 다시 단일 집계 게이트웨이로 회귀 가능
- 저자의 원칙
    - 마이크로서비스 내부 중복은 적극 제거
    - 서비스 간 중복은 관대하게 허용
    - 공유 코드 → 강한 결합 위험
- BFF 간 재사용이 필요할 때 선택지
    1. 공유 라이브러리
        - 비용은 낮음
        - 하위 서비스 클라이언트 라이브러리일 경우 결합 위험 큼
        - 내부 관심사 수준이면 허용 가능
    2. 새로운 마이크로서비스로 추출
        - 비즈니스 도메인 기능일 때 적합
        - 집계 책임을 하위 서비스로 이동
- 서비스 추출 비용이 낮다면 적극 고려

### 14.10.3 데스크톱과 그 이상을 위한 BFF

- BFF는 모바일 전용 패턴이 아님
- 데스크톱 웹 특성
    - 더 좋은 네트워크
    - 더 강력한 기기
    - 다수의 다운스트림 호출 감당 가능
- 따라서 웹 UI는 BFF 없이도 직접 호출 가능
- 하지만 BFF가 유용한 경우
    - 서버 측 렌더링 (SSR, 서버 템플릿)
    - 집계 결과 캐싱 (BFF 앞단에 리버스 프록시 배치)
- 장점
    - 외부 당사자가 API 변경에 취약할 때
    - 중앙 API의 하위 호환성 부담 감소
    - 클라이언트별 BFF로 영향 범위 제한

### 14.10.4 적용 시점

- 웹 UI만 있는 경우
    - 서버 측 집계가 많을 때만 BFF 고려
    - 그렇지 않으면 기존 UI 조합 패턴으로 충분
- BFF 도입을 적극 고려해야 하는 시점
    - 모바일 UI
    - 제3자에게 기능 제공
- 고려 요소
    - 추가 서비스 배포 비용
    - 하지만 관심사 분리 효과는 대부분 큼
- UI와 다운스트림 서비스를 만드는 사람이 분리돼 있다면 BFF가 훨씬 적합

## 14.11 GraphQL

- GraphQL은 클라이언트가 필요한 데이터만 원하는 형태로 요청할 수 있는 쿼리 언어
- REST 대비 장점
    - 과도한 데이터 반환(over-fetching) 방지
    - 부족한 데이터 반환(under-fetching) 방지
    - 왕복 호출 수 감소
- 예) 주문 전체가 아닌 총액, 상태, 배송 정보만 선택 요청
- 핵심 개념: 명시적 타입 정의
- 서버 측 구성 요소
    - 리졸버(resolver)
    - GraphQL 쿼리를 실제 마이크로서비스 호출로 매핑
- 마이크로서비스 환경에서는 리졸버가 여러 서비스 호출을 집계
- 활용: 중앙 집계 게이트웨이 BFF 구현 방식으로 사용 가능
- 장점
    - 클라이언트가 쿼리만 변경 → 서버 변경 불필요
    - UI 변화에 매우 유연
- 한계
    - 새로운 타입/필드 추가 시 서버 변경 필요
    - 여전히 팀 경계별 GraphQL 서버가 필요할 수 있음
- 결론
    - GraphQL은 BFF 구현의 강력한 수단
    - 다양한 UI 요구사항에 잘 대응
    - 단, 기존 우려 사항은 여전히 존재

## 14.12 하이브리드 방식

- 하나의 패턴만 고집할 필요 없음
- 실제 사례
    - 웹: 위젯 기반 분해
    - 모바일: BFF 사용
- 핵심 원칙:  사용자에게 제공되는 핵심 기능의 일관성 유지
- 도메인 로직은 반드시 해당 마이크로서비스 내부에 위치
- 주의점: 중간 계층(BFF, 게이트웨이)에 과도한 로직 집중 금물
- 결론: 중간 계층 책임과 도메인 책임 간 섬세한 균형이 핵심