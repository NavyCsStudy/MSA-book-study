> ui 는 모든 모든 ms가 고객에게 의미 있는 무언가로 통합되는 곳

## 1. 디지털을 향해

- ui 는 사용자에게 제공하고자 하는 기능을 한데 엮는 곳.
- 그렇다면 누가, 어떻게 엮을 것인가.

## 2. 소유권 모델

- 계층화 아키텍처에서 하나의 기능을 제공하기 위해 세 팀이 작업해야 함.
- 이는 전달 속도에 상당한 영향을 줌.

<img width="856" height="612" alt="image" src="https://github.com/user-attachments/assets/33bbdc0b-7d8f-423c-ba69-0a5535dd3310" />

- 엔드투엔드 기능에 대해 완전한 소유권을 가지면 더 빠르게 변경 가능.
- 각 팀은 sw 최종 사용자와 직접 접촉할 지점이 생김.

<img width="773" height="670" alt="image" src="https://github.com/user-attachments/assets/523719b1-fc49-48b7-a10f-a9a49a3e1825" />

### 2.1 전담 프론트엔드 팀 추구

- 여전히 많은 회사에서 전담 프론트엔드 팀은 일반적인 패턴.
- 전문가는 구하기 어려워서 한데 묶어서 전문 분야에만 집중하도록 만들고 싶은 유혹에 빠짐
- ui 전담 팀이 있으면 ui 를 일관성 있게 전달할 수 있음.
- 인터페이스 기술은 모놀리식 외의 방식으로 작업하기 어려울 수 있음. (예. 단일 페이지 애플리케이션)

## 3. 스트림 정렬 팀을 향해

- 이상적인 것은 엔드투엔드로 구분된 기능 중심으로 정렬된 팀.

> 스트림 정렬 팀은 가치 있는 단일 업무 스트림에 정렬.
> 고객 가치를 독립적으로 구현하고 전달할 수 있는 권한을 가짐.
> 업무를 수행하기 위해 다른 팀에 핸드오프를 할 필요가 없음.

- 백엔드 전담 팀은 사용자가 무엇을 필요로 하는지 막연하게 생각하는 경향이 있음.
- e2e 팀은 고객들과 직접적인 관계를 구축하는 것이 더 쉬움.
- 고객 중심의 kpi, okr 은 변경 사항이 고객에게 어떤 영향을 주는지 매우 명확해짐.
- 최종 사용자로부터 멀어질수록 최종 사용자의 관심과 거리가 먼 목표에 집중하게 됨.

### 3.1 전문가 공유

- 전문가를 동일한 팀에 모아두는 것은 고립된 조직.
- 전문가의 시간을 여러 팀에 사용할 수 있도록 쪼개거나, 사내 컨설팅을 위한 팀을 만들어 사소한 작업은 일반 개발자가, 어려운 작업은 진짜 전문가가 수행하여 전문가를 효과적으로 배치할 수 있음.

### 3.2 일관성 보장

- 전문가팀이 개발의 일관성을 보장할 수는 있음.
- 그런 형태의 팀이 아니어도 전문지식을 다른 개발자들과 공유하여 일관성을 보장할 수 있음.
- 또한, 일관성보다 제품의 제공 속도가 더 중요한 조직이 있을 수도 있음.

### 3.3 기술적 문제 극복

- 사용자는 가능한 한 원활하게 기능을 사용하길 원함.
- 기술은 발전했지만 20년 전과 동일한 ui가 여전히 사용됨. 사용자는 기술에는 관심이 없으므로 어떤 기기를 사용하든 동일한 인터페이스가 제공될 것을 기대함.

## 4. 모놀리식 프론트엔드

- 모든 ui 상태와 동작이 ui 자체에 정의되는 아키텍처.

<img width="763" height="535" alt="image" src="https://github.com/user-attachments/assets/e4c2f06a-7a29-4b26-9671-437e192dce44" />

- 전담 프론트엔드 팀과 spa 를 구축하는 사람들이 일반적으로 사용하는 모델.

### 4.1 적용 시점

- 단점.
  - 모놀리식의 특징으로 인해 전담 프론드엔드 팀이 필요할 수 있음.
  - 다양한 기기에 맞게 출력을 조절하기 어려움. (예. 모바일과 데스크톱 간에 조회 영역 차이)
 
- 하나의 배포 단위에서 ui 의 모든 구현과 동작을 처리하고 싶을 때 적절함.
- 계층형 아키텍처와 일치하는 조직 구조에서 적합한 패턴.

## 5. 마이크로 프론트엔드

- 여러 부분을 독립적으로 작업하고 배포하는 조직 패턴.
- 마이크로서비스와 ui 를 소유하는 기능 조직을 만들기 위한 필수 패턴.

### 5.1 구현

- 두 가지 방식이 존재.
  - 위젯 기반 분해.
  - 페이지 기반 분해.
 
### 5.2 적용 시점

- e2e 전담 기능 조직을 만들려는 경우 필수.
- ms 가 제공하는 기능이 위젯이나 페이지에 딱 맞아떨어지지 않을 수 있음.

## 6. 페이지 기반 분해

- 서로 다른 ms 에서 서로 다른 페이지들을 제공.

<img width="726" height="507" alt="image" src="https://github.com/user-attachments/assets/983bd5aa-de2b-4829-abb9-614f2558d418" />

- 팀의 변경 사항이 사용자에게 미치는 영향을 해당 팀이 쉽게 알 수 있음.

### 6.1 적용 대상

- 사용자 인터페이스가 웹인 경우에는 기본 선택지.
- spa 의 경우 사용자 경험이 저해될 수 있어 다른 패턴과 결합이 필요.

## 7. 위젯 기반 분해

- ui 의 화면에 독립적으로 변경할 수 있는 위젯이 포함됨.

<img width="740" height="524" alt="image" src="https://github.com/user-attachments/assets/9ca3df65-d76a-45f1-b320-c0956c84b46b" />

- 위젯별로 필요한 ms 와 상호작용이 이루어짐.

<img width="688" height="473" alt="image" src="https://github.com/user-attachments/assets/614e706c-0be1-42da-990a-1a13f25dacbd" />

### 7.1 구현

- ui 생성 방식에 따라 달라짐.

#### 의존성

- 위젯별로 다른 프레임워크를 사용할 수도 있음.
- 의존성 간에 중복이 발생해 페이지 로드 크기가 늘어날 수 있음.

#### 페이지 내 위젯 간 통신

- 위젯 간의 통신이 필요한 경우 사용자 정의 이벤트를 사용할 수 있음.

<img width="723" height="430" alt="image" src="https://github.com/user-attachments/assets/92f9a034-a799-4948-825d-03e93674d455" />

### 7.2 적용 시점

- 이 패턴은 여러 스트림 정렬 팀이 동일한 ui 에 쉽게 작업할 수 있게 만듬.
- 재사용 가능한 위젯을 제공할 수 있음.

## 8. 제약

- 다양한 클라이언트를 위한 접근성을 제공하기 위한 제약이 존재함.
- 모바일 네트워크의 한계, 장애인을 위한 접근성, 기기에 따른 상호작용 특성의 차이 등.
- 이를 위해 프론트엔드를 위한 백엔드 패턴도 존재.

## 9. 중앙 집계 게이트웨이

- ui 와 다운스트림 ms 사이에 위치. 모든 호출의 필터링과 집계를 수행.
- 개별 ms를 호출하는 대신 집계 게이트웨이를 사용하면 한 번의 호출로 필요한 데이터만 조회할 수 있음.

<img width="691" height="350" alt="image" src="https://github.com/user-attachments/assets/a5d8dde5-b18e-4365-bc82-ba7c9da109e7" />

<img width="708" height="460" alt="image" src="https://github.com/user-attachments/assets/0e0f690a-5f59-425e-94ca-81f510356443" />

- 이러한 게이트웨이는 배치 호출에도 도움이 됨. 10번 호출하는 대신 한 번의 배치 요청으로 처리 가능.
- 집계 게이트웨이는 클라이언트의 호출 수를 줄여주고 응답 데이터 양도 줄일 수 있음.
- 대역폭 감소, 애플리케이션 대기 시간 개선 측면에서 이점을 가짐.

### 9.1 소유권

- 호출 집계와 필터링은 ui 의 요구 사항에 따라 결정됨.
- 게이트웨이는 ui 를 만드는 팀이 소유하는 것이 타당.
- 누가 소유하든 간에 배포 병목 지점이 될 수도 있음.

### 9.2 다양한 종류의 사용자 인터페이스

- 모바일 기기는 그 특성으로 인해 더 적은 호출, 다른 데이터를 표시하길 원할 수 있음.
- 때문에 백엔드 게이트웨이는 서로 다른 두 가지 집계 및 필터링 호출 구현이 필요.
- ui 는 여러 팀에서 소유하지만, 게이트웨이는 단일 유닛이기 때문에 배포할 사이즈가 늘어나면 병목 지점이 될 수 있음.

<img width="782" height="602" alt="image" src="https://github.com/user-attachments/assets/733391e5-24b0-42ee-918d-0de9d665b25f" />

### 9.3 여러 문제

- api 키 관리, 사용자 인증, rate limit, 호출 라우팅 등도 문제임.
- 제품을 구매하는 경우 익숙한 개발 언어가 아닌 dsl 을 사용해야할 수 있음.
- 시간이 지나면서 호출 집계 패턴이 도메인 기능과 연관이 있다고 깨달을 수도 있음. 이러한 동작을 dsl 로 구현하면 제품을 변경하기 어려움.
- 따라서 전용 api 게이트웨이를 사용하려면 계속 사용하고, 필터링 및 집계 로직은 다른 곳에 두는 것을 고려할 것.

### 9.4 적용 시점

- 하나의 ui, 하나의 ms 에서는 인터페이스 전반에 유사성을 보이므로 필요치 않음.
- 중앙 게이트웨이를 도입하기로 했다면 어떤 기능을 넣을지 신중히 결정할 것.
- 사용자에게 최적화된 경험을 제공하기 위해서는 많은 팀 간에 조율이 필요할 수 있음.

## 10. 프론트엔드를 위한 백엔드(backend for frontend, bff)

- 하나의 목표, 특정 ui 를 위해 개발.
- 소유권이 여러 팀에 걸쳐져 있지 않아 병목점을 피할 수 있음.
- 사용자 경험과 밀접한 관련이 있으며 ui 와 동일한 팀에서 관리하므로 api 를 쉽게 정의하고 릴리스 과정을 단순화 할 수 있음.

<img width="760" height="620" alt="image" src="https://github.com/user-attachments/assets/1be9712f-67ab-4a2c-91e1-c50f9249c9fb" />

### 10.1 얼마나 많은 BFF가 필요한가?

- 다양한 플랫폼에서 동일한 사용자 경험을 제공하기 위한 두 가지 접근 방법.
  - 여러 유형의 클라이언트에 대해 하나의 bff를 엄격하게 유지.
  - 클라이언트마다 다른 bff.

<img width="732" height="598" alt="image" src="https://github.com/user-attachments/assets/38c4371b-ce2d-4aa2-ac4f-08244e9e53d2" />

- 단일 bff 는 클라이언트 유형이 많아질 수록 여러 문제를 처리하기 위해 비대해지기 쉬움.

<img width="718" height="610" alt="image" src="https://github.com/user-attachments/assets/b6532013-55b6-4b6a-8938-85d4b0d1f28d" />

- 클라이언트 별로 사용자 경험이 다르다면 서로 다른 방식으로 작업하고 독립적으로 배포하는 것이 좋음.

### 10.2 재사용과 BFF

- ms 간의 중복 제거는 서비스 사이의 강한 결합으로 이어질 수 있음.
- bff 간의 중복 제거도 몇가지 옵션이 있음.
  - 공유 라이브러리.
  - 공유 기능을 추출한 새로운 ms.

- 클라이언트 별로 동일한 동작을 수행하기 위해 여러 ms 를 호출하고 있다면 새로운 ms 로 추출하는 것도 방법.
 
<img width="770" height="595" alt="image" src="https://github.com/user-attachments/assets/f81ca72d-ef05-4d3e-936a-08f369332ae5" />

<img width="751" height="693" alt="image" src="https://github.com/user-attachments/assets/925c9dc8-d26a-4ea7-a986-4ff8da65fffe" />

### 10.3 데스크톱과 그 이상을 위한 BFF

- 데스크톱 앱은 일반적으로 bff 없이도 성능상의 문제는 없음.
- 서버 측에서 ui 를 생성하는 경우에는 bff 가 최적.
- 외부 api 를 관리하기 위해 bff 를 사용할 수도 있음. 제삼자가 api 를 호출할 수 없거나, 변경할 필요성이 없는 경우에 효과적.

<img width="710" height="470" alt="image" src="https://github.com/user-attachments/assets/8d96431c-62bf-46fc-9da8-e23cd5546521" />

### 10.4 적용 시점

- 서버 측에서 상당한 양의 집계가 필요할 때.

## 11. 그래프QL

- 클라이언트가 데이터에 액세스하거나 변경하기 위해 쿼리를 실행할 수 있는 쿼리 언어.
- 그래프ql 은 추가 데이터가 필요한 경우 필요한 필드만 쿼리해서 가져올 수 있음.

<img width="754" height="257" alt="image" src="https://github.com/user-attachments/assets/ef127c48-a5aa-4e17-a3ba-a3a4025756fa" />
<img width="740" height="162" alt="image" src="https://github.com/user-attachments/assets/95abacdd-bfa7-4de9-9b17-863424988ff7" />

- 원하는 필드를 정확히 요청할 수 있으며, 추가 호출도 줄일 수 있음.
- 그래프ql 구현을 위해서는 쿼리를 처리할 리졸버가 필요.
- 그래프ql을 사용한다면 집계 게이트웨이나 bff 구현에 도움이 됨.

## 12. 하이브리드 방식

- 물론 문제를 해결하기 위해 한 가지 방식만 사용할 필요는 없음.
- 핵심은 사용자 경험의 일관성.
- 물론 중간 계층에 너무 많은 동작을 넣는 것은 피해야 함.
