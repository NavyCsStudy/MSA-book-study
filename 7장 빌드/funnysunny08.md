## 7.1 지속적 통합에 대한 간략한 소개

지속적 통합(CI)의 핵심 목표는 **모든 개발자가 변경 사항을 자주 공유하고 통합해 코드베이스의 일관성과 안정성을 유지하는 것**이다.

이를 위해 CI 시스템은 다음을 자동으로 수행한다.

- 새로운 코드 커밋을 감지하고 체크아웃한다.
- 컴파일 및 테스트 실행을 통해 변경사항이 기존 코드와 잘 통합되는지 검증한다.
- 필요 시 추가 유효성 검증을 위한 산출물(artifact)을 생성한다.

CI에서는 한 번 생성한 산출물을 재사용하는 것이 중요하다. 이를 통해

- 배포되는 산출물이 테스트된 것임을 보장하고
- 동일한 코드를 여러 번 빌드하는 낭비를 줄일 수 있다.

**📍 CI의 장점**

- 빠른 피드백: 정적 분석 및 자동 테스트를 통해 코드 품질 저하를 빠르게 감지할 수 있다.
- 재현 가능한 빌드: 빌드에 필요한 모든 요소가 버전 관리되므로 동일한 산출물을 언제든 재생성할 수 있다.
- 추적 가능성 확보: 특정 배포 산출물이 어떤 커밋에서 생성되었는지 역추적 가능하다.
- 빌드·테스트 가시성: 어떤 산출물이 어떤 테스트를 통과했는지 CI 도구에서 명확히 확인할 수 있다.

### 7.1.1 실제로 CI를 하고 있는가?

CI는 빠르고 안전한 변경을 가능하게 하는 핵심 개발 관행이다. 그러나 CI 도구를 갖추었다고 해서 자동으로 CI를 하는 것은 아니다.

1. 메인라인(트렁크/마스터)에 하루 최소 한 번은 통합하는가?
    
    → 자주 통합해야 충돌과 병합 비용이 최소화된다.
    
2. 코드 변경을 검증하는 테스트가 충분히 있는가?
    
    → 테스트 없이는 자동화된 검증이 불가능하다.
    
3. 빌드가 깨지면 팀 전체가 최우선으로 수정하는가?
    
    → CI의 전제는 “항상 빌드가 녹색 상태”여야 한다는 것이다.
    

### 7.1.2 브랜치 모델

브랜치를 사용하면 다른 개발자 작업과 격리된 개발이 가능하지만, 기능 브랜치를 오래 유지하면 통합 주기가 길어지고 병합 비용이 증가하는 문제가 발생한다.

가장 이상적인 방식은 트렁크 기반 개발(Trunk-Based Development) 이다.

- 모든 개발자가 매일 트렁크(또는 마스터)에 머지한다.
- 브랜치는 하루 미만의 매우 짧은 수명을 유지하며, 동시에 활성화된 브랜치 수가 3개 미만일 때 지속적 전달 성능이 가장 높게 나타난다.

**📍 GitFlow와 오픈 소스 모델의 한계**

GitFlow와 같은 브랜치 중심 모델은 오픈 소스 프로젝트처럼 “신뢰할 수 없는” 다수의 기여자가 임시적으로 기여하고 소수의 “신뢰할 수 있는 유지관리자”가 리뷰하는 구조에서는 필연적이다.

그러나 일상적인 기업 개발 환경에서는 부적합할 수 있다.

- 커밋은 빠르게 할수록 좋다 → 오픈 소스도 패치를 빨리 머지해야 리베이스 충돌을 줄일 수 있다.
- 작은 단위로 머지하는 것이 더 바람직하다 → 대형 패치(“패치 폭탄”)는 리뷰가 어렵고 병합도 어렵다. 반면 작은 변경은 빠르고 정확하게 통합된다.

즉, 오픈 소스에는 브랜치 중심 모델이 필요하지만, 일반적인 상업 개발에서는 가능한 한 트렁크 기반 개발을 선호하는 것이 CI·CD에 유리하다.

## 7.2 빌드 파이프라인과 지속적 제공

<img width="691" height="282" alt="Image" src="https://github.com/user-attachments/assets/79862612-8d91-429e-851c-edd2eb18fe41" />

빌드 파이프라인은 소프트웨어가 개발 → 테스트 → 검증 → 운영 배포에 이르는 전체 과정을 명확하게 모델링한 구조다.

각 단계(stage)는 독립적으로 검증을 수행하며, 단계별 상태를 통해 소프트웨어 품질을 추적할 수 있다.

일반적으로 파이프라인은 다음 구조를 따른다.

1. 빠른 검증 단계 – 컴파일, 정적 분석, 단위 테스트 등 즉시 실패 가능한 빠른 테스트 실행
2. 느린 검증 단계 – 통합 테스트, 계약 테스트, 성능 테스트 등 시간이 오래 걸리는 테스트 실행
3. 배포 준비 단계 – 승인, 배포 후보 생성
4. 운영 배포 단계 – 실제 프로덕션 환경에 배포

핵심은 파이프라인 전체에서 단 하나의 산출물(artifact)만을 사용하는 것이며, 이 산출물이 점차 상위 단계로 이동하며 다양한 검증을 거쳐 최종적으로 운영에 배포된다.

CD의 핵심 관점은 다음과 같다.

- 모든 체크인은 잠재적 릴리스 후보다.
- 파이프라인은 “이 버전의 소프트웨어가 지금 어디에 있는지”를 명확히 알 수 있게 해준다.
- 어떤 단계에서 실패하면 파이프라인이 정지하고, CI/CD 도구는 어느 단계에서 무엇이 실패했는지 명확히 보여줘야 한다.

### 7.2.1 도구

CD를 완전히 지원하는 도구는 파이프라인을 정의·시각화·자동화할 수 있어야 한다.

예시: GitHub Actions, GitLab CI, Jenkins, GoCD, ArgoCD

파이프라인은 다음과 같은 특징을 가진다.

- 소프트웨어 버전이 단계(stage)를 하나씩 통과하며 상위 단계로 이동
- 자동 검증을 통과하면 다음 단계로 자동 전파
- 일부 단계는 여전히 수동 승인(manual approval)이 필요할 수 있음 (예: 운영 배포 전 최종 승인)

### 7.2.2 절충점과 환경

파이프라인 구축의 핵심 고민은 피드백 속도 vs 운영 환경 유사성이다.

- 파이프라인 초기 단계는 빠른 피드백이 중요
    - 개발자 노트북, 단위 테스트 환경 등
    - 빠르지만 운영 환경과의 차이가 크다
- 파이프라인 후반부는 운영 환경과의 유사성 확보가 중요
    - staging, pre-production 같은 운영 유사 환경
    - 신뢰도는 높지만 비용과 시간이 많이 든다

이 둘 사이의 균형이 필요하디.

운영 환경에 가까운 환경을 구축하기 어려운 경우 많은 팀이 다음 기술을 활용한다.

- 스모크 테스트
- 병렬 테스트 실행
- 프로덕션에서 수행되는 경량 테스트(예: Shadow Traffic)

### 7.2.3 산출물 생성

<img width="1216" height="654" alt="Image" src="https://github.com/user-attachments/assets/01b62ad0-ecdd-4e07-b842-d883952a2ebb" />

어떤 산출물을 생성할지는 선택한 배포 방식에 크게 좌우된다.

예: JAR/WAR, Docker Image, Helm Chart, ZIP 패키지 등.

하지만 어떤 방식을 선택하든 반드시 지켜야 하는 두 가지 규칙이 있다.

1. 산출물은 단 한 번만 빌드된다 → 환경마다 다시 빌드하면 재현성과 신뢰성이 깨진다.
2. 검증된 산출물이 곧 배포할 산출물이어야 한다 → 테스트용 산출물과 운영 배포 산출물이 다르면 의미가 없다.

따라서 가장 단순하고 올바른 접근은 다음과 같다.

- 파이프라인 초기에 아티팩트를 한 번만 빌드한다.
- 빠른 테스트(필요 시) 후 산출물을 생성한다.
- 생성된 산출물을 저장소(Artifact Repository)에 저장한다.
    - 예: Artifactory, Nexus, Docker Registry 등
- 이 동일한 산출물을 파이프라인 전 단계에서 사용하여 운영까지 전달한다.

운영 환경마다 필요한 구성(configuration)은 산출물 내부가 아니라 환경 변수, 설정 서버, 별도 구성 저장소 등을 통해 외부에서 관리해야 한다.

## 7.3 소스 코드와 빌드를 마이크로서비스에 매핑하기

### 7.3.1 거대한 리포지터리 하나와 거대한 빌드

<img width="715" height="493" alt="Image" src="https://github.com/user-attachments/assets/55e56adb-2821-4ab4-a5be-649323cafe2b" />

모든 마이크로서비스 코드가 하나의 리포지터리에 담기고 모든 코드를 한 번에 빌드하는 패턴이다.

**📍특징**

- 단일 리포지터리, 단일 빌드
- 모든 서비스의 검증 단계가 한꺼번에 실행됨
- 빌드 결과로 여러 서비스의 산출물이 동시에 생성됨

**📍장점**

- 구조가 단순하다
- 리포지터리 관리가 쉽다
- 프로젝트 초기, 단일팀 구성일 때 짧은 기간 동안은 유용할 수 있음

**📍단점**

- 한 줄 변경해도 전체 서비스가 다시 빌드·검증됨
- 변경하지 않은 서비스까지 빌드해야 하므로 비효율적
- 특정 서비스 코드 변경이 빌드를 깨면 모든 다른 서비스 개발이 중단됨
- 어떤 산출물만 배포해야 하는지 판단하기 어려움

→ 규모가 커지면 절대 피해야 할 패턴

### 7.3.2 마이크로서비스당 하나의 리포지터리(멀티레포)

<img width="846" height="546" alt="Image" src="https://github.com/user-attachments/assets/6d43aa1c-2813-4f5f-9a49-4d57ca13e38a" />

각 마이크로서비스가 별도의 리포지터리를 가지고, 각 리포지터리에 대응하는 CI 파이프라인이 존재하는 모델이다.

**📍특징**

- 서비스 단위의 소유권과 독립성 확보
- 코드 변경과 CI 빌드가 1:1 매핑됨
- 배포 단위가 명확함

**📍장점**

- 팀별 소유권이 명확하고 독립적인 배포 가능
- 특정 서비스가 고장 나도 다른 서비스 개발에는 영향 없음
- 규모가 커질수록 관리가 쉬워짐

**📍단점**

- 여러 리포지터리에 걸친 변경이 필요할 때 불편
- Git에서는 여러 리포지터리의 수정이 **원자적 커밋**으로 처리되지 않음
- 여러 리포지터리를 넘나드는 작업은 커밋 실패/성공이 분리되어 위험할 수 있음

**📍리포지터리 간 코드 재사용 문제**

<img width="1021" height="559" alt="Image" src="https://github.com/user-attachments/assets/9938e6bb-781b-4d1e-8d7e-b4f7b9b5ed83" />

- 멀티레포에서는 서비스가 다른 서비스 리포지터리의 코드를 참조할 수 없으므로 공통 코드를 **라이브러리 형태로 패키징**하고 의존성으로 포함시키는 방식을 사용한다.
- 하지만 이 방식은 다음 문제를 일으킨다.
    - 공통 라이브러리 변경 시 → 라이브러리 빌드 완료 → 모든 의존 서비스가 해당 버전을 업데이트 → **의존 서비스도 재배포** 필요
    - 이는 마이크로서비스의 **독립적 배포 가능성**을 약화시킨다.
    - 일부 서비스가 어떤 버전의 라이브러리를 사용하는지 추적하기 어려워짐

**📍서비스 간 횡단 변경**

여러 리포지터리에 걸친 변경을 피하기 위해서는 서비스 경계가 올바르게 설정되어 있어야 한다.

> 여러 리포지터리를 넘나들며 지속적으로 수정하고 있다면
> 
> 
> 경계가 잘못 설정되었을 가능성이 높다 → 서비스를 합치는 것을 고려해야 한다.
> 

### 7.3.3. 모노레포

여러 마이크로서비스가 모두 하나의 리포지터리에 존재하는 모델이다. 소스 코드가 한 곳에 있으므로 원자적 커밋과 코드 재사용이 용이하다.

**📍장점**

- 여러 서비스에 걸친 변경을 **하나의 커밋**으로 처리 가능 (원자적 변경)
- 코드 재사용이 매우 용이
- 다른 팀의 코드를 쉽게 참고할 수 있어 가시성 증가
- 대규모 조직에서는 개발 효율성이 높아질 수 있음

**📍주의점 – 원자적 커밋 vs 원자적 배포**

- 원자적 커밋이 가능하다고 해서 여러 마이크로서비스를 **한꺼번에 원자적으로 배포할 수 있다는 의미는 아님**
- 빌드·배포는 여전히 서비스 단위로 고려해야 한다.

**📍빌드 매핑**

<img width="856" height="529" alt="Image" src="https://github.com/user-attachments/assets/bd471149-54cb-444a-8015-b5bbc707a2f2" />

- 모노레포에서는 폴더 구조를 기반으로 서비스별 빌드를 매핑한다.
- 공통 폴더가 있을 경우, 그 폴더 변경 시 전체 서비스가 재빌드될 수 있음.
- 서비스가 많아질수록 빌드 의존성이 복잡해짐.

**📍소유권 모델**

<img width="899" height="809" alt="Image" src="https://github.com/user-attachments/assets/d55fb81e-c487-4886-becf-1e115fb82bb2" />

- 모노레포가 커질수록 소유권을 어떻게 정의할지가 핵심 이슈다.
- 강한 소유권: 특정 폴더/코드는 특정 팀만 수정 가능
- 약한 소유권: 누구나 수정 가능하지만 소유 팀이 리뷰 및 승인
- 공동 소유권: 모든 개발자가 모든 코드를 변경 가능
    - 소규모 팀에서는 공동 소유권이 잘 작동함
    - 규모가 커질수록 강/약한 소유권 모델 필요
- GitHub의 CODEOWNERS 같은 기능으로 경로 기반 소유자 지정 가능

**📍도구와 조직 요구사항**

대규모 모노레포는 매우 강력한 도구가 필요하다.

- 구글 → Proprietary VCS(파이퍼) + 빌드 시스템(Bazel)
- 마이크로소프트 → Git 가상 파일 시스템(VFS for Git)
- 우버·트위터·페이스북도 대규모 모노레포 운영
- 이 조직들의 공통점: 모노레포를 운영하기 위해 전용 인프라와 도구를 구축할 수 있는 기술 중심 대기업

**📍적용 대상**

- 소규모 팀에서는 모노레포가 매우 잘 작동
- 중간 규모 조직에서는 복잡성이 급격히 증가해 어려움 발생
- 초대형 조직은 자원을 투입해 극복 가능하지만 비용이 매우 큼

### 7.3.4 어떤 방식을 사용해야 할까?

저자의 결론은 다음과 같다.

- 모노레포의 장점(원자적 커밋, 코드 재사용)은 규모가 커질수록 빛이 바래고, 조직이 성장할수록 멀티레포(서비스당 리포지터리) 방식이 더 단순하고 관리가 쉽다.

또한 다음과 같은 문제가 자주 발생한다.

- 초기에는 공동 소유권의 모노레포가 잘 작동
- 시간이 지나 조직이 커지면 모노레포는 비효율 증가
- 이미 모노레포 중심으로 성장해 멀티레포로 전환하려 할 때 비용이 너무 커짐 → 매몰 비용 오류로 인해 전환 자체가 더 어려워짐

그래서 저자는 다음과 같이 결론낸다.

> 장기적으로 보면 멀티레포 방식이 더 단순하고 확장 가능하다.
> 
> 
> 따라서 가능한 경우 멀티레포를 기본 선택지로 삼는 것을 선호한다.
>