## 1 지속적 통합에 대한 간략한 소개

#### 지속적 통합(continuous integration, ci)

- 핵심 목표는 모든 사람이 서로 동기화를 유히나는 것
- 새로운 코드가 기존 코드와 잘 통합되는지 자주 확인해 목표를 달성
- ci 서버는 커밋을 감지, 코드 컴파일, 테스트 통과 등의 검증을 수행
- 정적 분석과 테스트로 코드 품질에 대한 빠른 피드백을 얻을 수 있다.
- 모든 코드가 버전 제어되므로 필요에 따라 산출물을 다시 생성할 수 있다.

### 1.1 실제로 CI를 하고 있는가?

- 우리가 ci 도구를 사용하더라도 실제로 ci를 하는 것은 아닐 수 있다.
- ci 도구를 사용한다고 ci를 올바르게 수행하는 것은 아님

#### 메인라인에 하루에 한 번 체크인하는가?
- 코드가 자주 통합되는지 확인해야 한다.
- 주기가 길 수록 통합은 점점 어려워짐

#### 변경 사항을 검증하는 일련의 테스트가 있는가?
- 테스트가 없어도 통합됐다는 사실은 알 수 있음
- 하지만 통합으로 인해 시스템 동작을 중단시켰다는 사실을 알기는 어려움

#### 빌드가 깨졌을 때 이를 수정하는 것이 팀의 최우선 일인가?
- 빌드 실패시 빌드 수정과 관련되지 않은 추가 체크인은 모두 중지해야 함
- 변경이 쌓일수록 빌드를 수정하는 데 걸리는 시간이 늘어남

### 1.2 브랜치 모델

- 브랜치를 사용하면 다른 사람을 방해하지 않고 독립적인 작업이 가능
- 기능 브랜치(feature branch)는 유용하지만 통합하는 주기가 길수록 복잡한 머지가 필요
- 대안 기술로 트렁크 기반 개발이 있음
- 모든 사람이 동일한 소스 코드, 즉 main에 머지함. 또는 아주 수명이 짧은 브랜치를 만들고 main에 머지함
- 기능 플래그 같은 기능을 이용해 변경 사항을 나중에 활성화하도록 만들 수 있다고 함
- 어떤 프로젝트를 진행하든 수명이 짧은 브랜치, 작고 읽기 쉬운 패치, 자동화된 테스트는 생산성을 높일 수 있음

## 2. 빌드 파이프라인과 지속적 제공

- 느린 테스트가 모두 성공한 후 빠른 테스트가 실패하는 것은 비효율적
- 빌드 파이프라인(build pipeline)을 통해 빠른 테스트 후 느린 테스트가 실행되도록 단계를 구성할 수 있음
- 이는 소프트웨어 진행 상황을 추적하는 좋은 방법을 제공해 소프트웨어 품질에 대한 통찰력을 제공
- 배포 가능한 산출물을 생성하고, 파이프라인 내내 이를 사용

<img width="736" height="237" alt="image" src="https://github.com/user-attachments/assets/46774d5e-db06-4597-8f0a-08e5908c303e" />

#### 지속적 제공(continuous delivery, cd)
- cd는 이러한 개념에 기반해 구축됨
- cd에서는 sw가 수동 및 자동으로 거쳐야 하는 모든 단계를 모델링하여 이러한 작업을 수행함
- ci 도구는 각 단계를 추적하고 시각화를 지원

<img width="741" height="216" alt="image" src="https://github.com/user-attachments/assets/e9de96d8-bc2d-4002-a4ba-defbc707d68a" />

> 지속적 제공(delivery) 대 지속적 배포(deploy)
> 제공은 릴리스 후보의 품질을 평가해 배포 준비되었는지 결정하는 개념
> 배포는 모든 검증을 통화한 sw를 사람의 개입 없이 자동으로 배포하는 것. 제공의 개념 확장으로 볼 수 있다.

### 2.1 도구

- cd를 완벽하게 지원하는 도구는 빌드 파이프라인을 시각화하여 sw가 운영 단계까지 이르는 전체 경로를 모델링할 수 있음

### 2.2 절충점과 환경

- 파이프라인은 개발자에게 운영 준비 상태에 대한 빠른 피드백을 제공

<img width="744" height="199" alt="image" src="https://github.com/user-attachments/assets/b26091c2-3ec8-473d-becf-37566a7754b8" />

- 개발 환경에 대한 빠른 피드백을 받을 수 있지만 운영 환경의 피드백을 받기는 어려움
- 빠른 피드백과 시간은 더 걸리지만 운영과 유사한 환경의 피드백을 받는 것 사이에서 절충점을 찾아야 함

### 2.3 산출물 생성

- 중요한 규칙 두가지
  - 첫째, 산출물은 한번만 생성한다. 매번 빌드 구성이 동일하지 않으면 문제 발생 가능
  - 둘째, 검증할 산출물이 배포할 산출물이어야 한다. 테스트, 배포 산출물이 따로 되어 있다면 신뢰할 수 없음
 
- 빌드는 파이프라인 초기에 수행하고 적절한 저장소에 저장. 이후 모든 단계에 동일한 산출물을 사용

<img width="627" height="265" alt="스크린샷 2025-11-25 오후 5 52 03" src="https://github.com/user-attachments/assets/780a9bdb-35e5-4463-9f9c-9a97b95e53d0" />

- 동일한 산출물을 여러 환경에서 사용한다면 configuration은 외부에 보관해야 함

## 3. 소스 코드와 빌드를 마이크로서비스에 매핑하기

### 3.1 거대한 리포지터리 하나와 거대한 빌드

<img width="623" height="326" alt="스크린샷 2025-11-25 오후 5 55 48" src="https://github.com/user-attachments/assets/2edc7b69-86dd-4c1a-aa93-995e3cea849b" />

- 하나의 빌드에서 여러 산출물이 생성
- 개념적으로 간단함
- 락스텝 배포라는 것만 수용하면 완벽하게 동작
- 모든 서비스를 검증하고, 빌드하기 위해 오랜 시간이 걸림
- 어떤 서비스 변경으로 인한 배포인지 알기 어려움

### 3.2 마이크로서비스당 하나의 리포지터리(멀티레포)

- 소스 코드 변경과 ci 빌드 간에 직접적으로 매핑됨
- 리포지터리 단위로 소유권 관리가 가능
- 여러 리포지터리에 걸친 변경이 필요한 경우 관리가 힘들어짐

<img width="625" height="275" alt="스크린샷 2025-11-25 오후 6 01 33" src="https://github.com/user-attachments/assets/ba20d937-7706-47b0-b8a2-51a66c86f683" />

#### 리포지터리 간 코드 재사용

- 다른 레포에서 리포지터리에서 관리되는 다른 코드에 의존하는 것을 막을 수 없음
- 간단한 해결 방법은 라이브러리를 하류 서비스의 명시적 의존성으로 만드는 것

<img width="629" height="298" alt="스크린샷 2025-11-25 오후 6 04 03" src="https://github.com/user-attachments/assets/7f61b962-cd7b-4e5a-b6fc-9c0ebd9d1109" />

- 라이브러리의 새로운 버전을 배포하려는 경우 하류 서비스 또한 재배포가 필요함
- 어떤 서비스가 라이브러리를 사용중인지 확인하기 어려움

#### 여러 리포지터리에서 작업

<img width="624" height="273" alt="스크린샷 2025-11-25 오후 6 07 57" src="https://github.com/user-attachments/assets/b4d39f4e-4dcb-4703-a294-8b09d4d81a80" />

- 여러 ms에 대한 변경이 지속적으로 발생한다면 서비스 경계가 적절하지 않거나, 서비스 간 결합을 의미할 수 있음
- 서비스를 합치는 거을 고려해볼 수 있음

#### 적용 대상

- 대규모 팀에서도 소규모 팀에서도 잘 작동함
- 서비스 경계를 넘나드는 변경을 하고 있다면 적합하지 않을 수 있음
- 버전 산출물로 패키징되는 코드에 의존하므로 코드 재사용이 복잡할 수 있음

### 3.3 모노레포

- 여러 서비스 코드가 동일한 리포지터리에 저장
- 여러 프로젝트의 소스 코드를 원자적으로 변경 가능
- 코드를 쉽게 재사용하고 다른 프로젝트에 영향을 미치는 변경을 수행할 수 있음

<img width="761" height="387" alt="image" src="https://github.com/user-attachments/assets/143132dd-6088-4953-9148-74347dc86f88" />

> 원자적 커밋 대 원자적 배포
> 원자적 커밋이 원자적 배포를 의미하는 것은 아님. 원자적 배포는 독립적 배포에 어긋남을 상기.

#### 빌드 매핑

- 모노레포의 빌드 매핑은 비교적 복잡
- 간단한 방법은 폴더를 빌드에 매핑하는 것

<img width="742" height="346" alt="image" src="https://github.com/user-attachments/assets/83edbfce-b140-48c5-83b2-e81f543bebd1" />

- 둘 이상의 빌드를 트리거하는 폴더(예를 들면 공통common)가 등장할 수도 있음
- 더 복잡해지면 이러한 의존성을 효과적으로 관리하는 베이즐과 같은 오픈 소스 도구가 필요
- 프로젝트 간 재사용은 이점이나 다른 프로젝트의 파일 하나에도 의존성을 가질 수 있다는 것은 단점

#### 소유권 정의

- 강력한 소유권
  - 특정 그룹이 코드를 소유
  - 외부자가 변경을 원하면 소유권자에게 요청해야 함
 
- 약한 소유권
  - 마찬가지로 특정 그룹이 코드를 소유
  - 그러나 외부자가 코드를 변경하고 소유권자에게 검토를 요청할 수 있음
 
- 공동 소유권
  - 모든 개발자가 코드를 소유
 
<br/>

- 보통 개발자가 적은 경우 공동 소유권을 수행
- 조직이 커지면 분명한 책임 경계를 위해 다른 소유권 모델로 변경하고 싶을 수 있음
- 몇몇 도구는 특정 디렉터리에 대한 소유권 지정을 지원. 깃허브 역시 지원함(CODEOWNERS)

#### 도구

- 구글이 모노레포를 사용하는 근거를 알고 싶다면 관련 문헌을 참고
- 우리의 조직은 구글과 같은 문제, 제약, 자원을 가지고 있지 않음. 따라서 우리의 모노레포는 구글과 다를 것

#### 모노의 범위는?

- 구글도 모든 코드가 모노레포에 저장되지는 않음
- 모노레포의 범위가 소수의 시스템에 국한될 수도 있음
- 패턴의 원래 정의와 동일하지 않을 수 있지만 팀별로 모노레포를 구성할 수도 있음

<img width="751" height="480" alt="image" src="https://github.com/user-attachments/assets/c73d35be-751b-46d3-b419-f31e9f956a84" />

- 이러한 모델은 큰 규모에서 발생하는 문제는 피하면서 모노레포의 이점을 얻을 수 있음

#### 적용 대상

- 대규모 작업이 필요한 기술 중심 대기업의 경우 모노레포를 통해 최상의 결과를 얻기 위해 노력함
- 소수의 개발자 팀에도 적합할 수 있음. 소유권 경계를 관리하고 빌드 프로세스를 단순하게 유지하기 쉬움
- 중간 규모의 경우 문제에 당면했을 때 새로운 아이디어에 투력할 여력이 부족하여 적합하지 않을 수 있음

### 3.4 어떤 방식을 사용해야 할까?

- 모노레포의 장점인 재사용과 원자적 커밋이 규모에 따라 발생하는 문제보다 중요하지는 않음
- 저자는 규모가 커질수록 멀티레포 방식이 더 간단하다고 생각함
- 모노레포는 서비스 간 변경, 불분명한 소유권 경계, 모노레포를 위한 새로운 도구가 우려스러울 수 있음
- 모노레포에서 다른 모델로 전환하는 비용도 상당할 수 있음. 투자 조금 더 한다고 잘 작동할 것이라 기대하면 안 됨
- 소유권 제어를 통해 우려를 줄일 수는 있지만 상당한 노력이 필요함
- 따라서 저자는 아직은 멀티레포를 선호한다고 말함
  - 물론 새로운 기술이 등장하면 생각이 바뀔 수는 있음 
