## 1. 마이크로서비스 살펴보기
### 마이크로서비스란
- 비즈니스 도메인에 따라 독립적으로 릴리즈 가능한 서비스
- 기능을 캡슐화하고 네트워크를 통해 다른 서비스들에 액세스하게 해준다.
- 작은 빌딩 블록을 사용해 더욱 복잡한 시스템을 구축할 수 있다.
- 직면한 문제를 해결하기 위해 다양한 옵션을 제공하는 데 중점을 둔 아키텍처

### 외부에서 봤을 때
- 마이크로서비스는 블랙박스로 취급된다.
- 적절한 프로톨콜을 사용해 비즈니스 기능을 호스팅, 소비자는 엔드포인트를 통해 기능에 접근한다.
- 사용 기술 및 인프라 같은 상세한 정보는 외부 세계에서 은폐된다.
<img width="708" height="534" alt="스크린샷 2025-09-20 오후 2 50 03" src="https://github.com/user-attachments/assets/3d6e7289-72d8-4db0-af15-1bccbe2cbdab" />

#### 정보 은닉
- 정보를 감추고 외부 인터페이스를 통해 최소한의 정보만을 노출하는 것
- 자유롭게 내부 구현의 변경이 가능하다.
- 마이크로서비스는 정보 은닉 개념을 가진다. 즉 상류 컴포넌트(업스트림)은 하류 컴포넌트(소비자)에게 영향을 미치지 않고 독립적인 릴리즈가 가능하다. 이는 마이크로서비스가 독립적으로 동작하고 릴리즈되기 위한 필수적인 특성이다.

## 2. 마이크로서비스 핵심 개념
### 2.1 독립적 배포성
- 마이크로서비스는 독립적으로 변경, 배포, 릴리즈 할 수 있다.
- 이를 위해 마이크로서비스를 느슨하게 결합시켜야 한다. 이는 서비스 간에 분명한 규약이 필요함을 뜻한다. 예를 들어 데이터베이스 공유는 이를 어렵게 하는 것 중 하나다.
### 2.2 비즈니스 도메인 중심의 모델링
- msa에서는 ddd와 동일한 개념을 사용해 서비스 경계를 정의
- 비즈니스 도메인 중심으로 서비스를 모델링하고, 마이크로서비스를 다양한 방식으로 재결합해 사용자에게 새로운 기능을 제공할 수 있다.
- 이러한 방식으로 비즈니스 기능에 대한 높은 응집도를 얻을 수 있다.
<img width="699" height="443" alt="스크린샷 2025-09-20 오후 3 19 28" src="https://github.com/user-attachments/assets/2513e50a-cdd9-46eb-843f-184210710624" />


### 2.3 자기 상태 소유
- 독립적인 배포를 위해 하위 호환성이 없는 변경을 제한해야 한다. 하위 호환성이 깨지는 변경은 하류 컴포넌트에 변경을 강요한다.
- 내부 구현 상세와 외부 계약을 명확하게 구분하면 하위 호환성이 없는 변경을 줄이는 데 도움이 된다.
### 2.4 크기
- 크기라는 개념 상황에 따라 달라진다.
#### 첫째, 얼마나 많은 마이크로서비스를 처리할 수 있는가?
- 서비스가 많아질수록 시스템 복장성이 증가
- 마이크로서비스 전환은 복잡성을 유발하는 근원. 따라서 msa 전환은 점진적으로 이루어져야 한다.
#### 둘째, 어떻게 경계를 정의하는가?
- 모든 것이 결합된 엉망진창인 상황을 피하려면 우선 어떻게 경계를 정의할지 고민해야 한다.
### 2.5 유연성
- 마이크로서비스 비용 vs 조직, 기술, 견고함 등의 유연성 사이에서 트레이드오프가 있다.
- 마이크로서비스가 많을 수록 유연성은 높아지지만 비례하여 복잡성 또한 높아진다.
### 2.6 아키텍처와 조직의 정렬
> 콘웨이의 법칙
> 시스템을 설계하는 조직은 커뮤니케이션 구조를 본떠 설계하도록 제한된다.
- 시스템에 대한 요구사항 대부분은 비즈니스 기능의 변경과 관련이 있다.
- 이러한 변경은 대부분 3계층에 걸쳐서 일어난다. 변경을 쉽게 만들고 싶다면 기술보다는 비즈니스 기능의 응집력을 선택해야 한다.
- 3계층 아키텍처의 대안은 수평적인 아키텍처, 조직이 아닌 수직적 비즈니스 라인을 따라 조직과 아키텍처를 세분화한다.
- 하나의 기능을 전담하는 팀이 존재하고 변경 범위는 하나의 팀으로 제한된다.
- 비즈니스 도메인은 시스템 아키텍처를 주도하는 원동력이 되고 변경을 쉽게 만들어준다. 또한 팀을 비즈니스 분야에 더 수월하도록 맞춰준다.
<img width="709" height="766" alt="스크린샷 2025-09-20 오후 4 04 27" src="https://github.com/user-attachments/assets/aa2a1e29-defa-4ed7-86c7-109f27b55234" />


> 스트림 정렬 팀(stream-algned team)
> 스트림 정렬 팀은 고객이나 사용자 가치를 빠르고, 안전하고, 독립적으로 구현하고 전달할 수 있는 권한을 부여받는다. 다른 팀과의 협업을 최소화하여 비즈니스 기능을 사용자게 제공할 수 있다.

## 3. 모놀리스
### 3.1 단일 프로세스형 모놀리스
- 모든 코드가 단일 프로세스로 배포되는 시스템은 전형적인 모놀리스
- 프로세스 인스턴스는 여러개일 수 있으나 모든 코드는 하나의 프로세스로 패키징
- 조직 성장에 따라 모놀리스는 함께 성장하고, 모듈식 모놀리스로 시선이 옮겨진다.
<img width="709" height="323" alt="스크린샷 2025-09-21 오후 4 40 24" src="https://github.com/user-attachments/assets/53f95dfd-ecac-4ce3-a43c-e092bab908c7" />

### 3.2. 모듈식 모놀리스
- 단일 프로세스가 별도의 모듈로 구성된 변형
- 각 모듈은 독립적으로 작업할 수 있지만 배포하려면 모두 다 합쳐져야 한다.
- 모듈 경계가 잘 정의되면 간단한 배포 토폴리지를 활용하여 높은 수준으로 병행 작업을 할 수 있다.
<img width="710" height="285" alt="스크린샷 2025-09-21 오후 4 44 02" src="https://github.com/user-attachments/assets/83aa2070-7ebd-4f7e-8186-a698579e465a" />


### 3.3 분산형 모놀리스
- 정보 은닉과 비즈니스 기능의 응집력 같은 개념을 중시하지 않는 환경에서 나타나는 모놀리스
- 강하게 결합된 아키텍처로 인해 변경 사항은 서비스 경계를 넘어 전파
- 국부적으로 보이는 변경이 시스템의 다른 부분을 손상시킬 수 있음
### 3.4 모놀리스와 전달 경합
- 점점 더 많은 사람이 같은 장소에서 작업함에 따라 서로를 방해하게 된다. 필자는 이를 전달 경합(delivery contention)이라 칭한다.
  - 서로 다른 개발자가 동일한 코드를 변경
  - 서로 다른 팀이 다른 시간에 라이브하길 원한다.
  - 누가 무엇을 소유하고 결정하는지 혼란을 겪는다.

 msa도 동일한 문제를 겪을 수 있으나 소유권 라인을 중심으로 표시될 수 있는 더 구체적인 경계를 제공하므로 이러한 문제를 줄이는 데 훨씬 유연하다.
### 3.5. 모놀리스의 장점
모놀리스는 단순하다.
- 단순한 배포 토폴로지는 분산 시스템과 관련된 많은 함정을 피할 수 있다. 모니터링, 트러블슈팅, e2e 테스팅 같은 활동도 크게 간소화 된다.
- 코드 재사용이 간단한다. 분산 시스템에서는 코드를 복사할지, 라이브러리로 분리할지, 공유 기능을 서비스로 내보낼지 경정해야 한다.

## 4. 활성화 기술
msa를 확장하면서 문제를 해결하는데 도움이 될 만한 기술을 찾아야 한다.
### 4.1 로그 집계와 분산 추적
- 로그 집계 시스템은 모든 서비스에서 로그를 수집, 집계하고 한 곳에서 분석할 수 있게 해주며 능독적 경보 메커니즘을 만드는 데 도움을 준다.
- 연관 서비스 호출에 사용되는 상관관계 ID를 구현해 이러한 도구를 더욱 유용하게 만들 수 있다. 이를 통해 호출 플로우와 관련된 로그를 쉽게 분리할 수 있다.
### 4.2 컨테이너와 쿠버네티스
- 컨테이너는 서비스 인스턴스를 위한 격리된 실행 환경을 프로비저닝하는 방법을 제공한다.
- 쿠버네티스는 하위 머신을 효율적으로 사용하면서 서비스에 요구되는 견고함과 처리량을 제공하는 방식으로 컨테이너를 분산시킨다.
- 자체 쿠버네티스 클러스터를 실행하는 것은 상당한 작업이다. 필자는 배포 관리의 오버헤드를 줄이기 위해 쿠버네티스를 사용하기로 결정했다면 관리형 서비스를 이용하는 것이 최선이라고 말한다.
### 4.3 스트리밍
- 마이크로서비스 통합을 위해 데이터 공유 방법을 찾아야 한다.
- 카프카는 영구성, 압축, 대용량 메세지를 처리할 수 있는 확장 기능 등으로 실질적인 선택지가 되었다.
### 4.4 공용 클라우드 및 서비스
- 관리형 서비스를 사용하면 데이터베이스 인스턴스, 메세지 브로커 등 제3자에게 많은 양의 작업을 넘길 수 있다.

## 5. 마이크로서비스의 장점
### 5.1 기술 이질성
- 서비스는 각기 다른 기술을 사용할 수 있다.
- 성능 개선, 데이터 저장 방식 차이를 해결하기 위해 서로 다른 언어, 데이터베이스를 사용할 수 있다.
- 새로운 기술의 리스크가 가장 낮을 것 같은 서비스에 적용하는 테스트 배드가 될 수 있다.
<img width="702" height="324" alt="스크린샷 2025-09-21 오후 5 28 36" src="https://github.com/user-attachments/assets/f6cc20ba-533b-4f8d-b5f0-f543903ccc6a" />

### 5.2 견고성
- 시스템 장애 전파를 격리할 수 있다. 서비스 경계는 명백한 격벽이 된다.
- 서비스가 견고함을 수용할 수 있게 하려면 분산 시스템이 처리해야 할 새로운 장애 원인을 이해해고 해결 방법, 사용자에게 미칠 영향을 알아야 한다.
### 5.3 확장성
- 필요한 서비스만 확장할 수 있다.
- aws의 주문형 프로비저닝 시스템을 도입하면 필요한 부분만 확장을 적용할 수 있다. 다만 아키텍처 접근 방식으로 즉각 비용 절감이 나타나는 경우는 드물다.
<img width="707" height="497" alt="스크린샷 2025-09-21 오후 5 37 55" src="https://github.com/user-attachments/assets/25da446f-773f-4f68-b62c-8c41c685f0d9" />

### 5.4 배포 용이성
- 하나의 서비스만 변경하여 다른 부분과 독립적인 배포가 가능하다. 문제가 발생해도 신속하게 롤백할 수 있다.
- 모놀리스는 코드 한 줄의 변경 사항을 릴리스하기 위해 전체 애플리케이션을 배포해야 한다.
### 5.5 조직적 정렬
- 아키텍처를 조직 구조에 맞게 더 적절히 정렬할 수 있다.
- 팀 크기와 생산성의 최적점에 도달하기 위해 하나의 코드베이스에서 일하는 인원을 최소화 할 수 있다.
- 조직 변경에 따라 서비스의 소유권도 바꿀 수 있어 아키텍처와 조직 간의 정렬 상태를 유지할 수 있다.
### 5.6 조합성(composability)
- 컴포넌트 간 상호 연관성을 다루는 시스템 설계 원칙을 말한다.
- 조합성이 높은 시스템은 고객의 요구 사항에 맞춰 다양한 방식으로 선택하고 조립해 조합할 수 있는 구성 요소를 제공한다.

## 6. 마이크로서비스의 고충
### 6.1 개발자 경험
- 로컬에서 4~5개의 서비스를 실행할 수는 있지만 그 이상도 가능할 것인가?
- 클라우드에 띄우서 개발하면 피드백 주기가 얼마나 기렁질까?
### 6.2 기술 과다
- 새롭고 다양한 기술은 그 모든 기술을 이해하는 데 어려움을 준다.
- msa의 점진적 증가는 시간이 지남에 따라 새롭게 나타날 더 나은 기술, 작업 방식을 확보할 수 있는 이점을 준다.
### 6.3 비용
- 단기적으로 비용이 증가할 가능성이 높다.
- 조직 변경이 발생하면 새로운 개념을 배우고 효과적으로 사용하는 방법을 익히는 데 시간이 걸린다.
- 필자는 msa는 비용 절감에 관심을 둔 조직에는 적합하지 않다고 한다. 대신 고객에게 제공할 수 있는 더 많은 기능을 병행 개발하는 데 관심이 있다면 더 많은 수익을 얻는 데 도움이 된다 말한다.
### 6.4 리포팅
- 데이터가 논리적으로 분리된 여러 스키마에 분산되어 있어 리포팅을 실행하기 어려워진다.
- 스트리밍을 사용할 수 있지만 새로운 개념과 기술의 도입하거나 중앙의 리포팅 데이터베이스에 발행하는 작업이 추가로 필요할 수 있다.
<img width="697" height="371" alt="스크린샷 2025-09-21 오후 6 30 54" src="https://github.com/user-attachments/assets/6ad9869f-496a-4ce1-b519-816a535ff03d" />

### 6.5 모니터링과 문제 해결
- msa에서 하나의 프로세스만 cpu 사용량이 100%를 유지한다면 누구를 깨워야 할까?
### 6.6 보안
- msa에서는 많은 정보가 네트워크를 통해 교류된다. 이로 인해 중간자 공격의 가능성도 높아진다.
- 전송중인 데이터와 서비스 엔드포인트를 보호해 권한 있는 당사자만 사용할 수 있도록 보장하는 데 많은 주의를 기울여야 한다.
### 6.7 테스팅
- e2e 테스트는 작성하고 유지하는 것이 어렵다. 하지만 사용자와 동일한 방식으로 시스템을 사용하여 얻는 확신 때문에 수행할 만한 가치가 있다.
- msa에서는 e2e 테스트 범위가 늘어난다.
  - 테스트 시나리오에 맞게 배포하고 적절히 구성해야 하는 여러 프로세스에서 테스트를 실행해야 한다.
  - 인스턴스가 죽거나 실패한 배포에 대한 네트워크 타임아웃이 발생하는 등의 환경적 이슈로 인해 테스트가 실패하는 거짓 음성 결과에도 대비해야 한다.
### 6.8 지연 시간
- 단일 프로세스 내에서만 이동하던 정보를 네트워크를 통해 직렬화하고 전송하며 역직렬화해야 한다. 이 모든 것은 시스템의 지연 시간(latency)를 악화시킨다.
### 6.9 데이터 일관성
- 분산 시스템에서는 데이터베이스 트랜잭션에 의존할 수 없다.
- 사가(saga)나 최종적 일관성(eventual consistency) 같은 개념을 사용해야 할수도 있다. 이러한 개념은 시스템의 데이터에 대한 사고방식을 근본적으로 바꾸도록 요구하기도 하며, 기존 시스템을 마이그레이션할 때는 매우 힘겨운 일이 되기도 한다.

## 7. 마이크로서비스를 사용해야 하는가?
### 7.1 마이크로서비스가 적합하지 않은 곳
- 도메인 모델이 안정화되지 않은 제품
  - 도메인 모델이 변화하면 서비스 경계가 변경된다. 경계를 넘어 변경을 조정하는 작업은 비용이 많이 든다.
- 소프트웨어를 고객이 배포하고 관리하는 경우
### 7.2 마이크로서비스가 적합한 곳
- 더 많은 개발자가 서로 방해하지 않고 동일 시스템을 작업해야 하는 곳
- 24시간 내내 작동해야 하는 제품
- 클라우드 플랫폼을 최대한 활용해야 하는 제품
