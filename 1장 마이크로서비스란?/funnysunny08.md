## 1.2 마이크로서비스의 핵심 개념

### 1.2.1 독립적 배포성

- 독립적 배포성이란, 다른 마이크로서비스를 배포하지 않고도 마이크로서비스를 변경하고, 배포하고, 사용자에게 릴리스할 수 있다는 개념
- 독립적 배포를 위해서는 마이크로서비스를 느슨하게 결합시켜야 한다.
    - 다른 서비스를 변경하지 않고도 한 서비스를 변경할 수 있어야 한다는 의미

### 1.2.2 비즈니스 도메인 중심의 모델링

- 마이크로서비스 아키텍처에서는 비즈니스 도메인을 중심으로 서비스를 모델링함으로써 새로운 기능을 좀 더 쉽게 출시하고 마이크로 서비스를 다양한 방식으로 재결합해 사용자에게 새로운 기능을 제공할 수 있다.
- 서비스를 비즈니스 기능 단위로 (수직으로) 처음부터 끝까지 한 조각으로 만들면, 비즈니스 기능을 최대한 효율적으로 변경하도록 아키텍처를 배치할 수 있다.
- 아래의 사진처럼 기술적 기능의 높은 응집력보다는 비즈니스 기능의 높은 응집력을 우선시하자.
    
    <img width="659" height="589" alt="Image" src="https://github.com/user-attachments/assets/16b1ba74-23bb-4bfe-9e06-4e7e04658e97" />
    

### 1.2.3 자기 상태 소유

- 공유 데이터베이스 사용 X
- 마이크로서비스에 어떤 데이터를 공유하고 감출지 결정하는 능력을 제공하므로 내구 구현과 외부 계약을 명확히 분리할 수 있게 해준다.
- 데이터와 동작을 캡슐화하면 비즈니스 기능에 대한 높은 응집력을 얻을 수 있고, 서비스의 데이터베이스를 숨김으로써 결합도를 낮출 수 있다.

### 1.2.4 크기

- 마이크로서비스는 쉽게 이해할 수 있는 크기로 유지돼야 한다.

## 1.3 모놀리스

### 1.3.1 단일 프로세스형 모놀리스

- 모든 코드가 하나의 프로세스로 패키징되어, 단일 프로세스로 배포되는 시스템

### 1.3.2 모듈식 모놀리스

<img width="512" height="380" alt="Image" src="https://github.com/user-attachments/assets/1c95ad5f-51a1-46ec-bf02-a76631741319" />

- 단일 프로세스가 별도의 모듈로 구성된 변형
- 각 모듈은 독립적으로 작업할 수 있지만 배포하려면 모두 다 합쳐져야 한다.
- 모듈 경계가 잘 정의된다면, 훨씬 더 간단한 배포 토폴로지를 활용함으로써 분산된 마이크로서비스 아키텍처의 문제를 피하면서도 높은 수준으로 병행 작업을 할 수 있다.
- 단, 데이터베이스가 코드 수준으로 분해되지 않아서 미래에 모놀리스를 분해하려면 상당한 어려움에 직면한다.

### 1.3.3 분산형 모놀리스

- 분산형 모놀리스는 여러 서비스로 구성된 시스템이지만, 어떤 이유로든 전체 시스템을 함께 배포해야 한다.
- 일반적으로 정보 은닉과 비즈니스 기능의 응집력 같은 개념을 그다지 중시하지 않는 환경에서 나타난다.

### 1.3.4 모놀리스와 전달 경합

- 많은 사람들이 같은 장소에 작업함에 따라 서로를 방해야하게 된다 → 전달 경합

### 1.3.5 모놀리스의 장점

- 훨씬 단순한 배포 토폴로지
- 모니터링, 문제 해결, 엔드투엔드 테스팅 간소화
- 내부 코드 재사용

## 1.4 활성화 기술

마이크로서비스에 유용한 기술

### 1.4.1 로그 집계와 분산 추적

- 로그 집계 시스템을 사용하면 모든 서비스에서 로그를 수집하거나 집계하고 한 곳에서 분석할 수 있으며, 능동적인 경보 메커니즘 일부도 만들 수 있다.
- 연관된 서비스 호출에 사용되는 단일 ID인 상관관계 ID를 구현해 분산된 환경에서 추적하는 데 도움을 줄 수 있다.
- 이 도구들은 여러 서비스를 경유하는 추적을 분석하고, 병목점을 감지할 수 있게 해준다.

### 1.4.2 컨테이너와 쿠버네티스

- 각 마이크로서비스 인스턴스를 격리해 실행하는 것은 이상적이다.
- 가상화는 기존 하드웨어에 격리된 실행 환경을 만드는 방법이지만, 일반적인 가상화 기술은 마이크로서비스 크기를 고려할 때 상당히 무거울 수 있다.
- 반면에 컨테이너는 서비스 인스턴스를 위한 격리된 실행 환경을 프로비저닝하는 훨씬 더 가벼운 방법을 제공하므로, 많은 아키텍처에서 비용 효율도 훨씬 더 높을 뿐 아니라 새로운 컨테이너 인스턴스의 시작 시간도 더 빨라진다.
- 쿠버네티스와 같은 컨테이너 오케스트레이션 플랫폼은 하위 머신을 효율적으로 사용하면서 서비스에 요구되는 견고함과 처리량을 제공하는 방식으로 컨테이너를 분산시킨다.

### 1.4.3 스트리밍

- 마이크로서비스 간에 데이터를 공유하는 기술
- 대용량 데이터를 쉽게 스트리밍하고 처리
- e.g. 카프카

### 1.4.4 공용 클라우드 및 서버리스

- 구글 클라우드, 마이크로소프트 애저, AWS → 다양한 관리형 서비스와 배포 옵션 제공
- 서버리스: 하부 머신을 숨겨 더 높은 추상화 수준에서 작업할 수 있게 해준다.

## 1.5 마이크로서비스의 장점

### 1.5.1 기술 이질성

- 각 마이크로서비스에 서로 다른 기술을 사용할 수 있다.
- 모놀리식 애플리케이션에서는 변경 사항이 시스템의 많은 부분에 영향을 미치기 때문에 새로운 기술을 시도하기 어렵다.
    - 마이크로서비스를 사용하면 기술을 더 빨리 채택할 수 있고 새로운 기술 발전이 어떻게 도움되는지 이해할 수 있다.
- 내부 구현 기술이 숨겨져 있다는 사실은 기술 업그레이드를 더욱 쉽게 만든다.

### 1.5.2 견고성

- 시스템의 구성요소 중 하나가 고장날 수 있지만, 그 고장이 연속적으로 발생하지 않는 한 문제를 격리하고 나머지 시스템은 계속 작동할 수 있다.
    - 이러한 서비스 경계는 명백한 벌크헤드가 된다.
- 단 마이크로서비스 시스템이 향상된 견고함을 수용할 수 있도록 하려면 분산 시스템이 처리해야 할 새로운 고장 원인을 이해해야 한다.

### 1.5.3 확장성

- 대규모 모놀리식 서비스에서는 모든 것을 함께 확장해야 한다.
    - 마이크로서비스에서는 확장이 필요한 서비스만 확장할 수 있다.

### 1.5.4 배포 용이성

- 하나의 서비스만 변경하고 시스템의 다른 부분과는 독립적으로 배포할 수 있다.
- 코드를 더 빠르게 배포할 수 있으며, 문제가 발생하더라도 빠른 롤백을 수행해 해당 문제를 개별 서비스로만 제한할 수 있다.

### 1.5.5 조직적 정렬

- 마이크로서비스를 이용하면 아키텍처를 조직 구조에 맞게 더 적절히 정렬할 수 있다.

### 1.5.6 조합성

- 재사용

## 1.6 마이크로서비스의 고충

- 개발자 경험
    - JVM과 같은 런타임은 하나의 개발자 머신에서 실행 가능한 마이크로서비스의 수를 제한한다.
    - 이로 인해 한 머신에서 전체 시스템을 실행하는 것이 어려워진다.
    - 간단한 해결법으로 개발자가 작업해야 하는 시스템의 영역 범위를 제한하는 것이 있다.
- 기술 과다
    - 다양한 기술이 가져올 비용과 사용하는 기술의 범위 및 복잡성을 신중하게 저울질해야 한다.
- 비용
    - 단기적으로는 여러 요인으로 인해 비용이 증가할 가능성이 높고, 팀이나 조직에 변경이 발생하면 단기적으로 속도가 느려질 수 있다.
    - 비용 절감을 위한 조직보다는 더 많은 고객에게 다가가거나 더 많은 병행 개발을 원하는 조직에 적합하다.
- 리포팅
    - 데이터가 논리적으로 분리된 여러 스키마에 분산돼 있기 때문에 리포팅을 실행하기 어려워졌다.
- 보안
    - 데이터가 각 서비스 사이의 네트워크를 통해 교류됨으로써 더 많이 외부로 노출되고 중간자 공격으로 조작될 가능성이 높아진다.
- 테스팅
    - MSA에서 엔드투엔드 테스트의 범위는 상당히 늘어난다.
    - 또한 서비스 인스턴스가 죽거나 실패한 배포에 대한 네트워크 타임아웃이 발생하는 등의 환경적 이슈로 인해 테스트가 실패하는 거짓 실패 결과에도 대비해야 한다.
    - 테스트의 비용이 더 들지만 과거와 같은 수준의 확신을 얻지 못한다.
- 지연 시간
    - 많은 네트워크를 통해 직렬화하고 전송하며 역직렬화해야 하기 때문에 지연 시간을 악화시킨다.
- 데이터 일관성
    - 해결책: 사가, 궁극적 일관성

## 1.7 마이크로서비스를 사용해야 하는가?

- 적합하지 않은 곳
    - 새로운 제품, 스타트업 → 도메인이 변화하는 시기
    - 팀이 어느정도 규모가 있어야 함
- 적합한 곳
    - 많은 개발자가 독립적으로 작업하길 원하는 곳
    - SaaS
        - 독립적 릴리스
        - 필요에 따라 마이크로서비스를 확장하거나 축소
    - 클라우드 플랫폼 최대한 활용 가능
    - 다양한 기술 채택 가능