## 4. 어떤 배포가 적합할까?

> 더 진행하기 전에 현재 하고 있는 일이 효과 있다면 계속하라.
> 유행에 따라 기술적인 결정을 내리지 말라.

- msa의 배포 원칙 중 가장 중요한 측면은 격리를 보장하는 것.
- 서비스당 전용 물리 머신을 이용하는 것은 많은 비용이 들고, 몇몇 도구는 이 방식에서 사용하지 못할 수 있음.

#### 샘의 정말 기본적인 경험 규칙

1. 고장 나지 않았다면 고치지 말라.
2. 당신이 만족한다고 느끼는 만큼 통제권을 포기한 다음 조금씩 더 포기하라. 모든 작업을 PaaS에 맡길 수 있다면 그렇게 하고 만족하라.
3. ms의 컨테이너화가 쉬운 일은 아니지만, 격리 비용에 대한 우수한 절충안이다. 발생하는 작업에 대한 어느 정도의 제어권과 로컬 개발에 이점을 가질 수 있다.

- 만약 배포 모델로 PaaS가 적합하다면 모든 작업을 플랫폼에 맡기고 제품에 더 많은 시간을 쏟을 것.
- 그렇지 않다면 컨테이너화가 가야할 길임.

## 5. 쿠버네티스와 컨테이너 오케스트레이션

### 5.1 컨테이너 오케스트레이션에 대한 사례

- 쿠버네티스는 컨테이너 오케스트레이션 플랫폼, 컨테이너 스케줄러로 다양하게 설명됨.
- 컨테이너는 하부 머신에 자원들을 격리시키며 생성됨.
- 컨테이너 오케스트레이션 플랫폼은 컨테이너 워크로드가 실행되는 방법과 위치를 다룸.
- 가용한 자원을 찾고, 필요한 경우 재할당하는 작업을 처리함.
- 컨테이너 오케스트레이션 플랫폼은 기대 상태를 관리해 컨테이너들이 예상된 상태가 유지되도독 함.
- 워크로드를 분산하는 방법을 지정할 수 있고, 리소스 사용률, 프로세스 간 지연 시간 등을 최적화할 수 있음.

### 5.2 쿠버네티스의 개념 엿보기

<img width="775" height="512" alt="image" src="https://github.com/user-attachments/assets/ad91514a-b833-483b-b079-67fb2f52b0b0" />

- 쿠버네티스는 두 부분으로 구성됨.
  - 첫째, 노드. 워크로드가 실행될 머신 집합.
  - 둘째, 컨트롤 플레인. 노드를 관리하는 일련의 제어 소프트웨어.
 
- 노드는 내부적으로 물리, 가상 머신을 실행할 수 있음.
- 파드(pod)라고 불리는 것을 스케줄링하며 이는 함께 배포될 하나 이상의 컨테이너로 구성.
- 일반적으로 파드 안에는 하나의 컨테이너(ms 인스턴스)만 존재함. 드물지만 여러 컨테이너를 함께 배포하는 것이 합리적인 경우도 있음.
- 서비스(service)라는 개념은 라우팅 엔드포인트로 간주할 수 있으며, 클러스터 내에서 라우팅을 처리함.
- 파드는 여러 이유료 종료될 수 있으나, 서비스는 계속 유지됨.
- 서비스는 호출과 파드를 상호 라우팅하며, 파드를 종료하거나 시작할 수 있음.

<img width="752" height="489" alt="image" src="https://github.com/user-attachments/assets/e93e3a75-8c15-4e48-8bd0-18c382293083" />

- 레플리카셋(replica set)은 파드들의 기대 상태를 정의. 쿠버네티스가 이를 보고 처리.
- 디플로이먼트(deployment)는 파드와 레플리카셋에 대한 변경 사항을 적용하는 방법.
  - 롤링 업그레이드 문제, 롤백, 노드 수 확장 등의 작업을 수행.
 
- 따라서 ms를 배포하려면 ms 인스턴스를 포함할 파드를 정의.
- 서비스를 정의해 쿠버네티스가 ms에 액세스하는 방법을 알려줌.
- 디플로이먼트를 사용해 실행 중인 파드에 변경 사항을 적용.

### 5.3 멀티테넌시와 페더레이션

- 조직의 부서마다 다양한 자원에 대해 서로 다른 수준의 제어가 필요할 수 있음.
- 쿠버네티스에 이와 같은 기능은 내장되어 있지 않기 때문에 다른 방법이 필요함.
- 첫째. 해당 기능을 제공하는 쿠버네티스 위에 구축된 플랫폼을 채택하는 것.
  - 이 경우 해당 벤더의 플랫폼을 사용하는 방법도 알아야 할 필요가 있음.
 
- 둘쨰, 페더레이션 모델(federated model)을 고려하는 것.
  - 페더레이션을 사용하면 여러 개로 분리된 클러스터를 가질 수 있음.
  - 이 클러스 위에 sw 계층이 있어 필요하다면 모든 클러스터에 변경을 가할 수 있음.
  - 페더레이션 소프트웨어는 유휴 노드를 활용하기 위해 특정 클러스터를 위해 파드를 실행할 수 있어야 함.
  - 여러 클러스터를 보유하면 도움이 되지만 비용이 동반됨.

<img width="637" height="436" alt="스크린샷 2025-12-25 오후 8 58 59" src="https://github.com/user-attachments/assets/7eafca49-9387-4204-9e94-fc71e4982283" />

### 5.4 클라우드 네이티브 컴퓨팅 재단

- cncf는 클라우드 네이티브 개발을 촉진하는 프로젝트의 생태계를 큐레이션하는 데 중점을 둠.
- 따로따로 개발되고 있는 프로젝트들의 공통 표준 및 상호 운용성을 개발할 수 있도록 함.
- 쿠버네티스의 성공에 큰 역할을 함.

### 5.5 플랫폼과 이식성

- 쿠버네티스가 제공하는 기능은 컨테이너 워크로드를 실행할 수 있는 것 뿐.
- 대부분은 지원 sw를 설치해 자체 플랫폼을 구축하게 됨.
- 한 클러스터에서 다른 클러스터로 이식시키는 것은 이론적으로는 가능하지만 실제로는 어려울 수 있음.

### 5.6 헬름, 오퍼레이터, CRD!

- 제삼자 애플리케이션의 배포 및 수명주기는 어떻게 관리해야 하는가?
- 아이디어는 카프카용 패키지와 유사한 것을 만들고 블랙 박스 같은 방식으로 쿠버네티스 클러스터에서 실행하는 것.
- 오퍼레이터와 헬름은 이 분야에서 유명한 솔루션.
- 헬름. 쿠버네티스틔 '누락된 패키지 매니저'라고 자칭함.
- 오퍼레이터. 애플리케이션의 지속적인 관리에 중점을 둠.
- CRD(Custom Resource Definition, 사용자 지정 리소스 정의). 핵심 쿠버네티스 api를 확장해 클러스터에 새로운 동작을 연결할 수 있음.
  - cli, 액세스 제어 등과 원활하게 통합됨.
  - 구성 정보의 비트 관리부터 카프카와 같은 클러스터 기반 sw까지 모든 작업에 crd를 사용할 수 있음.
 
### 5.7 Knative

- 쿠버네티스를 사용해 개발자에게 FaaS 방식의 워크플로를 제공하는 것이 목표인 오픈 소스 프로젝트.
- 쿠버네티스의 복잡성을 숨기고 FaaS 개발자 경험을 쿠버네티스에 가져오는 것이 목표.
- Knative는 다양한 서비스 메시를 연결할 수 있지만, 현재는 istio만 안정적인 것으로 간주할 수 있음.

### 5.8 미래

- 쿠버네티스가 개발자 친화적인 경험을 제공하지는 않음.
- 그러나 지속적인 추상화로 하여금 어디에나 쿠버네티스가 있지만 그 사실을 인지하지 못한 채 사용하게 되는 순간이 올 것임.

### 5.9 사용해야 할까?

- 몇 가지 지침.
- 첫째. 자체 쿠버네티스 클러스터를 구현, 관리하는 것은 힘든 작업.
- 둘째. 공용 클러스터를 사용할 수 있다면 aws와 같은 완전 관리형 솔루션이 더 나을 수 있음.
- 셋째. 쿠버네티스를 사용하기 전 일부 관리자와 개발자가 쿠버네티스를 사용하도록 할 것. 실제로 쿠버네티스를 사용하기 전에 minikube 같은 것으로 경험을 쌓는 것이 좋음.
- 넷째. 남들이 한다고 따라하지 말 것. 자체 평가를 수행하여 조직에 맞는 적절한 선택을 할 것.

## 8.6 점진적 제공

- 성과가 좋은 회사가 성과가 낮은 회사보다 더 자주 배포하고, 변경 실패율도 낮다고 함.
- 이러한 생각은 점진공 제공(progressive delivery)이라는 가치 아래에 있음.

### 6.1 배포와 릴리스의 분리

> 배포는 sw의 일부 버전을 특정 환경에 설치될 때 발생하는 것이다.
> 릴리스는 시스템이나 그 일부(예. 기능)를 사용자가 사용할 수 있도록 만드는 것이다.

- 이러한 개념의 분리는 사용자에게 실패 없이 운영 환경 설정에서 sw가 작동하도록 만들 수 있음.
- 블루 그린 배포에서 새로운 버전(블루)와 이전 버전(그린)을 함께 배포. 새 버전이 의도한대로 동작한다면 고객이 새로운 버전을 보도록 리다이렉션. 리다이렉션 이전에 문제가 발생해도 고객에게는 영향을 미치지 않음.

### 6.2 점진적 제공으로

- 폭발 반경을 세밀하게 제어하면서 지속적으로 제공하는 것.
- 점진적 제공은 지속적 제공의 확장이자 새로 출시된 sw의 잠재적 영향을 제어할 수 있는 기능을 제공하는 기술.

### 6.3 기능 토글

- 기능을 끄거나 켜는 데 사용할 수 있는 토글. 배포된 기능을 숨길 수 있음.
- 베타 테스터 그룹에게는 기능을 켜고, 다른 그룹에게는 기능을 숨길 수 있음. 카나리아 롤아웃을 구현하는 데 도움이 됨.

### 6.4 카나리아 릴리스

> 실수는 사람이 할 수 있는 일이지만, 정말 일을 망치러면 컴퓨터가 필요하다.

- 실수로 인한 영향을 제한할 수 있는 기술 중 하나.
- 일부 제한된 고객에게만 새로운 기능을 제공. 카나리아 그룹에서 기능이 잘 작동하면 모든 사람에게 새 버전을 롤아웃.
- 기능 토글을 이용해 해당 기능을 끄고 켬. 또는 두 버전의 ms를 병렬로 실행하여 토글을 이용해 새 버전 또는 이전 버전으로 라우팅. 이 경우 카나리아 구현은 ms가 아닌 라우팅/네트워킹 경로 어딘가에 존재해야 함.

### 6.5 병렬 실행

- 카나리아 릴리스는 요청이 이전 버전 또는 새 버전 둘 중 하나에서 처리되기 때문에 두 버전이 동일한 요청을 어떻게 처리하는지 비교할 수 없음.
- 병렬 실행은 서로 다른 구현이 요청을 처리하게 만들고 결과를 비교할 수 있음.
- 보통 구 버전이 신뢰할 수 있는 결과로 간주되며, 기능의 특성에 따라(주문 같은 기능들) 구현 사이의 세밀한 차이를 신중하게 생각해야 함.
