## 1. 테스트 유형

<img width="740" height="279" alt="image" src="https://github.com/user-attachments/assets/7a8852d7-cfec-4cd1-89e9-2c16c80a4fab" />

- 사분면 하단의 테스트는 개발자가 시스템을 구축하는 데 도움을 주는 테스트. 성능 테스트와 단위 테스트가 여기에 속함.
- 상위 절반은 비기술 이해관계자가 시스템의 작동 방식 이해를 돕는 것을 목표로 하는 테스트. e2e 테스트, 수동 테스트가 여기에 속함.
- 이러한 테스트 통과는 sw 배포 여부를 결정하는 진입 조건.
- 이전에는 수동 테스트로 해결해야 했던 영역이 기술이 성숙되면서 점점 자동화되고 있음. 이러한 발전은 덜 반복적인 탐색 테스팅에 집중하는 검증자의 시간을 확보할 기회로 이어짐.

## 2. 테스트 범위

<img width="748" height="346" alt="image" src="https://github.com/user-attachments/assets/1a05e6bf-3666-446a-badc-85da6aa5d81b" />

> 마이크 콘의 테스트 피라미드

- 피라미드 상위로 갈수록 테스트 범위가 증가하고, 테스트 중인 기능이 작동한다는 확신도 커짐.
- 그러나 테스트 시간과 피드백 주기 시간이 늘어나고, 어떤 기능으로 인해 실패했는지 파악하기가 어려워짐.
- 피라미드 하위는 피드백 주기가 짧고, 고장난 기능을 쉽고 짧게 발견할 수 있음. 더 작은 범위의 테스트는 정확한 코드 라인까지 내려가 어떤 것이 고장났는지 파악하기 쉬움.
- 격리된 테스트는 고장의 원인을 파악하기 쉽지만 전제 시스템이 잘 작동한다는 것을 보장하지는 않음.

***

- 해당 모델의 문제는 단위, 서비스, ui는 각자에게 다른 의미를 가진다는 점.
- 한 줄의 코드만 테스트하는 것은 단위 테스트라는 데 많은 사람이 동의할 것. 여러 함수나 클래스를 테스트하는 것을 무엇이라 부를지는 각자 의견이 다를 수 있음.
- 중요한 것은 어떻게 부르든 다양한 목적을 위해 자동화된 테스트를 원한다는 점.

<img width="737" height="328" alt="image" src="https://github.com/user-attachments/assets/c0f099c4-bfb5-4f9b-93c6-56613a2e502f" />

> 이제부터 살펴볼 예시

### 2.1 단위 테스트

- 일반적으로 단일 함수 또는 메서드 호출을 테스트.
- 주로 개발자에게 도움이 되는 테스트.

<img width="755" height="325" alt="image" src="https://github.com/user-attachments/assets/1decfd1f-667e-4398-94b8-0a4334a49ce8" />

- 핵심 목표는 기능이 정상적으로 작동하는지에 대한 빠른 피드백을 제공하는 것.
- 또한 코드 리팩터링을 지원하는 데도 중요함.

### 2.2 서비스 테스트

- 모놀리식에서는 service 클래스를 테스트. ms 에서는 개별 서비스의 기능을 테스트하는 것이 됨.
- 단위 테스트에 비해 기능이 잘 작동하는 것을 확신할 수 있음.
- 사용자 인터페이스를 우회한 테스트이기 때문에 테스트 범위는 여전히 어느 정도 격리되어 있음. 테스트 실패의 원인도 해당 ms로 제한됨.

<img width="739" height="321" alt="image" src="https://github.com/user-attachments/assets/1d015c63-9db4-4f57-8da1-bec2059484d9" />

- db를 사용하거나 스텁을 사용하는 대신 다운스트림 서비스와 통신하기로 결정한다면 테스트 시간이 그만큼 늘어남.
- 테스트 범위가 늘어날수록 실패의 원인을 찾기도 어려워짐.

#### 2.3 엔드투엔드 테스트

- 시스템 전체에 대한 테스트.
- 운영 환경의 코드를 많이 다루기 때문에 테스트 성공이 기능이 잘 작동한다는 것에 확신을 가질 수 있음.

<img width="746" height="366" alt="image" src="https://github.com/user-attachments/assets/b707dbb8-ef13-499a-9bd7-2304accca1ab" />

> 참고. 저자는 통합 테스트가 각자에게 다른 의미를 가질 수 있기 때문에 통합 테스트라는 용어 대신 서비스, 엔드투엔드 테스트라 설명하였음.

### 2.4 절충안

- 테스트를 실행하는 데 너무 오랜 시간이 걸리면 일부 테스트를 더 작고 빠른 단위 테스트로 대체할 것.
- 운영 단계에서 버그가 발견된다는 것은 테스트를 놓치고 있다는 신호일 수 있음.
- 테스트 구성이 역피라미드 모양인 경우 테스트로 인해 빌드가 오래 걸리고 피드백 주기가 매우 길어질 수 있음.

## 3. 서비스 테스트의 구현

- ms에서 하나의 서비스만 테스트를 하고 싶다면 다운스트림 서비스를 어떻게 처리해야하는가?

### 3.1 목 또는 스텁 사용

- 다운스트림 서비스를 스텁으로 만든다면 어떤 호출을 하든 항상 15,000원을 반환하는 방식일 것.
- 목으로 만든다면 실제 호출이 이루어졌는지 확인. 단, 실제 호출을 확인하는 방식은 깨지기 쉬움.

### 3.2 더 영리한 스텁 서비스

- 스텁 서비스를 띄위기 위한 다양한 방법이 존재.
- 간단한 프로그래밍을 통해 스텁 서버스를 띄우고 이를 이용한 테스트가 통과하면 곧바로 배포하는 방식.

## 4. 까다로운 엔드투엔드 테스트의 구현

- ui를 통해 노출되는 기능은 다수의 ms에 의해 전달됨.
- 즉, e2e 테스트는 필요한 모든 ms를 배포해야 한다는 의미.
- 기능이 잘 작동한다고 확신할 수 있으나 테스트에 오랜 시간이 걸리고, 문제 원인 파악이 어려워짐.

<img width="744" height="134" alt="image" src="https://github.com/user-attachments/assets/2aa146e9-cb5f-4384-8b71-9a289dab5b3b" />

- 그럼 e2e 테스트시에 각각의 ms는 어떤 버전을 사용해야 하는가?
- 서로 다른 ms 간에 e2e 테스트가 많은 부분이 중복된다면 배포하려는 노력도 중복됨.
- 이러한 문제는 여러 파이프라인을 하나의 e2e 테스트 단계로 팬인(fan-in)하여 처리 가능.

<img width="751" height="400" alt="image" src="https://github.com/user-attachments/assets/1de0b067-e760-4c37-b550-10f043fbc136" />

### 4.1 불안정하고 깨지기 쉬운 테스트

- 하나의 ms 라도 다운되면 테스트와 무관한 실패가 발생할 수 있음.
- 테스트 구성 요소가 많아질수록 테스트는 불안정해짐.
- 불안정한 테스트가 쌓이면 실패하는 테스트 집합에 대한 불신이 생김. 잘못된 것에 익숙해지면 정상적인 것으로 받아들이는 문제가 발생할 수 있음.
- 이와 같은 문제가 발생하기 전에 불안정한 테스트는 제거해야 함.
- 마틴 파울러는 불안정한 테스트를 수정할 수 없다면 제거하는 방식으로 관리해야 한다고 말함.
- 기본 환경을 안정적으로 만들거나, 불안정한 테스트를 더 작은 범위의 테스트로 대체할 수 있는지 확인해볼 것.

### 4.2 누가 엔드투엔드 테스트를 작성하는가?

- 합리적인 시전은 해당 서비스를 소유한 팀.
- 만약 여러 팀이 관련되어 있다면?
- 여러 사람이 테스트에 액세스할 수 있는 권한을 부여 받아 난장판이 되거나, 테스트가 실패하면 다른 사람은 문제라고 생각할 수 있음.
- 저자의 해결책은 특정 팀의 책임으로 지정하는 것. 파이프라인에 팬인 단계가 존재해도 e2e 테스트 집합을 각 팀이 소유한 기능 그룹으로 분할.

<img width="766" height="416" alt="image" src="https://github.com/user-attachments/assets/db14d786-ba47-44be-b8eb-f12ef38b162b" />

- 예시에서 웹 쇼핑의 변경은 웹 쇼핑 e2e 테스트를 트리거. 고객이 변경되는 경우 웹 쇼핑, 헬프데스트 e2e 테스트를 모두 트리거.
- 그러나 다른 팀 소유의 서비스로 테스트가 실패할 수 있다는 문제는 여전히 존재함.
- 테스트 전담팀을 둘 수도 있을 것. 그러나 개발자들이 점점 테스트 코드에서 멀어질 수 있음.
- 결국 여러 팀 간의 e2e 테스트는 굉장히 어려운 일.

### 4.3 엔드투엔드 테스트는 얼마나 오래 걸릴까?

- 저자는 6주가 걸린 것을 본적도 있음.
- 불안정한 테스트와 느린 테스트 속도가 만나면 끔직할 것.
- 불안정한 테스트를 제거하기도 쉽지 않음. 어쩌면 버그를 허용하게 될 수도 있음.
- 그러나 동일한 기능을 검증하는 복수의 테스트가 존재하고 시간이 수십분이 소요된다면 제거하는 것이 맞음.
- 이를 선별하고 실제로 제거하는 것은 분명 어려운 일.

### 4.4 대규모 적체

- 오래 걸리는 테스트를 수행하다가 실패하면 이를 수정하는 데도 오랜 시간이 소요됨.
- 모든 테스트를 성공적으로 통과한 sw 만 배포한다면 운영 환경까지 도달할 수 있는 서비스는 많지 않을 것.
- 테스트를 수정하는 동안 다른 팀의 변경이 누적되고 배포할 변경 사항의 범위도 늘어남.
- 그렇다고 문제를 수정하기 전까지 체크인을 금지하는 것은 빌드가 오랫동안 고장난 상태로 머무르고 코드 품질에 대한 빠른 피드백을 제공해주지 못하게 됨.
- 따라서 테스트 집합을 더 빠르게 만드는 것이 해답.
- e2e 테스트로 인해 작은 변경 사항을 릴리스하는 능력이 느려지면 결국 잃는 것이 많아짐.

### 4.5 메타버전

- e2e 테스트 단계를 통해 기능 작동을 확인하고서 여러 서비스들을 함께 배포하기 위해 버전 관리를 하는 것은 어떠한가?
- 이러한 버전 관리는 ms의 주요 이점인 독립적 배포 능력을 저하함.

### 4.6 독립적인 테스트 가능성 부족

- 팀이 독립적으로 일한다면 독립적으로 테스트할 수 있어야 함.
- 테스트에 사용하는 인프라스트럭처 혁시 각 팀이 독립적인 환경을 구축해야 함.

## 5. 엔드투엔드 테스트를 피해야 할까?

- 적은 수의 ms로 관리할 수 있으면 e2e 테스트는 합당함.
- 서비스 수가 늘어난다면 테스트 집합은 비대해지고 시나리오 수도 급격하게 증가함.
- 적은 수의 ms 더라도 여러 팀이 e2e 테스트를 공유하면 테스트가 어려워지고 독립적 배포 가능성도 떨어짐.
- e2e 테스트의 목적은 운영 환경에서 소비자가 중단되지 않도록 하는 것. ms 인터페이스에 대한 명시적 스키마를 통해 구조적 중단을 포착하는 것이 더 유용함.
- 물론 스키마만으로는 버전간의 비호환성으로 인한 의미적 중단을 알아내기 어려움.

### 5.1 계약 테스트와 소비자 주도 계약

- 계약 테스트는 업스트림 ms가 다운스트림 ms에 기대하는 동작 방식을 명시적 프로그래밍 방식으로 표현한 것.
- 계약 테스트(contract test) 사용시, 외부 서비스의 기대 작동 방식을 설명하는 테스트를 작성.
- 실제 외부 서비스를 사용할 때와 마찬가지로 자체 스텁에서 실행할 때도 테스트는 통과해야 함.
- 다른 ms를 실행할 필요 없이, 서비스 테스트와 동일한 테스트 범위를 가짐.

<img width="753" height="350" alt="image" src="https://github.com/user-attachments/assets/e051aaa6-4d33-4cc5-9ab5-b3244534fcf4" />

#### 대화가 중요해

- 애자일에서 스토리(story)는 api가 어떤 모습이어야 하는지, 문제가 생기면 해당 api가 어떻게 발전해야 하는지 논의하는 대화의 시작점.
- cdc(소비자 주도 계약)에는 소비자와 생산자 서비스 간의 원활한 의사소통과 신뢰가 필요함.
- 제삼자가 제공하는 서비스를 사용하는 경우 제한된 통합 테스트를 수행해야할 수 있음.

### 5.2 결론

- e2e 테스트에 포함되는 구성 요소가 많아질수록 단점도 많아짐.
- sw 품질을 검사하는 다른 메커니즘을 선호한다면 e2e 테스트는 불필요해짐.

## 6. 개발자 경험

- 스텁되지 않은 여러 ms를 연결하는 테스트에서 개발자는 어려움을 겪을 수 있음.
- 여기에는 기술 스택, 로컬 리소스 등 많은 부분이 영향을 끼침.
- 해결법 중 하나는 클라우드 환경에서 개발 및 테스트를 수행하는 것이나, 피드백 주기가 길어지고 인터넷 연결이 제한적인 환겨에서는 불가능함.
- 이상적으로는 로컬에서 실행 가능해야 함. 다른 팀이 소유한 서비스가 필요하다면 이를 모방한 스텁을 만들 수 있어야 함.

## 7. 운영 전 테스트에서 운영 중 테스트로

- 분산 시스템에서 운영 환경 도달 전에 모든 문제를 발견하기란 어려움.
- 테스트는 sw 품질이 충분하지 피드백하는 데 목적이 있음.
- 사전 운영 환경에서는 문제를 발견할 수 있는 장소가 줄어들고, sw가 사용될 가장 중요한 위치에서 sw의 품질을 테스트할 수 있는 가능성도 사라짐.
- 운영 환경에서의 테스트는 더 높은 품질의 피드백을 제공할 수 있음.

### 7.1 운영 환경 테스트 유형

- ms가 작동 중인지 알아보는 ping. 보통 운영 담당자가 처리하지만 이것도 테스트로 볼 수 있음.
- 배포된 sw가 올바르게 작동하는지 확인하는 스모크 테스트. 사용자 릴리스 전에 실행 중인 실제 sw에서 수행됨.
- 카나리아 릴리스. 제대로 작동하는지 테스트하기 위해 특정 사용자 그룹에 sw 새 버전을 릴리스.
- 가짜 사용자 행동을 주입하는 것. 가짜 회원가입, 가짜 주문. 단, 운영환경에 영향을 미칠 수 있으므로 안전하게 만들어야 함.

### 7.2 운영 환경에서 안전한 테스트 만들기

- 운영 환경 테스트가 운영 데이터를 오염시켜 문제를 일으키는 경우는 막아야 함.
- 가짜 행동 주입이 가장 관심과 주의가 필요한 테스트.

### 7.3 MTBF보다 MTTR?

- 소프트웨어 릴리스 전에 모든 문제를 파악하는 것은 얼움.
- 자동화된 테스트보다 문제 발생시 수정하는데 노력을 기울이는 것이 더 유익할 수 있음.
- 이는 mtbf(평균 무고장 시간, Mean Time Between Failure)의 최적화와 mttr(평균 수리 시간, Mean Time to Repair)의 최적화 간에 균형점으로 언급됨.
- 조직마다 둘 사이의 균형점은 다양함. 모니터링과 장애 복구 프로세스를 통해 이러한 시간을 줄일 수 있음.
- 다른 균형점도 있음. 아이디어를 증명하기 위한 제품에서 테스트는 사치임. 이런 상황에서는 테스트가 필요치 않을 것.

## 8. 교차 기능 테스트

- 앞서 살펴본 것은 기능 테스트에서 모놀리식과 ms가 어떻게 다른지에 대한 것.
- 비기능 요구 사항 또한 관심이 필요함. 이는 허용할 지연 시간, 가용할 수 있는 사용자 수, 접근성, 보안 같은 측면.
- 저자는 비기능적이라는 용어보다 교차 기능 요구사항(cfr, cross-functional requirement라는 용어를 더 좋아함. 실제 시스템의 동작이 많은 교차 작업의 결과이기 때문이라고 함.
- 즉, 대부분의 cfr은 운영환경에 종속됨.

### 8.1 성능 테스트

- 시스템을 더 작은 ms로 쪼개면 네트워크 경계를 넘나드는 호출이 증가함.
- 시나리오에 기반한 테스트를 하는 경우가 많기 때문에 시간이 꽤 소요됨.
- 실제 운영 환경과 같이 인프라를 구성하는 것도 힘든 일.
- 이 모든 것을 해결하면 병목 현상을 추적하는 데 쓸모가 있지만, 테스트 결과로 거짓 음성 또는 거짓 양성이 나올 수도 있다느 점에 유의할 것.
- 성능 문제는 테스트를 수행하지 않는 시간이 길어질수록 원인을 추적하기 어려워짐.
- 성능 테스트를 수행했으면 결과도 반드시 확인해야 함. 목표를 정하고 결과를 확인할 것.
- 이상적으로는 실제 운영 환경과 동일한 환경에서 성능 테스트를 수행해야 함.

### 8.2 견고성 테스트

- msa는 가장 취약한 링크에 의해 신뢰성이 결정됨.
- 견고성 개선을 위해 로드 밸런서 뒤에 여러 인스턴스를 배치하거나, 다운스트림 ms의 중단 상황을 피하기 위해 서킷 브레이커를 사용할 수 있음.
- 이러한 결함 상황을 테스트하는 것은 쉽지 않음. 결함을 테스트하기 위해 ms와 스텁 사이에 타임아웃을 만들어야할 수 있음.
