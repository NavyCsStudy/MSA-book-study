## 1. 핵심 원칙

### 1.1 최소 권한의 원칙

- 당사자가 필요한 기능을 수행하는 데 필요한 최소한의 액세스 권한을 필요한 기간 동안만 부여한다는 개념.
- 공격자에 의해 탈취되어도 제한된 액세스 권한 부여함.
- 탈취되기 전에 만료되면 사용할 수 없음.

### 1.2 심층 방어

- 특정 유형에 대한 보호보다 여러 보호 장치를 갖추는 것이 중요함.

- 보안 통제 유형
  - 예방형
    - 공격이 발생하지 않도록 한다. 시크릿을 안전하게 저장하고, 데이터를 암호화하고, 적절한 인증 및 권한 부여 메커니즘을 구현한다.
  - 탐지형
    - 공격 발생을 알려준다. 애플리케이션 방화벽과 침입 탐지 서비스가 좋은 예.
  - 대응형
    - 공격 중 또는 후 대응을 돕는다. 시스템 재구축 메커니즘, 데이터 백업, 사고 발생 시 의사소통 계획 수립이 중요하다.

### 1.3 자동화

- 사건 발생 후 복구에 도움을 줌.
- 보안키를 만료시키거나 교체하여 잠재적 보안 문제를 쉽게 감지할 수 있음.

### 1.4 제공 프로세스에 보안 주입

- 보안은 사후에 고려되는 사항으로 간주되는 경우가 많음.
- 악의적인 공격을 재현하는 도구, 보안 취약점을 만드는 코드를 찾는 도구, 라이브러리의 알려진 의존성 취약점을 찾아내는 다양한 도구가 있음. 이를 ci에 통합하는 것으로 쉽게 시작 가능.

## 2. 사이버 보안의 다섯 가지 기능

- 식별하라.
  - 잠재적인 공격자가 누구인지, 공격 대상이 무엇인지, 가장 취약한 곳은 어디인지.
- 보호하라.
  - 잠재적인 해커로부터 주요 자산을.
- 감지하라.
  - 최선의 노력에도 불구하고 공격이 발생했는지.
- 대응하라.
  - 나쁜 일이 발생했다는 것을 알게 되면.
- 복구하라.
  - 사고 발생 후.
 
### 2.1 식별

- 공격자 입장의 사고방식으로 행동하는 것을 위협 모델링이라 함.
- 공격자의 입장에서 내부를 바라보는 관점은 익숙한 문제를 새롭게 바라볼 수 있게 함.
- msa 에서 1~2개의 서비스에 집중하지 않고 전체적으로 살펴봐야 함.
- 안전한 정문에 집중하다 창문을 열어둬서는 안 됨.

### 2.2 보호

- 식별한 후에는 자산이 보호되는지 확인해야 함.

### 2.3 탐지

- msa 에서 장애 감지는 쉽지 않음.
- 로그 같이 원천 정보 사이즈가 증가해 문제 탐지가 더 어려움.
- 물론 도구도 같이 발전하고 있음.

### 2.4 대응

- 사고 대응 접근법의 시작은 침해 범위와 노출된 데이터를 이해하는 것.
- 노출 데이터에 개인 정보가 포함된 경우 개인정보 보호법에 명시된 프로세스를 따라야 함.

### 2.5 복구

- 시스템을 재가동하고 동일한 문제가 재발하지 않도록 배운 것을 구현하는 능력.

## 3. 애플리케이션 보안의 기초

### 3.1 자격 증명

- 제한된 자원에 대한 액세스 권한.
- msa 에서는 ms, 가상 머신, db 등 훨씬 많은 자격 증명이 필요.
- msa 특성상 귀찮다고 광범위한 권한을 가진 자격 증명을 사용하면 더 위험함.
- 자격 증명의 주요 영역 두 가지.
  - 첫째. 시스템 사용자의 자격 증명.
  - 둘째. ms 를 실행하는 데 사용하는 시크릿.
 
- 모두 교체, 폐기, 권한 제한의 문제를 고려해야 함.

#### 사용자 자격 증명

- 전통적으로는 이메일, 패스워드 같은 사용자 인증정보.
- 현대에는 제삼자 시스템을 위한 api 키를 관리하도록 확장됨.
- aws 루트 계정이 유출되면 모든 것이 파괴될 수 있음.

#### 시크릿

- ms 가 작동하는 데 필수적 정보.
- 관리를 위한 다양한 측면이 있음.
  - 생성: 처음에 시크릿을 어떻게 만드나?
  - 배포: 생성된 이후 올바른 장소에만 전달되는가?
  - 저장: 권한 당사자만 액세스할 수 있또록 저장되어 있는가?
  - 모니터링: 어떻게 사용되고 있는지 아는가?
  - 교체: 문제없이 교체할 수 있는가?
 
- 볼트같은 도구부터 aws 시크릿 매니저까지 다양한 도구가 있음.

#### 교체

- 자주 교체되는 자격 증명은 공격자가 우리 자원에 더 많은 액세스를 하기 전에 만료시킬 수 있을 것.
- 운영자 자격 증명은 시간 제한이 있는 api 키를 생성하는 것을 예로 들 수 있음.
- 물론 키 교체는 시스템 장애를 일으킬 수 있음. 그러니 광점위한 자격 증명으로 인해 예측하지 못한 문제가 발생하는 것보다 제한된 자격 증명이 더 나음.

#### 폐기

- 공격자에게 자격 증명이 유출되면 폐기하고 재생성 하는 것이 이상적.
- 중앙 집중식 시크릿 관리 도구를 사용하면 도움이 될 수 있음.
- 정기적인 자격 증명에 익숙한 시스템이라면 폐기 처리도 어렵지 않을 것.

#### 범위 제한

- 자격 증명 범위 제한은 최소 권한 원칙을 수용하는 핵심 개념.

<img width="717" height="649" alt="image" src="https://github.com/user-attachments/assets/b09be3b5-f3bd-4ecf-8a91-168969282727" />

- 읽기 전용 권한만 가지고 있다면 오남용의 영향을 제한할 수 있음.

<img width="766" height="466" alt="image" src="https://github.com/user-attachments/assets/9c001acd-9a60-460a-9fa5-67f231f964f2" />

- 각 자격 증명이 독립적이고 구체적일수록 추적하고 폐기하기 쉬워짐.
- 이 같은 체계를 갖추려면 자동화가 필수.

### 3.2 패치

- 취약점을 확인했으면 시스템을 패치하는 것은 중요함.
- 쿠버네티스를 이용해 직접 인프라를 운영하는 경우 관리해야 하는 범위가 늘어남.

<img width="644" height="599" alt="image" src="https://github.com/user-attachments/assets/d1453895-de4d-4279-9b80-481a97b9bdc1" />

- 반면 클라우드가 제공하는 관리형 k8 클러스터를 사용하면 관리해야할 범위가 줄어듬.

<img width="698" height="589" alt="image" src="https://github.com/user-attachments/assets/39b2e657-2862-4164-8087-1cefcfefbd6b" />

- 이러한 환경에서 6개월간 컨테이너 인스턴스를 변경하지 않았다는 것은 6개월 분량의 운영체제 패치가 적용되지 않은 것을 의미함.
- 라이브러리도 마찬가지로 취약점이 발생할 수 있음.
- 알려진 취약점을 파악하는 것은 쉽지 않으므로 유용한 도구를 ci 에 통합하여 빌드가 실패하도록 만들면 도움이 될 것.

### 3.3 백업

- 치명적인 오류로 db 클러스터가 지워지거나, 버그로 인해 중요한 데이터를 삭제할 수 있음. 중요한 데이터는 항상 백업해둬야 함.
- 자동화된 배포는 머신의 백업 중요성을 낮춰줌. 데이터나 로그는 여전히 높은 중요성을 가짐.
- 전통적으로 백업을 보관하는 장소는 멀리 떨어진 별도의 장소.
- 클라우드 환경에서는 별도의 클라우드 자원에 별도의 계정으로 백업하는 것을 생각해볼 수 있음.

### 3.4 재구축

- 재구축은 우리가 인지하지 못한 공격자의 영향을 제한할 수 있음.
- 재구축 능력은 자동화와 백업의 품질에 달려 있음.
- 쉬운 방법은 배포와 동일한 프로세스를 재구축에 사용하는 것. 새 버전의 컨테이너 집합을 배포하고 이전 집합을 종료하는 작업을 운영 절차로 만들면 됨.
- 직접 k8 클러스터를 관리한다면 재구축이 쉽지 않을 것.

## 4. 암묵적 신뢰 대 제로 트러스트

### 4.1 암묵적 신뢰

- 경계 내부에서 만들어진 서비스에 대한 호출을 암묵적으로 신뢰하는 것.
- 공격자가 네트워크에 침투하는 경우 인지하기 어려울 수 있음.
- 가장 흔한 내부 경계 신뢰의 형태.

### 4.2 제로 트러스트

- 이미 침해당한 환경에서 작업하고 있다고 가정하는 것.
- 적대적인 환경에서 작업하고 있다고 가정하고 안전하게 작업할 수 있도록 예방 조치를 수행해야 함.
- 이러한 면에서 제로 트러스트에서는 경계의 개념이 의미가 없음.
- ms 는 다른 ms 의 호출을 신뢰해도 되는지 평가해야 함.
- 모든 데이터는 안전하게 저장되고 암호화키는 안전하게 유지되어야 함. 또한 전송 중인 모든 민감 데이터는 암호화되어야 함.
- 제로 트러스트 사고방식 아래에서는 내부 네트워크와 외부 네트워크를 동등하게 취급하기 때문에 외부 인터넷의 내부 서비스 연결을 허용할 수 있음.
- 제로 트러스트는 기본 원칙, 개념에 해당하는 것이기 때문에 지속적으로 투자해야 하는 대상임.

### 4.3 스펙트럼

- 암묵적 신뢰와 제로 트러스트 사이의 선택은 액세스할 정보의 민감도에 따라 결정할 수 있음.
- 모든 보안 구현 비용은 위협 모델에 의해 정당화되고 주도되어야 함.
- 다음과 같이 공개, 비공개, 비밀로 정보의 수준을 나누고 접근 수준을 나누는 방식으로 제어할 수 있음.

<img width="766" height="507" alt="image" src="https://github.com/user-attachments/assets/aefac066-9abb-4a30-b4f6-7b0b0516b464" />

## 5. 데이터 보안

### 5.1 전송 중인 데이터

- 이는 통신 프로토콜의 특정에 따라 좌우됨.
- http를 사용하는 경우 tls 와 함께 https 를 사용하는 것이 당연.
- 메세지 브로커를 사용하는 경우 별도의 기술 지원 여부를 확인해야 함.
- 전송 중 데이터 보안에 관한 관심 사항은 다음과 같음.

<img width="589" height="407" alt="image" src="https://github.com/user-attachments/assets/50537fc3-8179-4103-bd6f-50abf6b993a6" />

#### 서버 신원

- 대화 중인 서버가 누구인지 확인하는 것.
- 공격자는 엔드포인트를 사칭하여 사용자가 전송하는 데이터를 탈취할 수 있음.

#### 클라이언트 신원

- 호출하는 ms 의 신원을 확인하고 인증하는 것.
- 일반적으로 클라이언트-서버 상호 인증 형태로 구현됨.
- 공용 인터넷에서는 클라이언트 장치보다는 사용자 신원을 확인하는 것이 중요함. 그러나 msa, 제로 트러스트 환경에서는 상호 인증이 중요해짐.

#### 데이터 가시성

- 중간자가 데이터를 확인할 수 있는지에 대한 가시성.
- 일반적으로 https 환경에서는 데이터를 확인할 수 없음.

#### 데이터 조작

- 중간자가 데이터를 조작하는 것. 물론 https 환경에서는 불가함.
- 공개적인 환겨에서는 hmac 을 사용해 데이터에 서명하는 방식을 사용할 수 있음.

### 5.2 보관 중인 데이터

- 보안 침해 중 다수는 공격자가 저장된 데이터를 획득하고 읽을 수 있는 것과 관련됨.
- 일반적으로 염두에 둬야할 사항은 다음과 같음.

#### 잘 알려진 것을 사용하라

- 암호화가 필요한 경우 잘 알려져있고 테스트를 거친 구현을 사용해야 함.
- 잘 알려진 알고리즘은 정기적인 메일링 및 권고 리스트에 가입해 취약점을 인지하고 최신 상태로 유지할 수 있음.

#### 암호화 대상 선택

- 모든 것을 암호화할 수는 없음.
- 오버헤드, 마이그레이션 작업은 어려움.

#### 절약하라

- 데이터를 저장하지 않으면 아무도 훔칠 수 없음.
- 정부 기관도 데이터를 요구할 수 없음.
- 필요한 만큼의 정보만 저장하는 것이 중요함.

#### 키가 전부다

- 데이터를 복호화할 때는 당사자가 동일한 키에 접근할 수 있어야 함.
- 별도의 키 볼트를 사용하거나 aws kms 같은 것을 사용할 수 있을 것.
- db 가 암호화 기능을 지원하기도 하나 이것이 유용할지는 실제 조사를 통해 파악해야 함.

#### 백업 암호화

- 민감 정보의 경우 백업 역시 암호화가 필요함.

## 6. 인증과 권한 부여

- 인증과 권한 부여는 시스템과 상호작용하는 사람, 사물에 관한 핵심 개념
- 인증받는 사람, 사물을 추상적으로 권한 주체(principal)라고 함.
- 권한 부여는 권한 주체를 허용된 행위와 매핑하는 메커니즘.
- 사용 편의성도 중요함. 이름, 패스워드를 사용한 반복적인 로그인보다는 sso 를 구현하는 방법도 살펴봐야 함.

### 6.1 서비스 간 인증

- 상호 tls 가 서비스 간 인증의 한 형태.
- api 키를 이용한 hmac 도 하나의 방식.

### 6.2 사람 인증

- 이름, 패스워드 조합에 더해 mfa(multifactor authentication) 를 사용하는 것.

### 6.3 일반적인 SSO 구현

- sso 를 이용하면 해당 세션동안 한 번의 인증으로 여러 서비스에 접근할 수 있음.
  - 권한 주체가 자원에 액세스하려고 하면 id 제공자(identity provider)에서 인증하도록 연결됨.
  - id 제공자는 이름, 패스워드, mfa 등을 사용하도록 요구할 수 있음.
  - 권한 주체가 인증됐다는 것을 확인하면 서비스 제공자(service provider)에게 정보를 제공해 액세스 권한 부여 여부를 결정할 수 있게 함.
 
### 6.4 SSO 게이트웨이

- 각 서비스 내부에서 id 제공자에 대한 리다이렉션과 핸드셰이킹을 하도록 정하면 많은 양의 중복 코드가 생길 수 있음.
- 일반적인 방식은 게이트웨이와 같은 프록시를 두는 것.

<img width="689" height="616" alt="image" src="https://github.com/user-attachments/assets/8f0b05f7-d7df-4176-ade9-3642ba0d587f" />

- 서비스 제공자는 권한 주체에 대한 정보를 http 헤더를 통해 전달받을 수 있음.
- 인증에 대한 책임을 게이트웨이로 넘기는 경우 개별 ms 가 어떻게 동작하는지 추론하기 어려울 수 있음.
- 보안을 게이트웨이에 의존하거나 게이트웨이 자체가 단일 장애 지점이 될 수 있음.
- 게이트웨이의 기능이 많아질수록 공격할 수 있는 지점도 늘어난다는 사실을 유념해야 함.

### 6.5 세밀한 권한 부여

- 게이트웨이가 인증의 결과로 권한 주체에 대한 속성을 추출할 수 있다면 세밀한 권한 부여에 도움이 됨.
- 단, 권한이 지나치게 세분화되면 유지보수하기에 쉽지 않음.
- 조직의 업무 방식을 모델링한 크게 분류된 역할을 고려해야 함. 우리는 우리 조직의 업무 방식에 맞게 sw 를 구축하고 있다는 사실을 기억할 것.

### 6.6 혼동된 대리인 문제

- ms 가 작업을 완료하기 위해 추가 호출이 필요한 경우 발생할 수 있는 문제.
- 중간 당사자를 속여 해서는 안 되는 일을 하도록 할 때 발생.

<img width="712" height="457" alt="image" src="https://github.com/user-attachments/assets/b7135d24-8d09-4a5c-911c-d60b8c01e4ea" />

- 호출이 경계 내부에서 발생했기 때문에 괜찮아보일 수 있음.
- 고객이 자신의 로그인된 자격 증명으로 다른 사람의 세부 정보를 요청하는 경우가 발생할 수 있음.
- 인증은 했지만 충분한 권한을 부여하지 않아 해결할 수 있음.
- 그렇다면 이를 판단하는 로직은 어디에 존재해야 하는가?

### 6.7 중앙 집중식 업스트림 권한 부여

- 혼동된 대리인 문제를 피하는 방법은 요청 수신 즉시 필요한 모든 권한을 부여하는 것.
- 다운스트림 ms로 전송될 때까지 요청은 허용된다고 가정.
- 이는 암묵적 신뢰를 허용하고 있음을 의미.
- 업스트림 서비스는 다운스트림 서비스가 제공하는 기능을 알고 있어야 하고 해당 기능에 대한 액세스를 제한한하는 방법을 알아야 함.
- 즉 각 ms 간의 독립성이 떨어지게 됨.

### 6.8 분산식 권한 부여

- 논리적으로 요청을 받은 서비스가 해당 호출이 유효한지 검증하는 것이 합당함.
- 보편적인 방법으로는 json 웹 토큰을 이용해 요청자를 식별하는 것.

### 6.9 JSON 웹 토큰

- jwt 를 사용하면 개인에 대한 여러 클레임(claim)을 문자열에 저장.
- 토큰은 서명을 통해 조작되지 않았음을 보장하고, 선택적인 암호화를 수행할 수도 있음.

#### 포맷

- jwt 토큰은 헤더, 페이로드, 서명이 줄바꿈 없이 점(.)을 구분자로 하여 구성됨.
- 페이로드는 json 구조로 다양한 클레임을 포함할 수 있음.
- jwt 표준은 사용자와 관련이 있을 경우 사용해야 하는 일부 필드를 지정함.

<img width="745" height="274" alt="image" src="https://github.com/user-attachments/assets/e393c714-ff47-4eff-b010-fd997129b327" />

#### 토큰 사용

- 클라이언트 장치에 저장된 로그인 세션(예. oauth2 토큰)의 요청이 게이트웨이에 도달하면 요청 기간동안 유효한 jwt 를 생성.
- 다운스트림 ms 는 토큰의 유효성을 검사하고 페이로드에서 클레임을 추출해 어떤 권한 부여가 필요한지 결정.

<img width="741" height="543" alt="image" src="https://github.com/user-attachments/assets/36b57421-91cb-4252-8330-7f87901b6d23" />

- jwt 를 클라이언트 저장 장치에 보관할 수도 있지만 탈취되는 경우를 고려해야 함.
- 요청별로 jwt 를 생성하는 것은 해당 문제에 대한 일반적인 해결책.

#### 문제점

- 첫째. 키 문제.
  - jwt 수신자는 토큰 검증을 위한 키가 필요함.
  - 볼트나 kms 를 이용해 분산 환경에서 키를 관리할 수 있음.
 
- 둘째. 토큰의 유효 기간.
  - 작업을 처리하는 데 몇 일 이상이 걸리는 비동기 프로세스가 존재할 수 있음.
  - 이러한 상황에서 동작할 수 있는 특수한 토큰을 사용할 수도 있음.
  - 명확한 해결책을 없기 때문에 논의가 필요한 문제.
 
- 셋째. jwt 의 크기.
  - 처리해야 하는 시나리오에 따라 jwt 에 많은 정보를 담아야할 수 있음.
  - 이러한 상황에서는 권한 부여 프로세스를 별도로 처리하는 것이 합리적일 수 있음.
  - 해결책 중 하나는 간단한 권한 부여에 jwt 를 사용하고, 후속 조회를 통해 추가 필드를 가져오는 것.
