## 11.1 핵심 원칙

- 보안은 가장 취약한 지점만큼만 안전
- 흔한 실수
    - 정문(JWT, TLS)은 철통 보안
    - 뒷문(기본 보안 위생)은 열려 있음
    - 목적: 특정 기술보다 보안의 기본 원칙을 이해하고 이를 마이크로서비스 맥락에 적용

### 11.1.1 최소 권한의 원칙 (Principle of Least Privilege)

- 필요한 작업에 필요한 최소 권한만, 필요한 기간 동안만 부여 → 자격 증명이 탈취돼도 피해 범위를 최소화
- 예
    - DB 읽기 전용 권한만 가진 서비스 → 탈취돼도 읽기만 가능
    - 자격 증명에 만료 시간 적용 → 탈취 후 재사용 위험 감소
- 확장: 서비스 간 통신도 허용된 마이크로서비스만 접근 가능
- 권한 축소 + 시간 제한이 핵심 전략

### 11.1.2 심층 방어 (Defense in Depth)

- 단일 방어 수단의 문제: 하나만 뚫리면 전체가 무너짐
- 심층 방어: 여러 겹의 방어 장치로 한 겹이 무너져도 다음 방어선 존재
- 마이크로서비스에서의 장점
    - 기능 분리 → 피해 확산 제한
    - 서비스별 권한 제한
    - 네트워크 세그먼트 분리
    - 다양한 기술 스택 혼용 → 단일 제로데이 취약점 영향 최소화
- 결론: 마이크로서비스는 모놀리식보다 심층 방어 구현에 유리

**📌 보안 통제 유형**

- 예방형 (Preventive): 공격 자체를 막음
- 탐지형 (Detective): 공격 발생 여부 인지
- 대응형 (Responsive): 공격 중·후 대응

⇒ 세 가지 모두 필요

### 11.1.3 자동화

- 마이크로서비스 환경: 구성 요소 증가 → 수동 관리 불가능
- 보안 측면 효과
    - 최소 권한 구현 용이
    - 키 회전 / 폐기 자동화
    - 침해 후 빠른 복구 가능
- 결론: 자동화 문화는 보안을 강화

### 11.1.4 제공 프로세스에 보안 주입

- 전통적 문제: 보안을 사후 단계로 취급 → 재작업 증가, 릴리스 지연
- 보안은 테스트, 운영, 사용성과 마찬가지로 제공 프로세스의 일부
- 필요한 변화
    - 개발자 보안 인식 향상
    - 보안 전문가의 팀 내 참여
    - 보안 개념을 코드와 도구에 내재화
- 자동화 도구 예
    - 동적 분석: OWASP ZAP
    - 정적 분석: Brakeman
    - 의존성 취약점: Snyk
- 주의: 도구는 로컬 취약점만 해결하며, 시스템 전반 보안 이해를 대체하지는 못함

## 11.2 사이버 보안의 다섯 가지 기능

- Identify → Protect → Detect → Respond(대응) → Recover
    - 장점: 보안을 전체 생명주기 관점에서 접근
- 보호에만 집착하지 말고 위협 이해부터 복구까지 고려

### 11.2.1 식별 (Identify)

- 목적
    - 누가 공격자인가?
    - 무엇을 노리는가?
    - 가장 취약한 지점은 어디인가?
- 핵심 활동: 위협 모델링
- 흔한 오류: JWT, mTLS 같은 눈에 보이는 기술 문제에만 집착
    - 가장 위험한 곳을 놓치면 보안 투자가 헛됨
- 마이크로서비스 관점
    - 아키텍처가 복잡할수록 전체 시스템 단위로 분석 필요
    - 너무 작은 범위만 보면 잘못된 안전 착각 발생
- 권장
    - 외부 관점 도입
    - 필요 시 외부 전문가 활용

### 11.2.2 보호 (Protect)

- 목표: 가장 가치 있고 취약한 자산 보호
- 마이크로서비스 특징
    - 공격 표면 증가
    - 동시에 심층 방어 기회도 증가

### 11.2.3 탐지 (Detect)

- 서비스·네트워크·로그 증가, 신호 대비 노이즈 증가 ⇒ 탐지 어려움
- 해결 수단
    - 로그 집계
    - 관찰가능성 도구
    - 침입 탐지 시스템
- 트렌드
    - 컨테이너 보안 도구 발전
    - 예: Aqua

### 11.2.4 대응 (Respond)

- 침해 인지 후 핵심 질문
    - 범위는?
    - 어떤 데이터가 노출됐는가?
- 중요 요소
    - PII(개인 식별 정보 노출 시 법적·규제 대응 필요
    - GDPR → 72시간 이내 보고 의무
- 조직 문화의 영향
    - 비난 문화 → 피해 확대
    - 개방적 문화 → 재발 방지 학습
    - 기술뿐 아니라 조직·커뮤니케이션 역량도 중요

### 11.2.5 복구 (Recover)

- 시스템 재가동 및 재발 방지 조치 반영
- 마이크로서비스는 구성 요소 많음 → 복구 복잡
- 핵심 수단
    - 자동화된 재구축
    - 백업
    - 주문형 인프라
- 목표
    - 최대한 빠른 정상화
    - 배운 교훈을 시스템에 반영

## 11.3 애플리케이션 보안의 기초

### 11.3.1 자격 증명 (Credentials)

- 마이크로서비스 환경은 **자격 증명의 수가 폭증**한다
- 관리가 어려워지면 광범위 권한의 자격 증명 남용
- 자격 증명 탈취는 가장 흔한 침해 원인

**📌 사용자 자격 증명**

1. 사용자/운영자 자격 증명
    - 이메일·패스워드, API 키, 클라우드 계정
    - 실제 침해 사고의 다수가 여기서 발생
2. 시크릿(Secrets)
    - 마이크로서비스가 동작하는 데 필요한 민감 정보

**📌 시크릿**

- TLS 인증서, SSH 키, API 키 쌍, DB 접근 계정

**시크릿 관리의 핵심 수명주기**

| 단계 | 핵심 질문 |
| --- | --- |
| 생성 | 시크릿을 어떻게 안전하게 만들 것인가 |
| 배포 | 올바른 대상에게만 전달되는가 |
| 저장 | 접근 통제가 보장되는가 |
| 모니터링 | 누가, 어떻게 사용하는가 |
| 교체 | 무중단으로 변경 가능한가 |
- 대표적인 도구
    - Kubernetes Secrets: 기본 제공, 단순한 용도
    - HashiCorp Vault: 동적 자격 증명, 시간 제한 자격, 대규모 환경에 적합
    - Cloud 제공 도구: AWS Secrets Manager, Azure Key Vault

**📌 교체(Rotation)와 폐기(Revocation)**

- 정기 교체
    - 자격 증명 탈취 시 피해 범위를 제한
    - 시간 제한 자격 증명(TTL)이 이상적
- 즉시 폐기 (유출이 의심되면 즉시 무효화)
- 이를 위해선 중앙 시크릿 관리 및 마이크로서비스의 동적 재로딩 또는 재시작 전략 필요

**📌 키 유출 방지**

- 실수로 Git에 커밋되는 경우가 매우 흔함
- 예방 도구: git-secrets, gitleaks
- 사전 커밋 훅으로 차단하는 것이 최선

**📌 범위 제한 (Scope Limiting)**

- 최소 권한 원칙의 핵심 구현
- 적용 방식:
    - 서비스별
    - 인스턴스별
    - 용도별 (읽기/쓰기 분리)
- 효과
    - 탈취 시 피해 최소화
    - 문제 발생 시 원인 추적 용이
- 단점: 자동화 없이는 관리 불가능

### 11.3.2 패치 (Patching)

- 패치 대상 계층: 인프라 (OS, VM), 컨테이너 베이스 이미지, 런타임 플랫폼 (K8s 등), 애플리케이션 코드, 제3자 라이브러리
    
    <img width="613" height="639" alt="Image" src="https://github.com/user-attachments/assets/4ac59396-b7c1-41f9-a81c-4e6b7f1c9432" />
    
- 컨테이너의 함정
    - “불변 이미지” ≠ “안전한 이미지”
    - 오래된 이미지는 OS 취약점 누적
- 대응 방법: 라이브러리 스캔 도구 사용 (Snyk, GitHub Code Scanning)
    - CI에서 취약 라이브러리 발견 시 빌드 실패

### 11.3.3 백업 (Backup)

- 데이터는 반드시 백업 (복제 ≠ 백업)
- 논리적 오류, 삭제, 공격에는 복제도 무력
- 마이크로서비스 환경의 백업 전략
    - 서버 전체 백업 X
    - 가치 있는 상태만 백업 ⇒ DB 데이터, 로그
- 운영 중단 없이 블록 레벨 스냅샷 활용
- 이때 운영 계정과 분리 ⇒ 가능하면 다른 계정, 다른 리전, 다른 클라우드

### 11.3.4 재구축 (Rebuild)

- 전제: 침해는 발생할 수 있으며, 깨끗한 재구축 능력이 핵심 방어 수단
- 전략
    - 기존 서버를 “고치지 말고” 버린다
    - 소스 코드 기반으로 재배포
    - 자격 증명 전면 교체
- 자동화의 중요성
    - 배포 자동화 = 재구축 자동화
    - 평소와 동일한 배포 프로세스로 재구축해야 실전에서도 가능

## 11.4 암묵적 신뢰 vs 제로 트러스트

### 11.4.1 암묵적 신뢰 (Implicit Trust)

- 내부 네트워크는 안전하다고 가정
- 서비스 간 호출은 인증 없이 허용
- 문제점: 내부 침투 시 전체 시스템 붕괴
- 대부분 의식 없이 채택되는 모델

### 11.4.2 제로 트러스트 (Zero Trust)

- 이미 침해당했다고 가정
- 내부/외부 구분 없음
- 모든 호출에 인증, 권한 검증, 암호화 수행
- 특징
    - 경계 개념 무의미
    - 내부 네트워크도 인터넷처럼 취급
    - 기술이 아니라 지속적인 설계 원칙

### 11.4.3 스펙트럼 접근

- 암묵적 신뢰 ↔ 제로 트러스트는 이분법 아님
    - 데이터 민감도에 따라 차등 적용
- 예: 데이터 등급별 영역 분리
    - 공개 (Public), 비공개 (Private), 비밀 (Secret / PII)
- 적용 원칙
    - 마이크로서비스는 가장 민감한 데이터 기준으로 영역 결정
    - 상위 보안 영역 → 하위 영역 접근 가능
    - 역방향 접근은 불가
- 효과
    - 보안 수준과 비용의 균형
    - 심층 방어 강화

## 11.5 데이터 보안

- 마이크로서비스 분해 → 데이터가 더 많은 시스템·위치로 분산
- 데이터는
    - 전송 중 (네트워크)
    - 보관 중 (디스크)
- 공격 표면 증가 → 데이터 보안은 애플리케이션 보안의 핵심 영역

### 11.5.1 전송 중인 데이터

전송 중 데이터 보호의 4가지 핵심 관심사

**📌 서버 신원 (Server Identity)**

- 통신 대상 서버가 진짜인지 검증
- 사칭 공격(MITM) 방지 목적
- 해결 방법
    - HTTPS = HTTP + TLS
    - 인증서를 통해 서버 신원 검증
- 내부 통신도 HTTPS 사용 가능 → SOAP, gRPC 모두 TLS 위에서 동작 가능

**📌 클라이언트 신원 (Client Identity)**

- 호출하는 업스트림 마이크로서비스의 신원 검증
- 구현 방식
    - 공유 시크릿
    - API 키
    - 클라이언트 인증서
- 주의점: 중앙 인증 서버 호출 방식은 지연 시간 문제
- 일반적인 해결책: 상호 TLS (Mutual TLS)
    - 서버 ↔ 클라이언트 상호 인증
    - 제로 트러스트 환경에서 특히 유용
- 최근 도구
    - Vault → 인증서 발급·관리 단순화
    - Service Mesh → mTLS 자동화

**📌 데이터 가시성 (Data Visibility)**

- 전송 중 데이터를 누가 볼 수 있는가
- 공개 데이터 vs 민감 데이터(PII)
- TLS 사용 시
    - 중간자(proxy, cache 등)는 데이터 열람 불가
    - HTTPS에서는 캐시 불가

**📌 데이터 조작 (Data Tampering)**

- 전송 중 데이터가 변경되지 않았는지 보장
- TLS는 기밀성 + 무결성 모두 제공
- 공개 데이터이지만 조작 방지가 필요한 경우
    - HMAC을 사용해 메시지 서명
    - 수신자는 해시 검증으로 변경 여부 확인

## 11.5.2 보관 중인 데이터

- 저장된 데이터 유출은 **대부분의 대형 보안 사고 원인**
- 심층 방어(defense in depth) 필수

**📌 잘 알려진 것을 사용하라**

- 자체 암호 알고리즘 구현 X 검증된 라이브러리·알고리즘 사용 O
- DB 자체 암호화 기능 활용 가능
- 패스워드 저장 시 솔트 기반 패스워드 해싱 필수
- 암호화 구현 오류는 “없는 것보다 더 위험”

**📌 암호화 대상 선택**

- 이상적으로는 “모든 데이터 암호화”
- 현실적 제약: 성능 오버헤드, 마이그레이션 복잡성
- 권장 접근: 민감 테이블·컬럼만 선택적 암호화

**📌 절약하라 (Datensparsamkeit)**

- 불필요한 데이터는 저장하지 않는다
- 예시: IP 일부 마스킹, 생년월일 대신 연령대
- 개인정보 최소화는 보안 + 법적 리스크 감소

**📌 키가 전부다**

- 암호화의 보안성 = 키 관리
- 데이터와 키를 같은 저장소에 보관 X
- 해결책
    - HSM / 보안 어플라이언스
    - 키 볼트 (ex. Vault)

**📌 백업 암호화**

- 운영 데이터가 암호화 대상이면 백업도 반드시 암호화

## 11.6 인증과 권한 부여

- 인증(Authentication) → “너 누구야?”
- 권한 부여(Authorization) → “너 뭐 해도 돼?”
- 인증 대상 = 권한 주체 (Principal)
- 목표
    - 보안 강화
    - 사용성 유지 (SSO)

### 11.6.1 서비스 간 인증

- 대표 방식
    - Mutual TLS
    - API 키 + 서명
- 목적
    - 호출한 서비스가 정상 서비스인지 확인

### 11.6.2 사람 인증

- 사용자 이름 + 패스워드 → 기본 요소
- MFA (다요소 인증)
    - SMS
    - 인증 앱
    - 하드웨어 키
    - 생체 인식

### 11.6.3 일반적인 SSO 구현

- 사용자 → ID 제공자(IdP)에서 인증
- IdP가 인증 결과를 서비스에 전달
- IdP 유형
    - 외부 (Google 등)
    - 내부 (LDAP, Active Directory)
- 표준
    - SAML: 복잡, 점점 감소
    - OpenID Connect + OAuth2: 현재 주류

### 11.6.4 SSO 게이트웨이

<img width="673" height="625" alt="Image" src="https://github.com/user-attachments/assets/7a8dfc6e-cc19-4658-be44-d4888b62d6b8" />

- 인증 로직을 게이트웨이로 집중
- 장점
    - 중복 제거
    - 일관된 인증 처리
- 단점
    - 단일 장애 지점
    - 서비스 단독 실행/테스트 어려움
    - 보안 책임을 게이트웨이에 과도하게 집중
- 주의
    - 게이트웨이에 기능 과적 X
    - 공격 표면 증가

### 11.6.5 세밀한 권한 부여

- 게이트웨이: 거친 인증
- 세부 권한은 마이크로서비스가 판단
- 역할 설계 원칙
    - 조직의 업무 구조를 반영한 거친 역할
    - 지나치게 세분화된 역할 X
- 이유
    - 서비스 독립성 유지
    - 수명주기 분리

### 11.6.6 혼동된 대리인 문제 (Confused Deputy)

- 인증된 사용자가 시스템을 속여 허용되지 않은 작업 수행
- 원인: 인증은 됐지만 권한 검증이 충분하지 않음
- 예: 로그인한 사용자가 다른 사람의 주문 정보 조회

### 11.6.7 중앙 집중식 업스트림 권한 부여

- 요청 초기에 모든 권한 검사
- 문제점
    - 암묵적 신뢰 발생
    - 게이트웨이가 서비스 내부 기능을 알아야 함
    - 배포 독립성 저하

### 11.6.8 분산식 권한 부여

- 권한 판단을 해당 마이크로서비스로 이동
- 필요 조건: 요청자의 신뢰 가능한 신원 정보 전달
- 단순 헤더 전달 X ⇒ JWT

### 11.6.9 JSON 웹 토큰 (JWT)

- 서명된 토큰으로 사용자 정보, 역할·그룹, 만료 시간 전달
- 변조 방지 + 선택적 암호화

**📌 포맷**

- Header
- Payload
- Signature

**📌 토큰 사용**

- 사용자 인증 → 게이트웨이
- 게이트웨이 → 요청별 JWT 발급
- 다운스트림 서비스
    - 서명 검증
    - 클레임 기반 권한 판단
- 효과
    - 분산 권한 부여 단순화
    - 서비스 독립성 강화

**📌 문제점**

1. 키 관리
    - 공개 키 배포·로테이션 필요
    - Vault 등 활용
2. 토큰 수명
    - 장시간 비동기 작업과 충돌
    - 상황별 토큰 전략 필요
3. 토큰 크기
    - 너무 많은 클레임은 비효율
    - 기본 JWT + 필요 시 추가 조회 전략