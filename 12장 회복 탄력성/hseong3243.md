## 1. 회복 탄력성이란?

- 견고성(robustness): 예상되는 변동을 흡수하는 능력.
- 회복성(rebound): 충격적인 사건 이후 회복하는 능력.
- 원한만 확장성(graceful extensibility): 예상치 못한 상황에서 대처하는 능력.
- 지속적인 적응력(sustained adaptability): 변화하는 환경, 이해관계자, 요구 사항에 지속적으로 적응하는 능력.

### 1.1 견고성

- 예상되는 문제를 수용하기 위해 sw와 프로세스에 메커니즘을 구축하는 개념.
- msa 는 호스트 고장, 네트워크 지연 등 많은 변동 사항이 존재.
- 호스트 자동 교체, 재시도 수행 등 다양한 방법으로 견고성을 개선할 수 있음.
- 견고성 개선은 예지력에 기반을 두거나, 문제가 발생한 뒤 뒤늦은 깨달음을 통해서도 시작될 수 있음.
- 문제는 애플리케이션 견고성이 높을수록 시스템에 복잡성이 추가됨. 따라서 비용과 이점에 대한 분석이 필요.

### 1.2 회복성

- 중단으로부터 얼마나 잘 복구되는가.
- 장애 가능성을 제거하는데 비용을 쏟지만 장애 발생 후 준비가 되어 있지 않을 수 있음.
- 시스템이 커질수록 잠재적인 문제를 제거하기는 어려움.
- 장애 발생 시 자기 역할, 처리 담당자, 사용자와의 소통 등 사전에 행동 계획을 세우면 더 잘 회복하는데 도움이 됨.

### 1.3 원만한 확장성

- 예측하지 못하는 상황을 대처하는 능력.
- 책임이 분산된 수평 조직이 예기치 못한 상황에 더 잘 대처할 수 있음.
- 시스템 최적화의 노력이 취약성을 증가시킬 수 있음. 자동화는 편리하지만 돌발 상황을 처리하지 못함.
- 예상치 못한 상황에 대한 대처 능력은 기술, 경험, 책임을 갖춘 사람을 배치하는데서 비롯됨.

### 1.4 지속적인 적응력

- 전체적인 관점이 중요함.
- 징계에 대한 두려움 없이 자유롭게 정보를 공유하는 환경을 중시하는 문화는 장애로부터 학습을 장려하는 데 필수.
- 모르는 것을 발견하려면 투자를 통해 지속적인 적응력을 조직 전략 및 문화의 핵심 부분으로 만들어야 함.

### 1.5 그리고 마이크로서비스 아키텍처

- 회복 탄력성은 시스템을 구축하고 운영하는 사람들의 속성.

## 2. 장애는 어디서나 발생한다

- 일정 이상의 규모에서는 고장을 피할 수 없음.
- 고장 가능성을 받아들인다면 불가피한 일을 막는 것보다, 이를 처리하는데 더 많은 시간을 할애할 수 있음.
- 실패할 가능성을 이해하는 것은 시스템 견고성을 개선하는 핵심.

## 3. 얼마나 많아야 너무 많은 건가?

- 인트라넷을 위한 무중단 배포는 불필요.
- 얼마나 많은 실패를 허용할지는 시스템의 사용자에 의해 결정됨.
- 몇 가지 일반적인 교차 기능을 정의하고 특정 사용 사례에 대해 재정의하는 것이 좋음.

#### 응답 시간/지연 시간

- 부하 증가가 응답 시간에 주는 영향은 사용자 수로 측정하는 것이 유용함.
- 모니터링되는 응답의 특정 백분위수에 대한 목표를 설정하면 도움됨.
- 목표 대상에는 sw 가 처리할 동시 접속 및 사용자 수가 포함되어야 함.
- 예. 초당 200개의 동시 접속을 처리할 때 응답 시간의 90%가 2초 미만을 유지할 것으로 예상된다.

#### 가용성

- 사용자는 우리 서비스에 의존할 수도, 그렇지 않을 수도 있음.
- 서비스 다운타임 기간을 측정하는 것은 보고 기록 관점에서 더 유용함.

#### 데이터 내구성

- 데이터 내구성에 대한 정도는 상황에 따라 변경될 수 있음.
- 금융 거래 기록은 수년 동안 보관해야 함.

<br/>

- 이러한 정보를 서비스 수준 목표(slo)로 명확히 표현하는 것은 요구 사항을 sw 제공 프로세스의 핵심 부분으로 자리 잡게 할 좋은 방법

## 4. 기능 저하

- 회복 탄력성에서 기능이 여러 ms 에 분산되어 있는 경우, 기능을 안전하게 저하시킬 수 있는 능력이 중요.
- 비즈니스 관점에서 주문 접수가 정상이라면 재고 수준을 보여주는 것은 덜 중요할 수 있음.
- 비즈니스 맥락을 이해하지 못한다면 어떤 조치를 취해야 하는지 이해할 수 없음.
- 여러 다운스트림 ms 에 의존하는 서비스는 협업하는 ms 가 다운되었을 때 어떻게 해야하는지 자문하며 무엇을 할지 알고 있어야 함.

## 5. 안정성 패턴

- 문제가 발생하는 하나의 시스템이 전체 시스템을 무너뜨려서는 안됨.
- 하나의 시스템이 느려지면서 커넥션 풀이 고갈되고 다른 시스템으로의 요청까지 동시에 마비될 수 있음.

<img width="732" height="417" alt="image" src="https://github.com/user-attachments/assets/50ca3227-826d-4977-8696-5c90c64c14e8" />

- 타임아웃 설정이 올바르게 되어있더라도 모든 시스템은 커넥션 풀을 공유하면 언제든지 문제가 발생할 수 있음.

### 5.1 타임아웃

- 너무 오래 기다리게 되면 전체 시스템 속도가 느려짐. 너무 빨리 초과되면 성공할 수 있는 호출을 실패로 간주하게 됨.

<img width="602" height="433" alt="image" src="https://github.com/user-attachments/assets/7415283c-fb4b-477a-ab2d-27a69fbe5da1" />

- 타임아웃이 30초로 설정되도 사용자는 기다리는 않음. 어느시점엔가 사용자는 새로고침을 하고 새로운 요청이 시스템으로 들어옴.
- 다운스트림 서비스에 대한 정상 상태의 응답 시간을 활용해 임계값을 결정할 것.
- 타임아웃은 전체 시스템에 대해 고려되어야 함. 전체 예산을 설정하고 이를 초과하면 연산 전체를 중단시키는 것이 합리적.

### 5.2 재시도

- 일부 다운스트림 호출 문제는 일시적.
- http api 호출 시 503, 504 가 반환되는 경우는 일적으로 간주하여 재시도하는 것이 적절함.
- 재시도에는 지연 시간을 두는 것이 좋음. 요청을 한 번에 쏟아내는 것은 좋지 않음.
- 다운스트림 호출에 대한 타임아웃이 500ms 일 때, 타임아웃 지연시간으로 인해 3초 넘게 기다리는 것은 적절하지 않음. 전체 타임아웃 예산에 따라서 예산을 초과한 요청은 적절하게 끊을 수 있어야 함.

### 5.3 벌크헤드

- 다운스트림 시스템 호출 별로 서로 다른 커넥션 풀을 사용한도록 벌크헤드(격벽)을 만들면 서로 영향 받지 않게 많들 수 있을 것.

<img width="537" height="303" alt="image" src="https://github.com/user-attachments/assets/c739f83e-735e-43f2-b256-e86133e12cee" />

- 관심사의 분리도 벌크헤드를 구현하는 한 가지 방법.
- 벌크 헤드는 타임아웃, 서킷 브레이커와 달리 처음부터 자원이 제한 되는 것을 방지할 수 있음.
- 병목 현상 방지를 위해 자원이 포화되지 않도록 거부할 수 있는 기능을 제공할 수도 있으며 이를 로드 셰딩(load shedding)이라고 함.

### 5.4 회로 차단기

- 서킷 브레이커는 부정적인 영향을 미칠 더 많은 호출로부터 다운스트림 서비스를 보호하기 위해 벌크헤드를 봉쇄하는 자동 메커니즘으로 생각할 수 있음.
- 일반적으로 실패는 타임아웃, 500 번대 응답을 의미. 일정횟수 이상 실패하면 트래픽 전송을 중단하고 빠르게 실패하기 시작함.

<img width="702" height="468" alt="image" src="https://github.com/user-attachments/assets/b52216e2-8480-4f1c-b1cf-41b3304a2d3d" />

<img width="673" height="553" alt="image" src="https://github.com/user-attachments/assets/7cfde337-56a9-4938-9742-65eb2a9e248b" />

- 빠르게 실패하는 것은 느리게 실패하는 것보다 좋음.

### 5.5 격리

- 다른 ms 에 의존할 수록 작업 수행 능력에 더 많은 영향을 미침.
- 서비스 간 격리는 팀 간의 조정 작업을 줄이고, 자신들의 서비스를 자유롭게 발전시킬 수 있게 만듬.
- ms 를 서로 다른 머신에서 실행하면 효과적으로 격리할 수 있음. 그만큼 비용이 늘어나기 때문에 적절한 절충점을 찾는 것이 중요함.

### 5.6 이중화

- 이중화의 필요성은 각 구성 요소의 잠재적인 장애 모드, 해당 기능을 사용하지 못할 때의 영향, 추가 비용 등을 얼마나 잘 이해하고 있는지에 따라 달라짐.
- 복사본을 보유하는 것은 이중화는 물론 스케일 아웃에도 도움이 될 수 있음.

### 5.7 미들웨어

- 메세지 브로커의 유용한 특성 중 하나는 전달을 보장하는 것.

### 5.8 멱등성

- 연산에 멱등성이 있다면 부정적인 영향 없이 호출을 여러 번 반복할 수 있음.
- 멱등성은 여러 서비스 인스턴스가 이벤트를 구독하는 경우 유용함.

## 6. 위험 분산

- 오늘날의 호스트는 가상의 개념. 서로 다른 호스트에서 실행되는 서비스가 사실은 동일한 물리 머신에서 실행되는 것일 수 있음.
- aws 는 리전으로 분리되어 있으며, 각 리전은 별개의 클라우드라고 볼 수 있음. 리전은 2개 이상의 가용 영역으로 구성되고, 데이터 센터에 해당함. aws 를 사용한다면 서로 다른 가용 영역, 더 신경쓴다면 서로 다른 리전에 서비스를 배치해 위험을 분산해야 함.

## 7. CAP 정리

- 일관성: 여러 노드의 응답은 일관적이어야 한다.
- 가용성: 모든 요청은 항상 응답 받을 수 있어야 한다.
- 단절내성: 통신이 가끔 불가능하다는 사실을 처리할 수 있어야 한다.

- 다음의 시스템에서 데이터 센터 간 네트워크 링크가 끊어지면 어떻게 되는가?
<img width="697" height="633" alt="image" src="https://github.com/user-attachments/assets/700f078f-632c-416b-a987-cb00baffcb10" />

### 7.1 일관성 희생

- AP 시스템.
- 두 노드 모두 요청을 처리할 수 있고, 단절됨에도 계속 실행.
- 그러나 서로 다른 응답으로 인해 일관성을 잃게 됨.
- 현실적으로 네트워크 장애가 없어도 데이터 복제는 즉각적이지 않음. 이처럼 미래 어느 시점에 모든 노드가 업데이트 된 데이터를 볼 수 있길 기대하는 것을 최종적 일관성(eventual consistency)라고 함.

### 7.2 가용성 희생

- CP 시스템.
- 일관성을 지키고자 한다면 유일한 선택은 모든 요청의 응답을 거부하는 것.
- 데이터 베이스 노드를 다시 동기화할 수 있을 때까지 서비스가 기능을 저하시키는 방법을 찾아야 함.
- 일관성을 보장하기 위해서는 여러 노드에 걸친 트랜잭션 읽기를 시작해야 함. 즉, 락이 필요.
- 저자가 권하길 필요하지 않다면 직접 개발하기 말 것.

### 7.3 단절내성 희생?

- CA 시스템.
- 시스템에 단절내성이 없다면 네트워크를 통해 실행할 수 없음.
- 로컬에서 작동하는 단일 프로세스. 즉, 존재할 수 없음.

### 7.4 AP 아니면 CP?

- 무엇이 필요할지는 상황에 따라 다름.
- 재고 시스템의 기록이 5분 정도는 최신 상태가 아니어도 괜찮은가?
- 은행 잔고가 최신 상태가 아니어도 괜찮은가?

### 7.5 양자택일이 아니다

- 전체 시스템이 ap 나 cp 일 필요는 없음.
- 고객이 최신 상태가 아닌 잔액을 보는 것은 상관없음. 그러나 잔액을 업데이트할 때는 최신 상태의 잔액을 알아야 함.
- 상황에 맞는 절충안을 찾고 개별 기능에 적절하게 적용해야 함.

### 7.6 그리고 현실에서는

- 시스템이 일관성을 유지한다고 해서 현실 세계의 기록을 정확하게 보관할 수는 없음.
- 모종의 사건으로 인해 시스템에 기록된 재고와 현실 세계의 재고는 달라질 수 있음.
- 즉, cp 시스템이 모든 문제를 해결해주지는 않음. 다양한 상황에서 주로 ap 시스템이 선택되는 이유임.

## 8. 카오스 엔지니어링

- 카오스 엔지니어링은 실제 환경에서 격동적인 조건을 견뎌내는 시스템의 능력에 신뢰를 구축하기 위해 시스템을 실험하는 분야.
- 여기서 시스템은 사람, 프로세스, 문화, 제품을 만드는데 필요한 sw 와 인프라를 포함하는 광범위한 개념.

### 8.1 게임 데이

- 특정 이벤트에 대한 준비 상태를 테스트하는 것.
- 사전에 계획하고 기습적으로 실시해 사람과 프로세스를 테스트하는 기회를 제공.

### 8.2 운영 환경의 실험

- 장애 대응 계획을 세우는 것과 실제로 장애를 처리할 수 있는지 여부는 별개의 문제.
- 넷플릭스는 실제 시스템에서 도구를 사용해 장애를 유도함.
- 카오스 몽키: 하루 중 특정 시간 동안 운영 중인 모든 머신을 무작위로 종료.
- 카오스 고릴라: 전체 가용 영역을 제거.
- 지연 시간 몽키: 시스템 간 느린 네트워크 연결을 시뮬레이션.

### 8.3 견고성을 넘어

- 좁은 의미에서 카오스 엔지니어링은 애플리케이션의 견고성을 개선하는데 유용함.
- 카오스 엔지어링 도구를 시스템의 회복 탄력성에 의문을 제기하는 접근 방식으로 활용하몀 더 넓게 적용될 가능성이 높음.

## 9. 비난

- 장애 발생 후 비난하는 문화는 일이 잘못됐을 때 누군가 앞으로 나서지 않는 문화로 이어짐.
- 실패로부터 배울 기회를 잃어버리고 동일한 문제가 재발되는 상황을 조성함.
- 회복 탄력성을 확보하기 위해서는 시스템 약점을 끝없이 탐구하려는 노력이 필요. 이를 위해 배움의 문화가 필요하고, 최악의 상황에도 수집한 정보를 활용해 문제 재발 가능성을 줄이는 환경을 조성하기 위해 최선을 다해야 함.
